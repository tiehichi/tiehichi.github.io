<!DOCTYPE html>
<html>
  <!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  
  <title>Linux进程栈空间大小 - Tiehichi&#39;s Blog</title>
  <link rel="icon" href="https://imgur.com/pPCZVX8.png" type="image/x-icon">
  <link href="https://fonts.googleapis.com/css?family=Bungee+Inline|Noto+Sans+SC|Ubuntu+Mono&display=swap" rel="stylesheet">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  
  <meta name="keywords" content=>
  
  
  
    <link rel="alternate" href="/atom.xml " title="Tiehichi&#39;s Blog" type="application/atom+xml">
  

  <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <div class="container">
      <header class="header">
  <div class="blog-title">
    <a href="/" class="logo">Tiehichi&#39;s Blog</a>
    <div class="subtitle"></div>
  </div>
  <nav class="navbar">
    <ul class="menu">
      
        <li class="menu-item">
          <a href="/" class="menu-item-link">Home</a>
        </li>
      
        <li class="menu-item">
          <a href="/categories" class="menu-item-link">Categories</a>
        </li>
      
        <li class="menu-item">
          <a href="/about" class="menu-item-link">About</a>
        </li>
      
        <li class="menu-item">
          <a href="/atom.xml" class="menu-item-link">RSS</a>
        </li>
      
    </ul>
  </nav>
</header>
<script>
  var link="";
  var a = document.getElementsByTagName('img');
  for(i=0;i<a.length;i++){
    a[i].referrerPolicy='no-referrer';
    link = a[i].src;
    a[i].src = link+'?t='+Math.random();
  }
</script>

<article class="post">
  <div class="post-title">
    <h1 class="article-title">Linux进程栈空间大小</h1>
  </div>

  <!-- 文章目录 -->
  <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#内核栈"><span class="toc-text">内核栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#用户栈大小"><span class="toc-text">用户栈大小</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#用户栈虚拟地址空间最大值"><span class="toc-text">用户栈虚拟地址空间最大值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#当前用户栈虚拟地址空间大小"><span class="toc-text">当前用户栈虚拟地址空间大小</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#栈顶地址随机化"><span class="toc-text">栈顶地址随机化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程的用户栈"><span class="toc-text">线程的用户栈</span></a></li></ol>

  <div class="post-content">
    <p>分析过程基于<code>Linux kernel 3.18.120</code></p>
<h2 id="内核栈"><a href="#内核栈" class="headerlink" title="内核栈"></a>内核栈</h2><p><code>Linux</code>上进程的相关属性在内核中表示为<code>task_struct</code>，该结构体中<code>stack</code>成员指向进程内核栈的栈底：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">void</span> *<span class="built_in">stack</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道<code>Linux</code>的子进程创建都是通过复制父进程的<code>task_struct</code>来进行的，所以可以从系统的0号进程着手分析进程内核栈的大小；0号进程为<code>init_task</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> <span class="title">init_task</span> = <span class="title">INIT_TASK</span>(<span class="title">init_task</span>);</span></span><br></pre></td></tr></table></figure>

<p>来看看<code>init_task</code>的<code>stack</code>字段的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_TASK(tsk)  \</span></span><br><span class="line">&#123;                                   \</span><br><span class="line">    ...</span><br><span class="line">    .<span class="built_in">stack</span>      = &amp;init_thread_info,                \</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">#define init_thread_info    (init_thread_union.thread_info)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">union</span> thread_union init_thread_union;</span><br></pre></td></tr></table></figure>

<p><code>init_task</code>的<code>stack</code>字段实际上指向thread_union联合体中的<code>thread_info</code>，再来看一下<code>thread_union</code>的结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> thread_union &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> <span class="title">thread_info</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">stack</span>[THREAD_SIZE/<span class="keyword">sizeof</span>(<span class="keyword">long</span>)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所以<code>init_task</code>进程的内核栈就是<code>init_thread_union.stack</code>，而<code>thread_info</code>位于内核栈的栈底；内核栈声明为<code>unsigned long</code>类型的数组，其实际大小与平台相关，即为<code>THREAD_SIZE</code>的定义；对于<code>arm32</code>平台，它的定义为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* arch/arm/include/asm/thread_info.h */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_SIZE_ORDER   1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_SIZE     (PAGE_SIZE &lt;&lt; THREAD_SIZE_ORDER)</span></span><br></pre></td></tr></table></figure>

<p>而<code>PAGE_SIZE</code>的定义为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* arch/arm/include/asm/page.h */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SHIFT      12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE       (_AC(1,UL) &lt;&lt; PAGE_SHIFT)</span></span><br></pre></td></tr></table></figure>

<p>所以对于<code>arm32</code>平台，<code>PAGE_SIZE</code>大小为<code>4k</code>，<code>THREAD_SIZE</code>大小为<code>8k</code>；此时可以确定 <strong><code>init_task</code>的内核栈大小为<code>8k</code></strong>。</p>
<p>前面提到进程的创建是在内核中拷贝父进程的<code>task_struct</code>，来看一下这部分代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct task_struct *<span class="title">dup_task_struct</span><span class="params">(struct task_struct *orig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> *<span class="title">ti</span>;</span></span><br><span class="line">    <span class="keyword">int</span> node = tsk_fork_get_node(orig);</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    tsk = alloc_task_struct_node(node);</span><br><span class="line">    ...</span><br><span class="line">    ti = alloc_thread_info_node(tsk, node);</span><br><span class="line">    ...</span><br><span class="line">    err = arch_dup_task_struct(tsk, orig);</span><br><span class="line">    ...</span><br><span class="line">    tsk-&gt;<span class="built_in">stack</span> = ti;</span><br><span class="line">    ...</span><br><span class="line">    setup_thread_stack(tsk, orig);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在复制<code>task_struct</code>的时候，新的<code>task_struct-&gt;stack</code>通过<code>alloc_thread_info_node</code>来分配：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct thread_info *<span class="title">alloc_thread_info_node</span><span class="params">(struct task_struct *tsk,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> = <span class="title">alloc_kmem_pages_node</span>(<span class="title">node</span>, <span class="title">THREADINFO_GFP</span>,</span></span><br><span class="line"><span class="class">                          <span class="title">THREAD_SIZE_ORDER</span>);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> page ? page_address(page) : <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里<code>THREAD_SIZE_ORDER</code>为<code>1</code>，所以分配了<code>2</code>个<code>page</code>，所以我们可以确定，进程的内核栈大小为<code>8k</code>。</p>
<h2 id="用户栈大小"><a href="#用户栈大小" class="headerlink" title="用户栈大小"></a>用户栈大小</h2><h3 id="用户栈虚拟地址空间最大值"><a href="#用户栈虚拟地址空间最大值" class="headerlink" title="用户栈虚拟地址空间最大值"></a>用户栈虚拟地址空间最大值</h3><p>通过<code>ulimit</code>命令可以查看当前系统的进程用户栈的虚拟地址空间上限，单位为<code>kB</code>；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~ <span class="comment"># ulimit -s</span></span><br><span class="line">8192</span><br></pre></td></tr></table></figure>

<p>即当前系统中，用户栈的虚拟地址空间上限为<code>8M</code>；为了确认这个值的出处，使用<code>strace</code>，确认<code>ulimit</code>执行过程中，使用了哪些系统调用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-&gt; % strace sh -c <span class="string">"ulimit -s"</span></span><br><span class="line">...</span><br><span class="line">prlimit64(0, RLIMIT_STACK, NULL, &#123;rlim_cur=8192*1024, rlim_max=RLIM64_INFINITY&#125;) = 0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>接着到内核中查找该系统调用的实现，函数名为<code>SYSCALL_DEFINE4(prlimit64, .......)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* kernel/sys.c */</span></span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE4(prlimit64, <span class="keyword">pid_t</span>, pid, <span class="keyword">unsigned</span> <span class="keyword">int</span>, resource,</span><br><span class="line">        <span class="keyword">const</span> struct rlimit64 __user *, new_rlim,</span><br><span class="line">        struct rlimit64 __user *, old_rlim)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    tsk = pid ? find_task_by_vpid(pid) : current;</span><br><span class="line">    ...</span><br><span class="line">    ret = do_prlimit(tsk, resource, new_rlim ? &amp;<span class="keyword">new</span> : <span class="literal">NULL</span>,</span><br><span class="line">            old_rlim ? &amp;old : <span class="literal">NULL</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数的第一个参数为<code>pid</code>，第二个参数为资源的索引；这里可以理解为查找<code>pid</code>为<code>0</code>的进程中，<code>RLIMIT_STACK</code>的值；函数查找到<code>pid</code>对应的<code>task_struct</code>，然后调用<code>do_prlimit</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* kernel/sys.c */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_prlimit</span><span class="params">(struct task_struct *tsk, <span class="keyword">unsigned</span> <span class="keyword">int</span> resource,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct rlimit *new_rlim, struct rlimit *old_rlim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> *<span class="title">rlim</span>;</span></span><br><span class="line">    ...</span><br><span class="line">    rlim = tsk-&gt;signal-&gt;rlim + resource;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>do_prlimit</code>的实现为我们指明了到何处去查找<code>RLIMIT_STACK</code>的值，即<code>tsk-&gt;signal-&gt;rlim + resource</code>；我们知道0号进程为<code>init_task</code>，所以找到<code>init_task-&gt;signal-&gt;rlim</code>进行确认</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* include/linux/init_task.h */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_TASK(tsk)  \</span></span><br><span class="line">&#123;  </span><br><span class="line">    ...</span><br><span class="line">    .signal        = &amp;init_signals,                \</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">#define INIT_SIGNALS(sig) &#123;                     \</span><br><span class="line">    ...</span><br><span class="line">    .rlim       = INIT_RLIMITS,                 \</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着找到<code>INIT_RLIMITS</code>宏的定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* include/asm-generic/resource.h */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_RLIMITS                            \</span></span><br><span class="line">&#123;                                   \</span><br><span class="line">    ...</span><br><span class="line">    [RLIMIT_STACK]      = &#123;       _STK_LIM,  RLIM_INFINITY &#125;,   \</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_STK_LIM</code>即为当前系统中，进程用户栈的虚拟地址空间上限：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* include/uapi/linux/resource.h */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _STK_LIM    (8*1024*1024)</span></span><br></pre></td></tr></table></figure>

<h3 id="当前用户栈虚拟地址空间大小"><a href="#当前用户栈虚拟地址空间大小" class="headerlink" title="当前用户栈虚拟地址空间大小"></a>当前用户栈虚拟地址空间大小</h3><p>可以从<code>proc</code>文件系统中，查看进程的虚拟地址空间分布；以<code>init</code>进程为例，其<code>pid</code>为1，可以通过以下命令查看<code>init</code>进程的虚拟地址空间分布，在<code>arm32</code>平台，内核版本<code>3.18.120</code>，<code>init</code>进程的用户栈空间大小为<code>132kB</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~ <span class="meta"># cat /proc/1/smaps</span></span><br><span class="line">...</span><br><span class="line">beec2000-beee3000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>          [<span class="built_in">stack</span>]</span><br><span class="line">Size:                <span class="number">132</span> kB</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>仔细观察会发现，任意进程在启动后，其栈空间大小基本都是<code>132kB</code>；在分析原因之前，我们先来看一下进程的虚拟地址空间分布：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1679957/1619073769696-a162481e-6c27-4cab-a313-2b3229285ccd.png" alt="进程虚拟地址空间-进程虚拟地址空间.png"></p>
<p>进程的虚拟地址空间大小为<code>4GB</code>，其中内核空间<code>1GB</code>，用户空间<code>3GB</code>，在<code>arm32</code>平台上，二者之间存在一个大小为<code>16M</code>的空隙；用户空间的准确大小为<code>TASK_SIZE</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* arch/arm/include/asm/memory.h */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_SIZE       (UL(CONFIG_PAGE_OFFSET) - UL(SZ_16M))</span></span><br></pre></td></tr></table></figure>

<p>即用户空间的地址范围为<code>0x00000000~0xBEFFFFFF</code>。</p>
<p>上图左侧为用户空间内的虚拟空间分布，分别为：用户栈（向下增长），内存映射段（向下增长），堆（向上增长）以及<code>BSS</code>、<code>Data</code>和<code>Text</code>；我们关注的重点在用户空间中的栈空间。</p>
<p>在Linux系统中，运行二进制需要通过exec族系统调用进行，例如<code>execve</code>、<code>execl</code>、<code>execv</code>等，而这些函数最终都会切换到<code>kernel space</code>，调用<code>do_execve_common()</code>，我们从这个函数开始分析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_execve_common</span><span class="params">(struct filename *filename,</span></span></span><br><span class="line"><span class="function"><span class="params">                struct user_arg_ptr argv,</span></span></span><br><span class="line"><span class="function"><span class="params">                struct user_arg_ptr envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    file = do_open_exec(filename);      <span class="comment">// 在内核中打开可执行文件</span></span><br><span class="line">    ...</span><br><span class="line">    retval = bprm_mm_init(bprm);        <span class="comment">// 初始化进程内存空间描述符</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* 拷贝文件名、环境变量和执行参数到bprm */</span></span><br><span class="line">    retval = copy_strings_kernel(<span class="number">1</span>, &amp;bprm-&gt;filename, bprm);</span><br><span class="line">    ...</span><br><span class="line">    retval = copy_strings(bprm-&gt;envc, envp, bprm);</span><br><span class="line">    ...</span><br><span class="line">    retval = copy_strings(bprm-&gt;argc, argv, bprm);</span><br><span class="line">    ...</span><br><span class="line">    retval = exec_binprm(bprm);         <span class="comment">// 处理bprm</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数中的<code>bprm</code>是类型为<code>struct linux_binprm</code>的结构体，主要用来存储运行可执行文件时所需要的参数，如虚拟内存空间<code>vma</code>、内存描述符<code>mm</code>、还有文件名和环境变量等信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linux_binprm</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> p; <span class="comment">/* current top of mem */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> argc, envc;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * filename;  <span class="comment">/* Name of binary as seen by procps */</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接着回到<code>do_execve_common</code>函数，在调用<code>bprm_mm_init</code>初始化内存空间描述符时，第一次为进程的栈空间分配了一个页：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 文件：fs/exec.c</span></span><br><span class="line"><span class="comment"> * 函数调用关系：do_execve_common()-&gt;bprm_mm_init()-&gt;__bprm_mm_init()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __bprm_mm_init(struct linux_binprm *bprm)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    vma-&gt;vm_end = STACK_TOP_MAX;</span><br><span class="line">    vma-&gt;vm_start = vma-&gt;vm_end - PAGE_SIZE;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>vma</code>就是进程的栈虚拟地址空间，这段<code>vma</code>区域的结束地址设置为<code>STACK_TOP_MAX</code>，大小为<code>PAGE_SIZE</code>；这两个宏的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* arch/arm/include/asm/processor.h */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_TOP_MAX   TASK_SIZE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* arch/arm/include/asm/memory.h */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_SIZE       (UL(CONFIG_PAGE_OFFSET) - UL(SZ_16M))       <span class="comment">// CONFIG_PAGE_OFFSET定义为0xC0000000</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* arch/arm/include/asm/page.h */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SHIFT      12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE       (_AC(1,UL) &lt;&lt; PAGE_SHIFT)</span></span><br></pre></td></tr></table></figure>

<p>此时，进程的栈空间如下图所示：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1679957/1619073695987-abd6cd30-9cd7-4f21-a9cb-25e66030609f.png" alt="进程虚拟地址空间-bprm_mm_init.png"></p>
<p>继续回到<code>do_execve_common()</code>函数，到目前为止，内核还没有识别到可执行文件的格式，也没有解析可执行文件中各个段的数据；在<code>exec_binprm()</code>中，会遍历在内核中注册支持的可执行文件格式，并调用该格式的<code>load_binary</code>方法来处理对应格式的二进制文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 文件：fs/exec.c</span></span><br><span class="line"><span class="comment"> * 函数调用关系：do_execve_common()-&gt;exec_binprm()-&gt;search_binary_handler()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search_binary_handler</span><span class="params">(struct linux_binprm *bprm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> *<span class="title">fmt</span>;</span></span><br><span class="line">    ...</span><br><span class="line">    list_for_each_entry(fmt, &amp;formats, lh) &#123;</span><br><span class="line">        ...</span><br><span class="line">        retval = fmt-&gt;load_binary(bprm);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>search_binary_handler()</code>会依次调用系统中注册的可执行文件格式<code>load_binary()</code>方法；<code>load_binary()</code>方法中会自行识别当前二进制格式是否支持；以<code>ELF</code>格式为例，其注册的<code>load_binary</code>方法为<code>load_elf_binary()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* fs/binfmt_elf.c */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">load_elf_binary</span><span class="params">(struct linux_binprm *bprm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loc-&gt;elf_ex.e_phnum; i++) &#123;</span><br><span class="line">        ...</span><br><span class="line">            retval = kernel_read(bprm-&gt;file, elf_ppnt-&gt;p_offset,      <span class="comment">// 读取ELF中的各个段</span></span><br><span class="line">                         elf_interpreter,</span><br><span class="line">                         elf_ppnt-&gt;p_filesz);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    retval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),</span><br><span class="line">                 executable_stack);</span><br><span class="line">    ...</span><br><span class="line">    current-&gt;mm-&gt;start_stack = bprm-&gt;p;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数的实现比较复杂，这里我们重点关注<code>setup_arg_pages()</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setup_arg_pages</span><span class="params">(struct linux_binprm *bprm,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_top,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> executable_stack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    stack_top = arch_align_stack(stack_top);</span><br><span class="line">    stack_top = PAGE_ALIGN(stack_top);</span><br><span class="line">    ...</span><br><span class="line">    stack_shift = vma-&gt;vm_end - stack_top;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* Move stack pages down in memory. */</span></span><br><span class="line">    <span class="keyword">if</span> (stack_shift) &#123;</span><br><span class="line">        ret = shift_arg_pages(vma, stack_shift);        <span class="comment">// 移动arg pages</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    stack_expand = <span class="number">131072U</span>L; <span class="comment">/* randomly 32*4k (or 2*64k) pages */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (stack_size + stack_expand &gt; rlim_stack)</span><br><span class="line">        stack_base = vma-&gt;vm_end - rlim_stack;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        stack_base = vma-&gt;vm_start - stack_expand;</span><br><span class="line">    ...</span><br><span class="line">    ret = expand_stack(vma, stack_base);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面我们已经初始化了一个页的栈空间，用来存放二进制文件名、参数和环境变量等；在<code>setup_arg_pages()</code>中，我们把前面这一个页的栈空间移动到<code>stack_top</code>的位置；在调用函数时，<code>stack_top</code>的值是<code>randomize_stack_top(STACK_TOP)</code>，即一个随机地址，这里是为了安全性而实现的栈地址随机化；函数通过<code>shift_arg_pages()</code>将页移动到新的地址，移动后的栈如下图所示：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1679957/1619073715280-ba9fe2c7-e41a-44ac-a0de-2a875d118e36.png" alt="进程虚拟地址空间-shift_arg_pages.png"></p>
<p>接着回到<code>setup_arg_pages()</code>函数，关注如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">stack_expand = <span class="number">131072U</span>L; <span class="comment">/* randomly 32*4k (or 2*64k) pages */</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (stack_size + stack_expand &gt; rlim_stack)</span><br><span class="line">    stack_base = vma-&gt;vm_end - rlim_stack;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    stack_base = vma-&gt;vm_start - stack_expand;</span><br><span class="line">...</span><br><span class="line">ret = expand_stack(vma, stack_base);</span><br></pre></td></tr></table></figure>

<p><code>expand_stack()</code>函数用来扩展栈虚拟地址空间的大小，<code>stack_base</code>是新的栈基地址，这里的<code>stack_expand</code>是一个固定值，大小为<code>128k</code>，即此处将栈空间扩展<code>128k</code>的大小，扩展后栈空间如下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1679957/1619073769672-7b6e92c2-f096-446d-8b61-b11c2d141d8b.png" alt="进程虚拟地址空间-expand_stack.png"></p>
<p>所以扩展后的栈虚拟地址空间为<code>4kB+128kB</code>，刚刚好<code>132kB</code>.</p>
<h2 id="栈顶地址随机化"><a href="#栈顶地址随机化" class="headerlink" title="栈顶地址随机化"></a>栈顶地址随机化</h2><p>前面介绍<code>setup_arg_pages()</code>函数移动栈顶的时候提到，出于安全原因，会将栈顶移动到一个随机的地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 文件：fs/binfmt_elf.c</span></span><br><span class="line"><span class="comment"> * 函数调用关系：load_elf_binary()-&gt;setup_arg_pages()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">load_elf_binary</span><span class="params">(struct linux_binprm *bprm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    retval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),</span><br><span class="line">                 executable_stack);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里<code>randomize_stack_top(STACK_TOP)</code>就是将<code>STACK_TOP</code>进行随机化处理，在我们的平台上。<code>STACK_TOP</code>与<code>STACK_TOP_MAX</code>的值相同，为<code>0xBF000000</code>；我们来分析一下<code>randomize_stack_top()</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* fs/binfmt_elf.c */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STACK_RND_MASK</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_RND_MASK (0x7ff &gt;&gt; (PAGE_SHIFT - 12)) <span class="comment">/* 8MB of VA */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">randomize_stack_top</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> stack_top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> random_variable = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((current-&gt;flags &amp; PF_RANDOMIZE) &amp;&amp;</span><br><span class="line">        !(current-&gt;personality &amp; ADDR_NO_RANDOMIZE)) &#123;</span><br><span class="line">        random_variable = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) get_random_int();</span><br><span class="line">        random_variable &amp;= STACK_RND_MASK;</span><br><span class="line">        random_variable &lt;&lt;= PAGE_SHIFT;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_STACK_GROWSUP</span></span><br><span class="line">    <span class="keyword">return</span> PAGE_ALIGN(stack_top) + random_variable;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> PAGE_ALIGN(stack_top) - random_variable;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">函数整体非常好理解，就是获取一个随机值，再根据栈向上还是向下增长，将栈顶地址加上或减去这个随机值；我们重点关注下面两行：</span><br><span class="line"></span><br><span class="line">``` C</span><br><span class="line">random_variable &amp;= STACK_RND_MASK;</span><br><span class="line">random_variable &lt;&lt;= PAGE_SHIFT;</span><br></pre></td></tr></table></figure>

<p><code>STACK_RND_MASK</code>的值为<code>0x7FF</code>，<code>PAGE_SHIFT</code>为<code>12</code>；第一行将获取的随机值范围限制在<code>0~0x7FF</code>的范围内；第二行将该值左移<code>12</code>位，这样得到的随机数范围就变成了<code>0~0x7FF000</code>，可以理解为<strong>栈顶地址是在一个<code>8MB</code>的范围内取一个<code>4kB</code>对齐的随机值</strong>。</p>
<h2 id="线程的用户栈"><a href="#线程的用户栈" class="headerlink" title="线程的用户栈"></a>线程的用户栈</h2><p>我们知道在<code>Linux</code>系统上，无论是进程还是线程，都是通过<code>clone</code>系统调用来创建，区别是传入的参数不同；为了确认创建线程时使用的参数，我准备了一个测试程序，然后使用<code>strace</code>来确认：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">function</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"function call\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread;</span><br><span class="line">    pthread_create(&amp;thread, <span class="literal">NULL</span>, function, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(thread,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序的<code>strace</code>部分输出（在<code>x86</code>平台上运行）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone(child_stack=<span class="number">0x7fd2500d0fb0</span>, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tid=[<span class="number">36747</span>], tls=<span class="number">0x7fd2500d1700</span>, child_tidptr=<span class="number">0x7fd2500d19d0</span>) = <span class="number">36747</span></span><br></pre></td></tr></table></figure>

<p>我们可以看到调用<code>clone</code>的时候传入的<code>flags</code>，其中与内存相关最重要的<code>flags</code>是<code>CLONE_VM</code>；接着我们来看内核部分的源码，仍然从<code>copy_process()</code>函数开始：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* kernel/fork.c */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct task_struct *<span class="title">copy_process</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_start,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">int</span> __user *child_tidptr,</span></span></span><br><span class="line"><span class="function"><span class="params">                    struct pid *pid,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">int</span> trace)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    retval = copy_mm(clone_flags, p);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">copy_mm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags, struct task_struct *tsk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>, *<span class="title">oldmm</span>;</span></span><br><span class="line">    ...</span><br><span class="line">    oldmm = current-&gt;mm;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_VM) &#123;</span><br><span class="line">        atomic_inc(&amp;oldmm-&gt;mm_users);</span><br><span class="line">        mm = oldmm;</span><br><span class="line">        <span class="keyword">goto</span> good_mm;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>copy_mm</code>中，检查了<code>clone_flags</code>，如果设置了<code>CLONE_VM</code>，那么将当前<code>task_struct-&gt;mm</code>指针赋值给新的<code>task_struct-&gt;mm</code>；所以我们可以得到结论，通过<code>pthread</code>库创建的线程，其内存是与主线程共享的。</p>

  </div>
  <div class="post-meta">
    <span class="post-time" style="color:#646060;font-size:13px">2020-10-22</span>
  </div>

  <div class="post-footer">
    

    <a href="#top" class="top">Back to Top</a>
  </div>
</article>

<!-- 评论插件 -->

    <div id="gitalk-container"></div>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
    <script>
    var gitalk = new Gitalk({
        id: 'Linux进程栈空间大小',
        owner: 'tiehichi',
        admin: ['tiehichi'],
        repo: 'tiehichi.github.io',
        clientID: 'bf2f550864240e94ca3f',
        clientSecret: 'a03922278132bc805aa4a44d72e5250166095dbe',
    })
    gitalk.render('gitalk-container')
    </script>


<!-- Cloudflare Web Analytics --><script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{"token": "8076240da6a9474eb806a2772561d84a"}'></script><!-- End Cloudflare Web Analytics -->
<footer>
  2022
  <span class="author">
    Tiehichi
  </span>
</footer>


    </div>
  </body>
</html>