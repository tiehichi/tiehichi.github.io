<!DOCTYPE html>
<html>
  <!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  
  <title>字符设备访问流程 - Tiehichi&#39;s Blog</title>
  <link rel="icon" href="https://imgur.com/pPCZVX8.png" type="image/x-icon">
  <link href="https://fonts.googleapis.com/css?family=Bungee+Inline|Noto+Sans+SC|Ubuntu+Mono&display=swap" rel="stylesheet">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  
  <meta name="keywords" content=>
  
  
  
    <link rel="alternate" href="/atom.xml " title="Tiehichi&#39;s Blog" type="application/atom+xml">
  

  <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <div class="container">
      <header class="header">
  <div class="blog-title">
    <a href="/" class="logo">Tiehichi&#39;s Blog</a>
    <div class="subtitle"></div>
  </div>
  <nav class="navbar">
    <ul class="menu">
      
        <li class="menu-item">
          <a href="/" class="menu-item-link">Home</a>
        </li>
      
        <li class="menu-item">
          <a href="/categories" class="menu-item-link">Categories</a>
        </li>
      
        <li class="menu-item">
          <a href="/about" class="menu-item-link">About</a>
        </li>
      
        <li class="menu-item">
          <a href="/atom.xml" class="menu-item-link">RSS</a>
        </li>
      
    </ul>
  </nav>
</header>
<script>
  var link="";
  var a = document.getElementsByTagName('img');
  for(i=0;i<a.length;i++){
    a[i].referrerPolicy='no-referrer';
    link = a[i].src;
    a[i].src = link+'?t='+Math.random();
  }
</script>

<article class="post">
  <div class="post-title">
    <h1 class="article-title">字符设备访问流程</h1>
  </div>

  <!-- 文章目录 -->
  <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#从cdev-add开始分析"><span class="toc-text">从cdev_add开始分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cdev-map"><span class="toc-text">cdev_map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kobj-map"><span class="toc-text">kobj_map()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符设备的访问"><span class="toc-text">字符设备的访问</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#kobj-lookup"><span class="toc-text">kobj_lookup()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chrdev-open"><span class="toc-text">chrdev_open()</span></a></li></ol></li></ol>

  <div class="post-content">
    <p>《LDD3》这本书中“字符设备驱动程序”一章有这样一段话：</p>
<blockquote>
<p><em>只要<strong>cdev_add</strong>返回了，我们的设备就“活”了，它的操作就会被内核调用。</em></p>
</blockquote>
<p>这里就研究一下<code>cdev_add</code>究竟如何让设备“活”过来，以及用户空间访问字符设备节点时，内核的处理流程。</p>
<h2 id="从cdev-add开始分析"><a href="#从cdev-add开始分析" class="headerlink" title="从cdev_add开始分析"></a>从cdev_add开始分析</h2><p>先从<code>cdev_add()</code>入手： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cdev_add</span><span class="params">(struct cdev *p, <span class="keyword">dev_t</span> dev, <span class="keyword">unsigned</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    p-&gt;dev = dev;</span><br><span class="line">    p-&gt;count = count;</span><br><span class="line"></span><br><span class="line">    error = kobj_map(cdev_map, dev, count, <span class="literal">NULL</span>,</span><br><span class="line">    			exact_match, exact_lock, p);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">    kobject_get(p-&gt;kobj.parent);  <span class="comment">/* 增加parent的引用计数 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数除了增加<code>parent</code>的引用计数外，只有一个<code>kobj_map()</code>的函数调用，所以重要的操作应该都通过该函数进行；函数定义再<code>drivers/base/map.c</code>中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kobj_map</span><span class="params">(struct kobj_map *domain, <span class="keyword">dev_t</span> dev, <span class="keyword">unsigned</span> <span class="keyword">long</span> range, </span></span></span><br><span class="line"><span class="function"><span class="params">             struct <span class="keyword">module</span> *<span class="keyword">module</span>, <span class="keyword">kobj_probe_t</span> *probe, </span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">int</span> (*lock)(<span class="keyword">dev_t</span>, <span class="keyword">void</span> *), <span class="keyword">void</span> *data)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="cdev-map"><a href="#cdev-map" class="headerlink" title="cdev_map"></a><code>cdev_map</code></h3><p>结合<code>cdev_add()</code>调用该函数时传入的参数，发现一个重要的参数和数据结构，<code>struct kobj_map</code>类型的<code>cdev_map</code>，这是一个定义在<code>fs/char_dev.c</code>中的全局变量；先来看一下<code>struct kobj_map</code>的结构定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobj_map</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">probe</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">probe</span> *<span class="title">next</span>;</span></span><br><span class="line">        <span class="keyword">dev_t</span> dev;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> range;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">        <span class="keyword">kobj_probe_t</span> *<span class="built_in">get</span>;</span><br><span class="line">        <span class="keyword">int</span> (*lock)(<span class="keyword">dev_t</span>, <span class="keyword">void</span> *);</span><br><span class="line">        <span class="keyword">void</span> *data;</span><br><span class="line">    &#125; *probes[<span class="number">255</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> *<span class="title">lock</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>kobj_map</code>中有一个指向<code>struct probe</code>结构的数组，长度为255，而<code>struct probe</code>结构中包含了设备号、模块的<code>owner</code>等信息。</p>
<p><code>cdev_map</code>的初始化操作通过<code>chrdev_init()</code>进行，而该函数又直接调用了<code>kobj_map_init()</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct kobj_map *<span class="title">kobj_map_init</span><span class="params">(<span class="keyword">kobj_probe_t</span> *base_probe, struct mutex *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobj_map</span> *<span class="title">p</span> = <span class="title">kmalloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">kobj_map</span>), <span class="title">GFP_KERNEL</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">probe</span> *<span class="title">base</span> = <span class="title">kzalloc</span>(<span class="title">sizeof</span>(*<span class="title">base</span>), <span class="title">GFP_KERNEL</span>);</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((p == <span class="literal">NULL</span>) || (base == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        kfree(p);</span><br><span class="line">        kfree(base);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    base-&gt;dev = <span class="number">1</span>;</span><br><span class="line">    base-&gt;range = ~<span class="number">0</span>;</span><br><span class="line">    base-&gt;<span class="built_in">get</span> = base_probe;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">255</span>; i++)</span><br><span class="line">    p-&gt;probes[i] = base;</span><br><span class="line">    p-&gt;lock = lock;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化过程非常简单，除了分配内存，还初始化了一个<code>probe</code>结构的<code>base</code>，并将<code>cdev_map</code>中<code>probes</code>所有元素指向这个<code>base</code>，所以初始化后的<code>cdev_map</code>结构如下图：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1679957/1619074445251-04defb8d-4c45-46c5-9450-71ac97940c49.png" alt="image.png"></p>
<h3 id="kobj-map"><a href="#kobj-map" class="headerlink" title="kobj_map()"></a><code>kobj_map()</code></h3><p>分析完<code>cdev_map</code>的初始化，继续回到<code>kobj_map()</code>函数；前面说到<code>cdev_map</code>被作为参数传递给<code>kobj_map()</code>函数，接下来分析一下<code>kobj_map()</code>的实现，注释后的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kobj_map</span><span class="params">(struct kobj_map *domain, <span class="keyword">dev_t</span> dev, <span class="keyword">unsigned</span> <span class="keyword">long</span> range, </span></span></span><br><span class="line"><span class="function"><span class="params">             struct <span class="keyword">module</span> *<span class="keyword">module</span>, <span class="keyword">kobj_probe_t</span> *probe, </span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">int</span> (*lock)(<span class="keyword">dev_t</span>, <span class="keyword">void</span> *), <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> n = MAJOR(dev + range - <span class="number">1</span>) - MAJOR(dev) + <span class="number">1</span>;  <span class="comment">/* 设备号范围跨了多少个主设备号 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> index = MAJOR(dev);  <span class="comment">/* 该设备的起始主设备号 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">probe</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">255</span>)  <span class="comment">/* 虽然主设备号为12位，但是此处限制设备号范围最多跨255个主设备号 */</span></span><br><span class="line">    n = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">    p = kmalloc_array(n, <span class="keyword">sizeof</span>(struct probe), GFP_KERNEL);  <span class="comment">/* 每个主设备号一个probe结构 */</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    	<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 逐个初始化probe结构 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++, p++) &#123;</span><br><span class="line">        p-&gt;owner = <span class="keyword">module</span>;</span><br><span class="line">        p-&gt;<span class="built_in">get</span> = probe;</span><br><span class="line">        p-&gt;lock = lock;</span><br><span class="line">        p-&gt;dev = dev;</span><br><span class="line">        p-&gt;range = range;</span><br><span class="line">        p-&gt;data = data;  <span class="comment">/* 传入的data实际上是cdev结构的实例 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    mutex_lock(domain-&gt;lock);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, p -= n; i &lt; n; i++, p++, index++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">probe</span> **<span class="title">s</span> = &amp;<span class="title">domain</span>-&gt;<span class="title">probes</span>[<span class="title">index</span> % 255];</span></span><br><span class="line">        <span class="keyword">while</span> (*s &amp;&amp; (*s)-&gt;range &lt; range)</span><br><span class="line">        	s = &amp;(*s)-&gt;next;</span><br><span class="line">        p-&gt;next = *s;</span><br><span class="line">        *s = p;</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_unlock(domain-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mutex_lock()</code>之前的部分比较好理解，就是根据传入的参数，创建并设置了<code>probe</code>结构；<code>mutex_lock()</code>和<code>mutex_unlock()</code>之间的部分需要单独分析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>, p -= n; i &lt; n; i++, p++, index++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">probe</span> **<span class="title">s</span> = &amp;<span class="title">domain</span>-&gt;<span class="title">probes</span>[<span class="title">index</span> % 255];</span></span><br><span class="line">    <span class="keyword">while</span> (*s &amp;&amp; (*s)-&gt;range &lt; range)</span><br><span class="line">    	s = &amp;(*s)-&gt;next;</span><br><span class="line">    p-&gt;next = *s;</span><br><span class="line">    *s = p;</span><br><span class="line">&#125;</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>在这个<code>for</code>循环中，<code>index</code>表示设备的主设备号，<code>p</code>表示一个<code>probe</code>的实例，这段代码主要作用就是将<code>kobj_map</code>结构的<code>probes</code>数组中的元素指向前面创建的<code>probe</code>实例。<br>循环中第一行，创建一个<code>struct probe</code>的指针指向<code>kobj_map-&gt;probes</code>中的某个位置，这个位置并不直接指向第<code>index</code>个位置，而是通过<code>index%255</code>计算得到，因为<code>index</code>是12位的主设备号，取值范围大于255，取模操作可以保证索引不会溢出。<br>接下来的<code>while</code>循环条件比较复杂，暂时先忽略<code>while</code>循环的内容；<code>for</code>循环中最后两句则是将<code>probe[index%255]</code>这个位置指向<code>p</code>，<code>p-&gt;next</code>指向原来的值，最终<code>cdev_map</code>会得到这样的结构：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1679957/1619074445517-0132300b-5a41-4f13-a76a-9f28c0c732d3.png" alt="image.png"></p>
<p>接着再看刚刚忽略的<code>while</code>循环；简单来说，这里的<code>while</code>循环作用就是将一条<code>probe</code>链上的<code>probe</code>实例按照<code>range</code>的值从小到大排序。</p>
<p>在<code>kobj_map_init()</code>中这样一条语句，将<code>base</code>的<code>range</code>设置为<code>unsigned long</code>的最大值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">base-&gt;range = ~0</span><br></pre></td></tr></table></figure>

<p>这里我们以<code>probes</code>数组的第0个元素为例，此时<code>probes[0]</code>结构如下图：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1679957/1619074445213-73fe6afd-e71c-458a-8633-a3f7089506d8.png" alt="image.png"></p>
<p>假设此时插入一个<code>range</code>为<code>1</code>的<code>probe</code>实例到<code>probes[0]</code>，此时<code>(*s)-&gt;range = MAX &gt; range = 1</code>，所以结构会变为这样：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1679957/1619074445310-69813bb6-3567-4cab-9bd9-65859a61d704.png" alt="image.png"></p>
<p>这种情况下，再插入一个<code>range</code>为2的<code>probe</code>实例，这时<code>(*s)-&gt;range = 1 &lt; range = 2</code>，会进入到<code>while</code>循环中，执行<code>s = &amp;(*s)-&gt;next</code>：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1679957/1619074446180-17ac8558-f6de-4b96-97bf-1e08ba6e7a27.png" alt="image.png"></p>
<p>执行完后，<code>s</code>将指向<code>probe_0</code>的<code>next</code>域，而<code>(*s)</code>则指向<code>base</code>，此时<code>(*s)-&gt;range = MAX &gt; range = 2</code>，离开<code>while</code>循环，最终得到如下结构：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1679957/1619074445502-c5dc42b3-87fe-4cd5-8d10-5db47158a65b.png" alt="image.png"></p>
<p>所以最终得到的<code>cdev_map</code>中，每条<code>probe</code>链都是按<code>range</code>从小到大排序的，并且每条链的末尾都指向初始化时创建的<code>base</code>。</p>
<h2 id="字符设备的访问"><a href="#字符设备的访问" class="headerlink" title="字符设备的访问"></a>字符设备的访问</h2><p>前面分析完了<code>cdev_map</code>的初始化流程，到目前为止，<code>cdev</code>结构已经添加到<code>cdev_map</code>中，但是从用户空间访问设备节点时，如何找到对应的<code>file_operations</code>函数呢？</p>
<h3 id="kobj-lookup"><a href="#kobj-lookup" class="headerlink" title="kobj_lookup()"></a><code>kobj_lookup()</code></h3><p><code>drivers/base/map.c</code>中还有一个重要的函数<code>kobj_lookup</code>，先来从这个函数进行分析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct kobject *<span class="title">kobj_lookup</span><span class="params">(struct kobj_map *domain, <span class="keyword">dev_t</span> dev, <span class="keyword">int</span> *index)</span></span>;</span><br></pre></td></tr></table></figure>

<p>从函数定义来看，这个函数的作用是根据设备号，从<code>kobj_map</code>中找到对应的<code>probe</code>，并从中返回对应<code>driver</code>的<code>kobject</code>；看一下这个函数的实现部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line"><span class="keyword">for</span> (p = domain-&gt;probes[MAJOR(dev) % <span class="number">255</span>]; p; p = p-&gt;next) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *(*<span class="title">probe</span>)(<span class="title">dev_t</span>, <span class="title">int</span> *, <span class="title">void</span> *);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *data;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 设备号与当前probe不匹配，继续寻找 */</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;dev &gt; dev || p-&gt;dev + p-&gt;range - <span class="number">1</span> &lt; dev)</span><br><span class="line">    	<span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;range - <span class="number">1</span> &gt;= best) <span class="comment">/* 达到链表尾，退出循环 */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (!try_module_get(p-&gt;owner))</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    owner = p-&gt;owner;</span><br><span class="line">    data = p-&gt;data;</span><br><span class="line">    probe = p-&gt;<span class="built_in">get</span>;</span><br><span class="line">    best = p-&gt;range - <span class="number">1</span>;</span><br><span class="line">    *index = dev - p-&gt;dev;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;lock &amp;&amp; p-&gt;lock(dev, data) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        module_put(owner);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_unlock(domain-&gt;lock);</span><br><span class="line">    kobj = probe(dev, index, data);  <span class="comment">/* 使用kobj_map()时注册的probe函数获取kobj */</span></span><br><span class="line">    <span class="comment">/* Currently -&gt;owner protects _only_ -&gt;probe() itself. */</span></span><br><span class="line">    module_put(owner);</span><br><span class="line">    <span class="keyword">if</span> (kobj)</span><br><span class="line">    	<span class="keyword">return</span> kobj;</span><br><span class="line">    <span class="keyword">goto</span> retry;</span><br><span class="line">&#125;</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p><code>kobj_lookup()</code>根据主设备号从<code>kobj_map-&gt;probes</code>中找到对应的链表进行遍历，并通过计算<code>probe</code>中设备号的范围来匹配正确的<code>probe</code>结构；而<code>kobj_map()</code>时注册的<code>probe()</code>函数则用来从<code>data</code>中获取<code>kobject</code>；对应到<code>cdev_map</code>上，<code>data</code>指向的是<code>cdev</code>结构，而<code>probe()</code>函数指针指向<code>exact_match()</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct kobject *<span class="title">exact_match</span><span class="params">(<span class="keyword">dev_t</span> dev, <span class="keyword">int</span> *part, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> *<span class="title">p</span> = <span class="title">data</span>;</span></span><br><span class="line">    <span class="keyword">return</span> &amp;p-&gt;kobj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>exact_match()</code>的作用就是从<code>data</code>中获取<code>kobject</code>。</p>
<p>既然获取到了<code>kobject</code>，那就可以使用<code>container_of()</code>获取对应的<code>cdev</code>结构，所以<code>char_dev.c</code>中一定有对应的函数会调用<code>kobj_lookup()</code>。</p>
<h3 id="chrdev-open"><a href="#chrdev-open" class="headerlink" title="chrdev_open()"></a><code>chrdev_open()</code></h3><p>经过搜索，在<code>char_dev.c</code>中找到了函数<code>chrdev_open()</code>调用<code>kobj_lookup()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Called every time a character special file is opened</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">chrdev_open</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br></pre></td></tr></table></figure>

<p>从注释来看，这个函数在用户空间每次访问字符设备时调用；来看一下哪里会注册这个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">def_chr_fops</span> = &#123;</span></span><br><span class="line">    .<span class="built_in">open</span> = chrdev_open,</span><br><span class="line">    .llseek = noop_llseek,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>chrdev_open()</code>函数注册在<code>def_chr_fops</code>结构体中，继续搜索一下这个结构体会被赋值给谁：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_special_inode</span><span class="params">(struct inode *inode, <span class="keyword">umode_t</span> mode, <span class="keyword">dev_t</span> rdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    inode-&gt;i_mode = mode;</span><br><span class="line">    <span class="keyword">if</span> (S_ISCHR(mode)) &#123;</span><br><span class="line">        inode-&gt;i_fop = &amp;def_chr_fops;</span><br><span class="line">        inode-&gt;i_rdev = rdev;</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>fs/inode.c</code>中的函数<code>init_special_inode()</code>里，<code>def_chr_fops</code>被赋值给了字符设备的<code>inode</code>结构体，这样在访问字符设备时，就会通过其<code>inode</code>访问到<code>def_chr_fops-&gt;chrdev_open()</code>，但是目前为止还没有调用我们自己为设备注册的<code>file_operations</code>，回过头来继续看<code>chrdev_open()</code>的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">chrdev_open</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">fops</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> *<span class="title">new</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    spin_lock(&amp;cdev_lock);</span><br><span class="line">    p = inode-&gt;i_cdev;</span><br><span class="line">    <span class="keyword">if</span> (!p) &#123;</span><br><span class="line">        ……</span><br><span class="line">        kobj = kobj_lookup(cdev_map, inode-&gt;i_rdev, &amp;idx);</span><br><span class="line">        ……</span><br><span class="line">        <span class="keyword">new</span> = container_of(kobj, struct cdev, kobj);</span><br><span class="line">        spin_lock(&amp;cdev_lock);</span><br><span class="line">        ……</span><br><span class="line">        <span class="keyword">if</span> (!p) &#123;</span><br><span class="line">            inode-&gt;i_cdev = p = <span class="keyword">new</span>;</span><br><span class="line">            list_add(&amp;inode-&gt;i_devices, &amp;p-&gt;<span class="built_in">list</span>);</span><br><span class="line">            <span class="keyword">new</span> = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!cdev_get(p))</span><br><span class="line">            ret = -ENXIO;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!cdev_get(p))</span><br><span class="line">            ret = -ENXIO;</span><br><span class="line">        ……</span><br><span class="line">        fops = fops_get(p-&gt;ops);</span><br><span class="line">        ……</span><br><span class="line">        replace_fops(filp, fops);</span><br><span class="line">        <span class="keyword">if</span> (filp-&gt;f_op-&gt;<span class="built_in">open</span>) &#123;</span><br><span class="line">        	ret = filp-&gt;f_op-&gt;<span class="built_in">open</span>(inode, filp);</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数实现经过精简后，非常容易看出实现过程：第一次访问时，<code>inode-&gt;i_cdev</code>为空，使用<code>kobj_lookup()</code>结合<code>container_of()</code>获取<code>cdev</code>，并将<code>cdev</code>赋值给<code>inode-&gt;i_cdev</code>，然后使用<code>fops_get()</code>获取我们设置的<code>fops</code>，再使用<code>replace_fops()</code>将我们的<code>fops</code>设置到<code>filp</code>文件指针上，然后调用<code>filp-&gt;f_op-&gt;open()</code>，至此成功访问到我们自己的<code>open</code>函数；当再次访问该字符设备时，<code>inode-&gt;i_cdev</code>已经被赋值，无需再次通过<code>kobj_lookup()</code>查找对应的<code>cdev</code>结构。</p>

  </div>
  <div class="post-meta">
    <span class="post-time" style="color:#646060;font-size:13px">2020-03-13</span>
  </div>

  <div class="post-footer">
    

    <a href="#top" class="top">Back to Top</a>
  </div>
</article>

<!-- 评论插件 -->

    <div id="gitalk-container"></div>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
    <script>
    var gitalk = new Gitalk({
        id: '字符设备访问流程',
        owner: 'tiehichi',
        admin: ['tiehichi'],
        repo: 'tiehichi.github.io',
        clientID: 'bf2f550864240e94ca3f',
        clientSecret: 'a03922278132bc805aa4a44d72e5250166095dbe',
    })
    gitalk.render('gitalk-container')
    </script>


<!-- Cloudflare Web Analytics --><script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{"token": "8076240da6a9474eb806a2772561d84a"}'></script><!-- End Cloudflare Web Analytics -->
<footer>
  2022
  <span class="author">
    Tiehichi
  </span>
</footer>


    </div>
  </body>
</html>