<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tiehichi</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-03T12:11:16.789Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Tiehichi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>树莓派上的骚操作</title>
    <link href="http://yoursite.com/2018/04/04/about_rpi/"/>
    <id>http://yoursite.com/2018/04/04/about_rpi/</id>
    <published>2018-04-03T16:00:00.000Z</published>
    <updated>2019-01-03T12:11:16.789Z</updated>
    
    <content type="html"><![CDATA[<p>树莓派是个好东西，简单易用价格不贵，就是上面的坑还真不少，本文记录一下在使用树莓派2/3的过程中踩过的坑<br><a id="more"></a></p><h3 id="串口问题"><a href="#串口问题" class="headerlink" title="串口问题"></a>串口问题</h3><p>树莓派3上蓝牙使用硬件串口，软件串口<code>ttyS0</code>的速率不稳定基本无法正常使用。为了能够使用硬件串口设备<code>ttyAMA0</code>即<code>GPIO 14 15</code>脚，需要禁用蓝牙设备，关闭串口shell并打开硬件串口。</p><p>向<code>/boot/config.txt</code>文件中添加<code>dtoverlay=pi3-disable-bt</code>将禁用蓝牙设备，具体可见<code>/boot/overlays</code>文件夹中的<code>README</code>文件。然后使用<code>raspi-config</code>关闭串口shell并且打开硬件串口，重启后即可使用<code>ttyAMA0</code>串口设备。</p><h3 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h3><p>刚装完系统的树莓派，没有显示屏没有串口线，默认没有打开<code>ssh</code>和<code>vnc</code>服务，怎么远程连接上去呢？直接在SD卡的<code>boot</code>分区中创建一个名为<code>ssh</code>的空文件，再启动树莓派的时候<code>ssh</code>服务就被启动了。</p><p>需要注意的是，如果使用这种方法启动了ssh服务，就不要再去<code>raspi-config</code>中启动ssh服务了，否则树莓派上回启动两个<code>ssh</code>服务，远程连接上去使用任何命令都会被两个<code>ssh</code>服务同时执行，也就是任何命令都会被执行两次。</p><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>没有路由器密码没有屏幕怎么查看树莓派ip地址呢？这里强烈安利我的小脚本<a href="https://github.com/StarAndRabbit/LAN-Scanner" target="_blank" rel="noopener">LAN-Scanner</a>，简单粗暴显示局域网内的活动IP和MAC和OUI信息。</p><h3 id="3-5MM音频输出电流声"><a href="#3-5MM音频输出电流声" class="headerlink" title="3.5MM音频输出电流声"></a>3.5MM音频输出电流声</h3><p>网上很多人都提过树莓派的音频输出电流声过大的问题，有人说电路设计有问题解决不了，有人说换电流稳定的电源，有人说换USB声卡，居然还有人说大力出奇迹使劲把接头往里按的……其实解决方法很简单，在<code>/boot/config.txt</code>中添加<code>audio_pwm_mode=2</code>，重启，完事。</p><h3 id="备份镜像过大"><a href="#备份镜像过大" class="headerlink" title="备份镜像过大"></a>备份镜像过大</h3><p>在Linux上使用<code>dd</code>把SD卡备份出来的镜像文件，跟SD卡容量大小相等，你用张32G的卡，备份出来的镜像就是32G。那么有没有一种方法能把镜像缩小呢？当然有！<a href="https://github.com/Drewsif/PiShrink" target="_blank" rel="noopener">PiShrink</a>脚本能够快速的重排镜像中的<code>inode</code>节点，缩减未使用的部分。</p><h3 id="更换软件源"><a href="#更换软件源" class="headerlink" title="更换软件源"></a>更换软件源</h3><p><code>Raspbian</code>上不是只有一个<code>apt</code>源，还有一个<code>archive.raspberrypi.org</code>源，文件位置在<code>/etc/apt/sources.list.d/raspi.list</code>，科大和清华都有对应的国内源，找出来把原本的替换掉即可。例如USTC源的<a href="http://mirrors.ustc.edu.cn/help/archive.raspberrypi.org.html" target="_blank" rel="noopener">使用帮助</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;树莓派是个好东西，简单易用价格不贵，就是上面的坑还真不少，本文记录一下在使用树莓派2/3的过程中踩过的坑&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux串口开发</title>
    <link href="http://yoursite.com/2017/11/16/linuxserialport/"/>
    <id>http://yoursite.com/2017/11/16/linuxserialport/</id>
    <published>2017-11-15T16:00:00.000Z</published>
    <updated>2019-01-03T12:11:18.439Z</updated>
    
    <content type="html"><![CDATA[<p>一直以来在Linux下用到串口的时候都是用Python的pyserial库操作，现在发现直接使用Linux的系统调用操作串口还真是挺复杂的。<br><a id="more"></a></p><p>得益于Linux一切皆文件的思想，串口的读写可以直接使用<code>read</code>、<code>write</code>系统调用操作<code>/dev</code>目录下的串口设备节点，串口开发复杂的地方在于串口属性的配置，十分繁琐。</p><h3 id="串口设备属性配置"><a href="#串口设备属性配置" class="headerlink" title="串口设备属性配置"></a>串口设备属性配置</h3><p>一般来说，使用串口设备需要配置的属性有：波特率、数据位、停止位、校验位。Linux中，这些属性使用<code>struct termios</code>结构进行存储，该结构定义在<code>termios.h</code>头文件中，查看系统的<a href="https://linux.die.net/man/3/termios" target="_blank" rel="noopener">man手册</a>可以看到该结构的详细介绍。该结构至少包含以下属性：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">termios</span></span></span><br><span class="line"><span class="class">&#123;</span>   </span><br><span class="line">    <span class="keyword">tcflag_t</span> c_iflag;      <span class="comment">/* input modes */</span></span><br><span class="line">    <span class="keyword">tcflag_t</span> c_oflag;      <span class="comment">/* output modes */</span></span><br><span class="line">    <span class="keyword">tcflag_t</span> c_cflag;      <span class="comment">/* control modes */</span></span><br><span class="line">    <span class="keyword">tcflag_t</span> c_lflag;      <span class="comment">/* local modes */</span></span><br><span class="line">    <span class="keyword">cc_t</span>     c_cc[NCCS];   <span class="comment">/* special characters */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>使用<code>tcgetattr()</code>、<code>tcsetattr()</code>函数可以读取或设置串口设备的属性，函数原型见<a href="https://linux.die.net/man/3/termios" target="_blank" rel="noopener">man手册</a>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">portOption</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fd: 串口设备文件描述符，使用 open 函数创建</span></span><br><span class="line">tcgetattr(fd, &amp;portOption);     <span class="comment">// 读取串口设备属性，存入portOption中</span></span><br><span class="line">tcsetattr(fd, TCSANOW, &amp;portOption);    <span class="comment">// 设置设备属性， “TCSANOW”参数表示使属性立即生效</span></span><br></pre></td></tr></table></figure></p><p><strong>波特率的设置</strong></p><p>可以使用<code>cfsetispeed()</code>、<code>cfsetospeed()</code>分别设置串口的输入、输出波特率，使用<code>cfgetispeed()</code>、<code>cfgetospeed()</code>分别获取串口的输入、输出波特率。波特率的数据类型为<code>speed_t</code>，是一个枚举类型，其取值范围可以查看<a href="https://linux.die.net/man/3/termios" target="_blank" rel="noopener">man手册</a><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cfsetispeed(&amp;portOption,B115200);   <span class="comment">//设置为115200Bps</span></span><br><span class="line">cfsetospeed(&amp;portOption,B115200);</span><br></pre></td></tr></table></figure></p><p>注意，该设置仅为修改<code>struct termios</code>结构的值，要让设置生效还需要使用<code>tcsetattr()</code>函数。</p><p><strong>数据位设置</strong></p><p>数据位长度可以设置为5、6、7、8，分别对应宏CS5、CS6、CS7、CS8，根据需要将对应的宏与<code>struct termios</code>结构中的<code>c_cflag</code>字段按位或即可，这种设置属性的方法很符合Unix风格。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">portOption.c_cflag |= CS7;  <span class="comment">// 7位数据位</span></span><br><span class="line">portOption.c_cflag |= CS8;  <span class="comment">// 8位数据位</span></span><br></pre></td></tr></table></figure></p><p><strong>停止位设置</strong></p><p><code>termios.h</code>中定义了一个宏<code>CSTOPB</code>来表示两位停止位，如果需要设置2位停止位，同数据位设置一样与<code>c_cflag</code>按位或即可。如果要设置1位停止位，则对CSTOPB取反再与<code>c_cflag</code>按位与。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">portOption.c_cflag |= CSTOPB;   <span class="comment">// 2位停止位</span></span><br><span class="line">portOption.c_cflag &amp;= ~CSTOPB;  <span class="comment">// 1位停止位</span></span><br></pre></td></tr></table></figure></p><p><strong>校验位设置</strong></p><p>涉及校验的宏定义有<code>INPCK</code>、<code>PARENB</code>、<code>PARODD</code>：</p><ul><li>INPCK：开启输入校验</li><li>PARENB：开启输入输出时的校验码生成</li><li>PARODD：设置奇校验<br>使用这三个宏，即可设置校验方式：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 无校验 */</span></span><br><span class="line">portOption.c_cflag &amp;= ~PARENB;</span><br><span class="line">portOption.c_cflag &amp;= ~INPCK;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 奇校验 */</span></span><br><span class="line">portOption.c_cflag |= PARENB;</span><br><span class="line">portOption.c_cflag |= PARODD;</span><br><span class="line">portOption.c_cflag |= INPCK;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 偶校验 */</span></span><br><span class="line">portOption.c_cflag |= PARENB;</span><br><span class="line">portOption.c_cflag &amp;= ~PARODD;</span><br><span class="line">portOption.c_cflag |= INPCK;</span><br></pre></td></tr></table></figure></li></ul><p>注意：如果不是开发串口终端，而仅仅使用串口传输数据，则数据需要使用RAW Mode进行传输：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">portOption.c_lflag &amp;= ~(ICANON | ECHO | ECHOE | ISIG);  <span class="comment">/*Input*/</span></span><br><span class="line">portOption.c_oflag &amp;= ~OPOST;   <span class="comment">/*Output*/</span></span><br></pre></td></tr></table></figure></p><p>也可以偷懒使用<code>termios.h</code>中提供的函数<code>cfmakeraw()</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfmakeraw(&amp;portOption);</span><br></pre></td></tr></table></figure></p><h3 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h3><p>串口设备的读写阻塞与非阻塞不仅仅与设备节点被<code>open</code>的时候设置的参数有关，还与<code>struct termios</code>结构中<code>c_cc[VMIN]</code>和<code>c_cc[VTIME]</code>有关。</p><p>参考<code>wiringPi</code>库和<code>pyserial</code>的实现，我发现大家再打开串口设备的时候都是将其设置为非阻塞，然后在设置完设备属性后再使用<code>fcntl()</code>将其设置为阻塞。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"/dev/ttyS0"</span>, O_RDWR | O_NOCTTY | O_NONBLOCK | O_NDELAY);</span><br><span class="line">...</span><br><span class="line"><span class="comment">/* 设置属性... */</span></span><br><span class="line">...</span><br><span class="line">fcntl(fd, F_SETFL, <span class="number">0</span>);  <span class="comment">// 设置为阻塞模式</span></span><br></pre></td></tr></table></figure></p><p>设置完文件描述符的属性，还需要根据<code>c_cc[VMIN]</code>和<code>c_cc[VTIME]</code>才能确定读写的时候是否为阻塞模式，这两项的组合如下：</p><ul><li><p>c_cc[VMIN]==0; c_cc[VTIME]==0;</p><p>  非阻塞，<code>read</code>函数将立即返回实际读取的字节数，没有读取到则返回0</p></li><li><p>c_cc[VMIN]&gt;0; c_cc[VTIME]==0;</p><p>  阻塞，串口缓冲区中至少有<code>c_cc[VMIN]</code>个字节可供读取时，<code>read</code>才会返回，<code>read</code>的返回值为<code>c_cc[VMIN]</code>与<code>read</code>的<code>len</code>参数中的较小者。</p></li><li><p>c_cc[VMIN]==0; c_cc[VTIME]&gt;0;</p><p>  这种情况下，当调用<code>read</code>时，计时器开始计时，<code>c_cc[VTIME]</code>的单位为十分之一秒，如果计时超过<code>c_cc[VTIME]</code>设置的时间，<code>read</code>将会返回0，或者缓冲区中至少有一个字节可供读取，<code>read</code>正常返回，否则将会阻塞。</p></li><li><p>c_cc[VMIN]&gt;0; c_cc[VTIME]&gt;0;</p><p>  该情况中从调用<code>read</code>并且缓冲区中至少有一个字节可用时，计时器开始计时，并且每次调用<code>read</code>且缓冲区中有数据可供读取时，计时器会重新计时，直到计时器超时或者<code>read</code>已经读到<code>len</code>个字节，<code>read</code>会返回实际读取的字节数。注意在该情况下，如果缓冲区中没有可供读取的数据，那么计时器不会启动，<code>read</code>将被一直阻塞。</p></li></ul><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>使用<code>c_cc[VMIN]</code>与<code>c_cc[VTIME]</code>可以灵活的按需设置串口读取的阻塞与非阻塞状态。非阻塞<code>read</code>直接设置<code>c_cc[VMIN]==0; c_cc[VTIME]==0;</code>即可；阻塞的设置相对比较复杂：</p><ol><li><p>如果需要保证每次<code>read</code>的字节数，可以设置<code>c_cc[VMIN]&gt;0; c_cc[VTIME]==0;</code>，但是需要注意，<code>c_cc[]</code>的数据类型<code>cc_t</code>实际上为<code>unsigned char</code>，其取值范围为<code>0~255</code></p></li><li><p>如果需要为<code>read</code>设置超时时间，需要注意后面两种情况的超时是不同的。<code>c_cc[VMIN]==0; c_cc[VTIME]&gt;0;</code>只能确保串口缓冲区中有数据可读，但是无法保证实际<code>read</code>到的字节数量；<code>c_cc[VMIN]&gt;0; c_cc[VTIME]&gt;0;</code>能够确保<code>read</code>到的字节数量，但是<code>read</code>每读取一个字节会重新设置计时器，即设置的超时时间并不是<code>read</code>超时返回的时间，并且需要注意，当缓冲区无数据可读时，计时器并不会启动，<code>read</code>将被一直阻塞。</p></li></ol><p>从某种意义上来说，串口超时的设置都不是“真正的”超时，并非从<code>read</code>函数被调用到超时返回的真实时间。<code>pyserial</code>库中的<code>read</code>函数是可以设置其超时返回时间的，参考其源码发现可以使用<code>select()</code>来实现“真正的”超时。</p><p>为了同时保证<code>read</code>读取的字节数和超时返回的时间，换一种思路就是使用<code>c_cc[VMIN]&gt;0; c_cc[VTIME]==0;</code>来保证<code>read</code>读取的字节数，使用<code>select()</code>函数来设置超时：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fd_set <span class="built_in">set</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line"></span><br><span class="line">timeout.tv_sec = <span class="number">5</span>;     <span class="comment">// 设置超时时间为5s</span></span><br><span class="line">FD_ZERO(&amp;<span class="built_in">set</span>);</span><br><span class="line">FD_SET(fd, &amp;<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">portOption.c_cc[VMIN] = <span class="number">255</span>;</span><br><span class="line">portOption.c_cc[VTIME] = <span class="number">0</span>;</span><br><span class="line">tcsetattr(fd, TCSANOW, &amp;portOption);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(select(fd+<span class="number">1</span>, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;timeout))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="comment">/* timeout */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        <span class="comment">/* select() error */</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        read(fd, buffer, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关于<code>select()</code>函数的使用方法可以参考<a href="https://linux.die.net/man/3/select" target="_blank" rel="noopener">man手册</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直以来在Linux下用到串口的时候都是用Python的pyserial库操作，现在发现直接使用Linux的系统调用操作串口还真是挺复杂的。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Systemd Service 单元文件的编写</title>
    <link href="http://yoursite.com/2017/09/19/systemd_service_unit/"/>
    <id>http://yoursite.com/2017/09/19/systemd_service_unit/</id>
    <published>2017-09-18T16:00:00.000Z</published>
    <updated>2019-01-03T12:11:20.263Z</updated>
    
    <content type="html"><![CDATA[<p>目前我所掌握的使一个Linux下的软件开机自启动的方法只有将其加入<code>rc.local</code>文件或桌面环境的<code>autostart</code>文件中，但前者不能很好的保证软件的依赖关系，后者要求系统具备桌面环境。虽然知道现在大多数发行版已经使用<code>systemd</code>来管理系统服务，但一直没有研究过如何编写其单元文件，为了解决上述问题，研究了一下<code>systemd</code>的<code>service</code>单元文件的写法，将遇到的问题做个总结。<br><a id="more"></a></p><h3 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a><code>systemctl</code></h3><p><code>systemctl</code>命令基本相当于<code>System V init</code>的<code>service</code>命令，可用于系统服务的管理，也可以进行电源管理，常用命令如下：</p><ul><li><p>系统服务管理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> &lt;unit&gt;     <span class="comment"># 将&lt;unit&gt;设置为开机自启动</span></span><br><span class="line">systemctl <span class="built_in">disable</span> &lt;unit&gt;    <span class="comment"># 取消&lt;unit&gt;开机自启动</span></span><br><span class="line"></span><br><span class="line">systemctl start &lt;unit&gt;      <span class="comment"># 启动&lt;unit&gt;</span></span><br><span class="line">systemctl restart &lt;unit&gt;    <span class="comment"># 重启&lt;unit&gt;</span></span><br><span class="line">systemctl stop &lt;unit&gt;       <span class="comment"># 停止&lt;unit&gt;</span></span><br><span class="line">systemctl status &lt;unit&gt;     <span class="comment"># 查看&lt;unit&gt;的状态</span></span><br><span class="line">systemctl reload &lt;unit&gt;     <span class="comment"># 重新加载&lt;unit&gt;的配置文件而不关闭服务</span></span><br><span class="line"></span><br><span class="line">systemctl is-active &lt;unit&gt;  <span class="comment"># 查看&lt;unit&gt;是否为激活状态</span></span><br><span class="line">systemctl is-enabled &lt;unit&gt; <span class="comment"># 查看&lt;unit&gt;是否设置了开机自启</span></span><br><span class="line">systemctl is-failed &lt;unit&gt;  <span class="comment"># 查看&lt;unit&gt;是否加载失败</span></span><br></pre></td></tr></table></figure></li><li><p>电源管理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl reboot            <span class="comment"># 重启</span></span><br><span class="line">systemctl poweroff          <span class="comment"># 关机</span></span><br><span class="line">systemclt hibernate         <span class="comment"># 休眠</span></span><br><span class="line">systemctl <span class="built_in">suspend</span>           <span class="comment"># 待机</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="systemd单元文件"><a href="#systemd单元文件" class="headerlink" title="systemd单元文件"></a><code>systemd</code>单元文件</h3><p><code>systemd</code>的单元文件有以下几类：</p><ul><li>系统服务 <code>.service</code></li><li>挂载点 <code>.mount</code></li><li>sockets <code>.socket</code></li><li>系统设备 <code>.device</code></li><li>交换分区 <code>.swp</code></li><li>文件路径 <code>.path</code></li><li>启动目标 <code>.target</code></li><li>定时器 <code>.timer</code></li></ul><p>当使用<code>systemctl</code>对一个单元进行操作时，一般需要使用单元的全名，如<code>ssh.service</code>，但如果使用不带后缀名的单元名称，<code>systemctl</code>将会把这个单元当做系统服务(<code>.service</code>)进行操作。如果一个单元文件中存在<code>@</code>字符，表示该单元文件是一个模板单元，当使用<code>systemctl</code>操作模板单元时，需要对单元进行实例化，否则会调用失败。</p><p>单元文件可以从两个地方加载：</p><ul><li><code>/usr/lib/systemd/system/</code>：软件包安装的单元</li><li><code>/etc/systemd/system/</code>：系统管理员安装的单元</li></ul><p>加载优先级上，系统管理员安装的单元优先级高于软件包安装的单元。</p><h3 id="Serivce单元文件编写："><a href="#Serivce单元文件编写：" class="headerlink" title="Serivce单元文件编写："></a>Serivce单元文件编写：</h3><p><code>service</code>单元文件有三个段落：<code>[Unit]</code> <code>[Service]</code> <code>[Install]</code>；其单元文件的编写模板可以参考man手册的<a href="http://jlk.fjfi.cvut.cz/arch/manpages/man/systemd.service.5#EXAMPLES" target="_blank" rel="noopener">EXAMPLE章节</a>，上面提到的单元加载目录下也有很多例子可供参考。</p><p><strong>依赖关系的处理</strong></p><p>如果需要<code>A</code>单元在<code>B</code>单元启动之后启动，仅指定<code>Requires=B</code>或<code>Wants=B</code>是不行的，如果不指定<code>After=B</code>，<code>A</code>单元和<code>B</code>单元会并行启动。为了保证<code>A</code>在<code>B</code>单元启动之后再启动，应该在<code>A</code>的配置文件中<code>[Unit]</code>段中添加<code>Requires=B</code>和<code>After=B</code>。</p><p>在<code>[Unit]</code>段中，用于表示依赖关系的选项有<code>Wants</code>、<code>Requires</code>、<code>BindsTo</code>和<code>PartOf</code>，他们所表示的依赖关系的强弱可以大致表示为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PartOf = BindsTo &gt; Requires &gt; Wants</span><br></pre></td></tr></table></figure></p><p><code>Wants</code>的依赖关系最弱，当依赖的单元启动失败时，不会对其他单元的启动造成影响；<code>Requires</code>所指定的单元中有一个启动失败时，其他相关的单元都不会被启动；<code>BindsTo</code>的依赖性比<code>Requires</code>更强，当启动使用了<code>BindsTo</code>的单元时，<code>BindsTo</code>所指定的单元均会被启动，当列出的单元全部被启动后，该单元也会被启动，但是如果指定的单元中任意一个终止或重启，该单元也会终止或重启；<code>PartOf</code>类似于<code>BindsTo</code>，不同的是，使用<code>PartOf</code>的单元不会随着依赖单元的启动而启动。</p><p><strong>为启动的服务设置环境变量</strong></p><p>可以在单元配置文件的<code>[Service]</code>段落中添加<code>Environment</code>选项，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Environment=LANG=zh_CN.UTF_8</span><br></pre></td></tr></table></figure></p><p>如果需要添加多个环境变量，<del>应在<code>[Service]</code>中添加多个<code>Environment</code>，而不是在一个<code>Environment</code>后面添加多个环境变量的值。</del> 可以在<code>[Service]</code>中添加多个<code>Environment</code>，也可以在<code>Environment</code>后添加多个环境变量的定义，使用空格分隔，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Environment=PATH=/home/jack CONFIG=&apos;-std=c99&apos;</span><br></pre></td></tr></table></figure></p><p>对没错也可以使用<code>&#39;</code>，可以查看man手册的<a href="http://jlk.fjfi.cvut.cz/arch/manpages/man/systemd.service.5.en#COMMAND_LINES" target="_blank" rel="noopener">相关章节</a>获得更多信息。</p><p>也可以使用<code>EnvironmentFile</code>选项指定一个包含环境变量列表的文件路径，这个文件中每一行都是一个环境变量的值。例如，单元文件中<code>[Service]</code>字段包含选项如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EnvironmentFile=/home/jack/env</span><br></pre></td></tr></table></figure></p><p><code>/home/jack/env</code>文件包含内容格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LANG=zh_CN.UTF-8</span><br><span class="line">CONFIGPATH=/home/jack/.config/config</span><br></pre></td></tr></table></figure></p><p><strong>设置运行服务的用户和组</strong></p><p>在单元配置文件的<code>[Service]</code>段落中添加<code>User</code>和<code>Group</code>选项即可，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User=Jack</span><br><span class="line">Group=Jack</span><br></pre></td></tr></table></figure></p><p><strong>设置服务的工作路径</strong></p><p>在单元配置文件的<code>[Service]</code>段落中添加<code>WorkingDirectory</code>选项，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WorkingDirectory=/home/Jack/</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>经过了激烈的讨论之后绝大多数发行版还是迁移到了<code>Systemd</code>，这个东西确实符合UNIX<code>keep it simple and stupid</code>的哲学，而是一个大而全的东西。<code>Systemd</code>出现后接管了Linux上包括启动日志在内的很多东西，造成使用者们之前掌握的一部分技能在这上面不顶用了，这会不会也是<code>Systemd</code>出现后遭到抵制的原因之一呢。</p><p>更多<code>Systemd</code>的相关资料可以查看man手册的<a href="http://jlk.fjfi.cvut.cz/arch/manpages/man/systemd.1" target="_blank" rel="noopener">systemd章节</a>，以及ArchLinux Wiki页面中关于<a href="https://wiki.archlinux.org/index.php/Systemd" target="_blank" rel="noopener">Systemd的部分</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前我所掌握的使一个Linux下的软件开机自启动的方法只有将其加入&lt;code&gt;rc.local&lt;/code&gt;文件或桌面环境的&lt;code&gt;autostart&lt;/code&gt;文件中，但前者不能很好的保证软件的依赖关系，后者要求系统具备桌面环境。虽然知道现在大多数发行版已经使用&lt;code&gt;systemd&lt;/code&gt;来管理系统服务，但一直没有研究过如何编写其单元文件，为了解决上述问题，研究了一下&lt;code&gt;systemd&lt;/code&gt;的&lt;code&gt;service&lt;/code&gt;单元文件的写法，将遇到的问题做个总结。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>在树莓派上使用 PN532 NFC读卡器[1]——Mifare Classic 1K 协议解析</title>
    <link href="http://yoursite.com/2017/09/18/nfc_1/"/>
    <id>http://yoursite.com/2017/09/18/nfc_1/</id>
    <published>2017-09-17T16:00:00.000Z</published>
    <updated>2019-01-05T09:34:22.327Z</updated>
    
    <content type="html"><![CDATA[<p>本系列的<a href="http://tiehichi.site/2017/07/04/archives/nfc_0/" target="_blank" rel="noopener">上一篇文章</a>讲了libnfc的安装与配置，这篇文章将着重分析Mifare Classic 1K卡的存储结构。<br><a id="more"></a></p><h3 id="Mifare-Classic-卡的存储结构"><a href="#Mifare-Classic-卡的存储结构" class="headerlink" title="Mifare Classic 卡的存储结构"></a>Mifare Classic 卡的存储结构</h3><p>Mifare Classic 卡的容量分为三种，1K、2K和4K，我只用过容量为1K的，即S50卡，后面两种卡据说只是容量不同，存储格式一样。</p><p>Mifare卡的存储有扇区（Sector）和块（Block）两个概念，对于1K卡来说，其容量共1024字节，这1024个字节被分为16个扇区，每个扇区有4个块，每个块16字节，如下图所示：</p><p><img src="https://i.loli.net/2019/01/05/5c3079223c3a3.png" alt="mfs50storage.png"></p><ul><li><p><strong>厂商数据块</strong></p><p>  Mifare卡的存储空间中，第0扇区的第0块为厂商数据块，该块是只读的，不过据说有一种<code>Chinese Magic Card</code>是可以修改该数据块的。</p><p>  该块中，0-3字节为UID，每张Mifare卡都拥有唯一的UID，所以很多小区的门禁系统使用UID作为门禁卡的标志来认证门禁卡，比如我们小区；第4字节据说是校验位，但我不清楚它是怎么进行校验的；第5字节为SAK，又称卡片容量，我不知道其他卡该字节的值是多少，我手上的Mifare卡该字节均为<code>0x08</code>；第6-7字节是<code>ATQA</code>应答字节，好像也经常被称为卡片类型，因为Mifare Classic 1K卡的<code>ATQA</code>均为<code>0x0004</code>（Mifare协议使用小端约定，低字节存放在低地址，高字节存放在高地址，即第6字节为<code>0x04</code>，第7字节为<code>0x00</code>）；剩下的第8-15字节我也不知道是啥，我手里的多张卡读出来的值均为<code>0x62 0x63 0x64 0x65 0x66 0x67 0x68 0x69</code>。</p><p>  第0扇区第0块的结构如下图所示：</p><p>  <img src="https://i.loli.net/2019/01/05/5c3079447721e.png" alt="mfs50block0.png"></p></li><li><p><strong>密钥块</strong></p><p>  Mifare卡中每个扇区的最后一个Block为密钥块，又叫做尾块（<code>Sector Trailer</code>），该Block中存放了对应扇区的认证密钥以及权限设置，密钥块的结构如下图所示：</p><p>  <img src="https://i.loli.net/2019/01/05/5c30797485468.png" alt="mfs50trailerblock.png"></p><p>  该块中，前6个字节与最后6个字节分别为密钥A和密钥B，当卡片出厂时，两个密钥均被设置为<code>0xFF 0xFF 0xFF 0xFF 0xFF 0xFF</code>，如果读密钥时，权限不足或认证失败则读出的值全为0。</p><p>  密钥块中，第6-9个字节为权限位，指明对应扇区相应的权限，其默认值为<code>0xFF 0x07 0x80 0x69</code></p></li><li><p><strong>数据块</strong></p><p>  除了密钥块和厂商数据块以外的Block为数据块，普通数据块可以作为可读写块或数值块，可读写块可以进行一般的读写操作，没什么特殊的，比较特殊的是数值块。</p><ul><li><p><strong>数值块</strong></p><p>  将普通数据块格式化为数值块后，可以把卡片当做电子钱包使用，其除了读写操作外，还可进行增值、减值、存储和传输操作，数值块的数据格式如下：</p><p>  <img src="https://i.loli.net/2019/01/05/5c3079a24b629.png" alt="mfs50valueblock.png"></p><p>  根据官方文档的说法，为了保证数据的可靠性，在一个数值块中，数值存储三次，一次取反，两次不取反；地址存储四次，两次取反，两次不取反。</p><p>  例如：将<code>Sector 0 Block 2</code>设置为数值块，其值设置为十进制<code>200</code>，则<code>block 2</code>中的数据为：<code>00 00 00 C8 FF FF FF 37 00 00 00 C8 02 FD 02 FD</code></p></li></ul></li></ul><h3 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h3><p>前面说到S50卡中，通过扇区尾块的权限位（<code>Access Bits</code>）来控制一个扇区相应的权限，权限位为尾块中的第6-9个字节。每个扇区中对应的Block的权限由三个位控制，表示为 C1<sub>n</sub> C2<sub>n</sub> C3<sub>n</sub>。例如Block 0的权限位表示为：C1<sub>0</sub> C2<sub>0</sub> C3<sub>0</sub></p><p><img src="https://i.loli.net/2019/01/05/5c3079c4bbbd3.png" alt="mfs50accessconditions.png"></p><p>权限位在尾块中的存储结构如下图所示：</p><p><img src="https://i.loli.net/2019/01/05/5c3079e055a4a.png" alt="mfs50accessbitsstruct.png"></p><p>如果需要修改扇区中某个块的访问权限，需要根据控制条件修改权限位并存储到对应扇区尾块的<code>Access Bits</code>区中，数据块的控制条件如下图所示：</p><p><img src="https://i.loli.net/2019/01/05/5c3079fde1d19.png" alt="mfs50dbaccess.png"></p><p>上图中Access Bits列表示权限位的组合，Access conditions for列表示进行对应操作时需要认证的密钥，<code>never</code>表示不可进行对应操作。Application列表示应用在何种类型的操作或数据块上。</p><p>需要注意的是，尾块的权限控制与数据块不同，尾块的控制条件如图：</p><p><img src="https://i.loli.net/2019/01/05/5c307a1a6f26d.png" alt="mfs50tbaccess.png"></p><div class="tip"><br>如果不需要使用key B，可在尾块中将key B的存储空间当做数据块使用，但需要配置相应的权限。<br></div><h3 id="卡片认证流程"><a href="#卡片认证流程" class="headerlink" title="卡片认证流程"></a>卡片认证流程</h3><p>当对S50卡的一个Block进行操作时，需要根据其权限的设置来选择对应的密钥进行认证，其认证流程如下：</p><ol><li><p><strong>选卡</strong></p><p> 当S50卡进入PN532的可通信范围后，需要控制PN532选择卡片进行通信，如果有多张卡同时进入可通信范围，需要抗干扰算法选择其中一张进行通信。</p></li><li><p><strong>认证</strong></p><p> 当PN532与S50卡之间建立通信连接后，需要根据权限位选择对应的密钥对扇区进行认证，如果认证失败，则需要断开连接重新选卡才能再次认证。</p></li><li><p><strong>操作</strong></p><p> 认证成功后可以对已经认证的扇区进行操作，操作完成后断开连接即可进行下一次选卡。</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从上一篇到现在拖了将近两个月，目睹了大佬们的博客之后还是把这篇写出来了……下一篇将着重总结一下libnfc控制PN532的具体代码，先列标题：<strong>在树莓派上使用 PN532 NFC读卡器[2]——libnfc 控制PN532</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列的&lt;a href=&quot;http://tiehichi.site/2017/07/04/archives/nfc_0/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;上一篇文章&lt;/a&gt;讲了libnfc的安装与配置，这篇文章将着重分析Mifare Classic 1K卡的存储结构。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>记一次失败的刷机经历</title>
    <link href="http://yoursite.com/2017/08/14/flash_myphone/"/>
    <id>http://yoursite.com/2017/08/14/flash_myphone/</id>
    <published>2017-08-13T16:00:00.000Z</published>
    <updated>2019-01-05T09:23:30.212Z</updated>
    
    <content type="html"><![CDATA[<p>无意间在网上看到了有sony z5p的非官方版的Lineage OS了，准备刷一下试试看，在XDA上看到卡刷需要使用Lineage定制的TWRP刷入，于是从网上找了个TWRP的img镜像准备刷进去，结果……<br><a id="more"></a><br>想了一下，img文件嘛，用flashtool刷不是很方便嘛，打开flashtool，手机进到fastboot，选择img文件，刷入kernel，完美。重启开机，嗯？怎么进到TWRP了，我要进系统啊，难道是刚刷入TWRP要进行什么设置？不管了，瞎**设置一通，重启……卧槽又进TWRP了！这时我意识到</p><p><img src="https://i.loli.net/2019/01/05/5c30776ec4dfe.png" alt="not-simple.png"></p><p>想了一下，感觉流程没什么问题啊，此时机智的我想起来看一下flashtool的日志。发现问题了！我在flashtool的日志上看到<code>写入boot分区成功</code>，这boot分区按理来说应该是存放kernel镜像的，系统启动的时候会从boot分区加载内核镜像，我现在把recovery写进了boot分区，那开机必然会直接进入recovery……</p><p>搞清楚了问题的原因，那解决方法就很明朗了，再搞个内核重新刷呗。既然已经决定要刷机了，干脆直接把系统刷成<code>Lineage OS</code>，经过一番搜索，在<a href="https://forum.xda-developers.com/z5-premium/development/lineageos-14-1-z5p-e6853-t3576995" target="_blank" rel="noopener">XDA</a>上看到非官方版的<code>Lineage OS</code>已经提供了<code>fastboot</code>刷机所需要的各种镜像文件，全部下载下来，开搞。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fastboot -S 256M flash boot boot.img</span><br><span class="line">fastboot -S 256M flash system system.img</span><br><span class="line">fastboot -S 256M flash userdata userdata.img</span><br><span class="line">fastboot -S 256M flash cache cache.img</span><br></pre></td></tr></table></figure></p><p>刷完这些东西应该能进系统了，不过还是顺便把TWRP刷一下，这次不会出问题了！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastboot flash recovery lineage_twrp_recovery.img</span><br></pre></td></tr></table></figure></p><p>拔下数据线，开机成功！</p><p>总结：瞎**操作之前要先动脑子。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无意间在网上看到了有sony z5p的非官方版的Lineage OS了，准备刷一下试试看，在XDA上看到卡刷需要使用Lineage定制的TWRP刷入，于是从网上找了个TWRP的img镜像准备刷进去，结果……&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>为树莓派编译Qt5.8(Embedded)</title>
    <link href="http://yoursite.com/2017/07/09/build-qt5.8-for-rpi/"/>
    <id>http://yoursite.com/2017/07/09/build-qt5.8-for-rpi/</id>
    <published>2017-07-08T16:00:00.000Z</published>
    <updated>2019-01-05T09:42:33.460Z</updated>
    
    <content type="html"><![CDATA[<p>为了在树莓派上使用Qt提供的虚拟键盘，最开始我将虚拟键盘的源码下载到树莓派上，使用Raspbian软件源中的Qt5库进行编译，结果运行时发现弹出虚拟键盘时，屏幕上除了虚拟键盘以外的区域均为黑色，无法正常显示其他窗口，猜测可能是虚拟键盘在X Window上显示有问题。为了解决这个诡异的问题，我决定为树莓派编译Qt5.8，交叉编译完的Qt显示时将绕过X Window，直接走FrameBuffer将图形显示在屏幕上，这样应该可以解决虚拟键盘在X Window上显示的问题。<br><a id="more"></a></p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li><p><strong>一个正常运行的Linux系统</strong></p><p> 编译工作需要在Linux系统（任意发行版均可）下进行，可以跑在虚拟机上，也可以是物理机，如果是虚拟机的话，记得分配多一点硬盘空间，建议40G左右。</p></li><li><p><strong>设置环境变量</strong></p><p> 这一步主要是为了方便后面的编译工作，我的编译工作全部在<code>~/rpi</code>文件夹中进行，将后续会用到的交叉编译工具以及Qt源码、Raspbian镜像等全部放在该文件夹中。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> RPIROOT=<span class="variable">$HOME</span>/rpi</span><br><span class="line"><span class="built_in">export</span> RPIIMG=<span class="variable">$RPIROOT</span>/rasp-pi-rootfs</span><br><span class="line"><span class="built_in">export</span> RPIQT=<span class="variable">$RPIROOT</span>/qt5pi</span><br><span class="line">mkdir <span class="variable">$RPIROOT</span></span><br><span class="line">mkdir <span class="variable">$RPIIMG</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$RPIROOT</span></span><br></pre></td></tr></table></figure><p> 为了使用方便，可以将这些<code>export</code>放在一个文件中，需要时<code>source</code>就可以了。我将这些环境变量的设置全部放在<code>$RPIROOT/rpi.env</code>文件中。</p></li><li><p><strong>交叉编译工具</strong></p><p> 树莓派的交叉编译工具可以从官方GitHub上获取到，将其<code>clone</code>到<code>$RPIROOT</code>文件夹中。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/raspberrypi/tools.git</span><br></pre></td></tr></table></figure><p> 下载完成后，设置一下交叉编译工具的环境变量，同样可以将其放在<code>.env</code>文件中</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$RPIROOT</span>/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin</span><br></pre></td></tr></table></figure><p> 如果你是32位的系统，将<code>-x64</code>去掉。</p></li><li><p><strong>下载树莓派Raspbian镜像</strong></p><p> 树莓派的系统镜像可以直接从树莓派官方网站<a href="https://www.raspberrypi.org/downloads/raspbian/" target="_blank" rel="noopener">下载</a>，我这里使用的是官方的<code>2017-04-10-raspbian-jessie-lite.img</code>。</p> <div class="tip"><br> 建议使用官方的Lite镜像，Lite版本不包含图形环境，而编译完成的Qt5.8将直接通过FrameBuffer进行显示，因此没必要使用包含图形环境的树莓派镜像；而且X Window的显示与FrameBuffer的显示呈现在同一个屏幕上，FrameBuffer的显示将会遮盖X Window的显示，但是通过鼠标对FrameBuffer的显示窗口进行操作时，鼠标事件同样会被X Window所捕获，会发生冲突。<br> </div></li><li><p><strong>获取Qt源码</strong></p><p> Qt源码同样下载到<code>$RPIROOT</code>文件夹中。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://code.qt.io/qt/qt5.git</span><br></pre></td></tr></table></figure><p> 下载完成后，<code>checkout</code>到你需要编译的Qt版本中</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> qt5</span><br><span class="line">git checkout v5.8.0</span><br></pre></td></tr></table></figure><p> 完成后，使用<code>qt5</code>文件夹中的<code>init-repository</code>工具初始化仓库，该过程将下载Qt各个模块的源码。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./init-repository</span><br></pre></td></tr></table></figure><p> 该过程需要网络连接，如果在初始化过程中由于某些原因导致下载失败，使用<code>-f</code>参数继续初始化，直至全部模块下载完成。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./init-repository -f</span><br></pre></td></tr></table></figure></li></ol><h3 id="挂载Raspbian镜像"><a href="#挂载Raspbian镜像" class="headerlink" title="挂载Raspbian镜像"></a>挂载Raspbian镜像</h3><p>首先使用<code>fdisk -l</code>命令查看一下镜像文件的结构：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l 2017-04-10-raspbian-jessie-lite.img</span><br></pre></td></tr></table></figure></p><p>输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Disk 2017-04-10-raspbian-jessie-lite.img：1.2 GiB，1297862656 字节，2534888 个扇区</span><br><span class="line">单元：扇区 / 1 * 512 = 512 字节</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br><span class="line">磁盘标签类型：dos</span><br><span class="line">磁盘标识符：0x84fa8189</span><br><span class="line"></span><br><span class="line">设备                                 启动  起点    末尾    扇区  大小 Id 类型</span><br><span class="line">2017-04-10-raspbian-jessie-lite.img1       8192   92159   83968   41M  c W95 FAT32 (LBA)</span><br><span class="line">2017-04-10-raspbian-jessie-lite.img2      92160 2534887 2442728  1.2G 83 Linux</span><br></pre></td></tr></table></figure></p><p>可以看到该镜像文件共有两个分区，其中img1为树莓派的bootloader，img2为raspbian的根文件系统，我们需要挂载的就是该镜像中的第二个分区，其格式为ext4。注意该镜像中，一个扇区为<code>512 Byte</code>，而img2分区的起点是第<code>92160</code>号扇区，那么挂载该分区时，其偏移量应为<code>512 × 92160</code>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -o loop,offset=$((512 * 92160)) 2017-04-10-raspbian-jessie-lite.img <span class="variable">$RPIIMG</span></span><br></pre></td></tr></table></figure></p><p>不同的系统镜像其根文件系统的起始扇区可能不同，偏移量请根据<code>fsidk -l</code>的输出确定。</p><h3 id="修复相对链接"><a href="#修复相对链接" class="headerlink" title="修复相对链接"></a>修复相对链接</h3><p>由于镜像的挂载点与我们即将使用的交叉编译工具不在同一个根文件系统中，可能会出现一些相对连接的问题，这里需要使用工具修复relative links。<br>首先确保已经安装交叉编译工具，并将其加入系统<code>PATH</code>，然后下载并执行symlink修复工具：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/riscv/riscv-poky/master/scripts/sysroot-relativelinks.py</span><br><span class="line">sudo python sysroot-relativelinks.py <span class="variable">$RPIIMG</span></span><br></pre></td></tr></table></figure></p><h3 id="编译Qt-Base"><a href="#编译Qt-Base" class="headerlink" title="编译Qt Base"></a>编译Qt Base</h3><p>终于可以开始Qt的编译了，我们首先要做的是生成交叉编译用的<code>qmake</code>，编译安装<code>qtbase</code>库：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$RPIROOT</span>/qt5/qtbase</span><br><span class="line">./configure -opengl es2 -device linux-rasp-pi2-g++ -device-option CROSS_COMPILE=$(<span class="built_in">which</span> arm-linux-gnueabihf-gcc | sed <span class="string">'s/.\&#123;3\&#125;$//'</span>) -sysroot <span class="variable">$RPIIMG</span> -opensource -confirm-license -optimized-qmake -reduce-exports -release -make libs -prefix /usr/<span class="built_in">local</span>/qt5pi -extprefix /opt/qt5pi -hostprefix <span class="variable">$RPIQT</span></span><br><span class="line">make -j4</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></p><p><code>config</code>命令后面的那一大堆参数我是根据<a href="https://wiki.qt.io/RaspberryPi2EGLFS" target="_blank" rel="noopener">官方教程</a>来的, <del>其中<code>-device linux-rasp-pi2-g++</code>适用于树莓派2和3（不用试了没有<code>linux-rasp-pi3-g++</code>）</del>其中<code>-device</code>选项可以根据Qt源码目录下<code>qtbase/mkspecs/devices</code>文件夹进行选择，包括<code>linux-rasp-pi2-g++</code>以及<code>linux-rpi3-g++</code>等设备类型，如果你是树莓派1代，使用<code>linux-rasp-pi-g++</code>；<code>which arm-linux-gnueabihf-gcc | sed &#39;s/.\{3\}$//&#39;</code>得到的值是交叉编译器的路径及其前缀(即<code>arm-linux-gnueabihf-</code>)；<code>-sysroot</code>参数指定根文件系统的位置；<code>-prefix</code>指定在根文件系统中的安装路径；<code>-extprefix</code>参数设置后，安装qt时将在你的系统中该路径下同时安装一份，交叉编译Qt项目时qmake将使用该路径下的Qt lib；<code>-hostprefix</code>指定的是需要安装在宿主机的部分的路径，如<code>qmake</code>等工具是安装在宿主机中的；如果需要编译example，加上<code>-make example</code>。</p><div class="tip"><br>如果make过程中出现错误，我也没什么办法，清理仓库重新来过吧……<br></div><h3 id="编译Qt子模块"><a href="#编译Qt子模块" class="headerlink" title="编译Qt子模块"></a>编译Qt子模块</h3><p>编译安装完成qtbase后，就可以开始编译安装各个子模块了，注意使用刚刚生成的<code>qmake</code>来配置项目，比如我需要编译<code>qtvirtualkeyboard</code>:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$RPIROOT</span>/qt5/qtvirtualkeyboard</span><br><span class="line"><span class="variable">$RPIQT</span>/bin/qmake .</span><br><span class="line">make -j4</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure></p><p>注意Qt子模块之间的依赖关系，比如<code>qtvirtualkeyboard</code>依赖<code>qtquick2</code>，而<code>qtquick2</code>在<code>qtdeclarative</code>中，所以需要先安装<code>qtdeclarative</code>才能编译安装<code>qtvirtualkeyboard</code>。</p><h3 id="Qt-VirtualKeyboard"><a href="#Qt-VirtualKeyboard" class="headerlink" title="Qt VirtualKeyboard"></a>Qt VirtualKeyboard</h3><p>如果需要<code>qtvirtualkeyboard</code>提供拼音输入支持，在配置项目时添加参数<code>CONFIG+=&#39;lang-en_GB lang-zh_CN&#39;</code>，即：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$RPIROOT</span>/qt5/qtvirtualkeyboard</span><br><span class="line"><span class="variable">$RPIQT</span>/bin/qmake CONFIG+=<span class="string">'lang-en_GB lang-zh_CN'</span></span><br><span class="line">make -j4</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure></p><p>这样在使用虚拟键盘时就能够选择拼音输入法。</p><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>卸载根文件系统：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo umount <span class="variable">$RPIIMG</span></span><br></pre></td></tr></table></figure></p><p>此时Raspbian镜像中已经包含了Qt5.8库，PC端编写代码使用<code>$RPIQT/bin/qmake</code>配置编译完后，生成的二进制文件放在树莓派上就可以正常运行啦。经测试，虚拟键盘在<code>QtWidget</code>项目中弹不出来，但是对<code>qml</code>项目的支持非常好，反正也没什么别的解决方案，就这么凑合着用吧～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了在树莓派上使用Qt提供的虚拟键盘，最开始我将虚拟键盘的源码下载到树莓派上，使用Raspbian软件源中的Qt5库进行编译，结果运行时发现弹出虚拟键盘时，屏幕上除了虚拟键盘以外的区域均为黑色，无法正常显示其他窗口，猜测可能是虚拟键盘在X Window上显示有问题。为了解决这个诡异的问题，我决定为树莓派编译Qt5.8，交叉编译完的Qt显示时将绕过X Window，直接走FrameBuffer将图形显示在屏幕上，这样应该可以解决虚拟键盘在X Window上显示的问题。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>在树莓派上使用 PN532 NFC读卡器[0]——libnfc的安装配置</title>
    <link href="http://yoursite.com/2017/07/04/nfc_0/"/>
    <id>http://yoursite.com/2017/07/04/nfc_0/</id>
    <published>2017-07-03T16:00:00.000Z</published>
    <updated>2019-01-05T09:27:23.909Z</updated>
    
    <content type="html"><![CDATA[<p>最近需要在树莓派上使用使用NFC读取mifare classic卡中的信息，在X宝购买了一块PN532芯片的NFC读卡器，然后使用libnfc提供的接口进行开发，本文介绍一下libnfc的基本使用方法。<br><a id="more"></a></p><h3 id="PN532芯片介绍"><a href="#PN532芯片介绍" class="headerlink" title="PN532芯片介绍"></a>PN532芯片介绍</h3><blockquote><p>PN532是一个高度集成的NFC读写芯片，它包含80C51微控制器内核，集成了13.56MHz下的各种主动/被动式非接触通信方法和协议。</p></blockquote><p>此处给出PN532的<a href="https://cdn-shop.adafruit.com/datasheets/pn532ds.pdf" target="_blank" rel="noopener">DataSheet</a>和<a href="http://www.nxp.com/docs/en/user-guide/141520.pdf" target="_blank" rel="noopener">UserManual</a>。</p><p>PN532支持三种与主机之间的通信接口（可能还支持USB，不过我这块PN532板子上没有USB接口）：</p><ul><li>SPI</li><li>I2C</li><li>UART</li></ul><p>PN532传输模块支持6种不同的工作模式：</p><ul><li>读写器模式，支持ISO/IEC 14443A / MIFARE®机制</li><li>读写器模式，支持 FeliCa机制</li><li>读写器模式，支持ISO/IEC 14443B机制</li><li>卡操作模式，支持ISO 14443A / MIFARE®机制</li><li>卡操作模式，FeliCa机制</li><li>ISO/IEC18092，ECM340点对点</li></ul><p>本文中使用SPI与Raspberry Pi3之间进行通信，接线图就不放了，SPI接口一共就那么几根线。其实使用libnfc进行开发的话，使用什么接口都一样，libnfc会处理底层的通信细节，让开发者专注于PN532于芯片卡之间的通信过程。下文将讲述libnfc的配置方法。</p><h3 id="libnfc介绍"><a href="#libnfc介绍" class="headerlink" title="libnfc介绍"></a>libnfc介绍</h3><blockquote><p>libnfc是GNU公共许可正下发布的第一个免费的底层的NFC SDK和编程API。它对任何人都是完全免费和公开的。这个列表给出了目前<a href="http://nfc-tools.org/index.php?title=Libnfc:Features" target="_blank" rel="noopener">已经支持的功能</a>。libnfc支持所有的主流操作系统，包括GNU/Linux、Mac OS X和windows。其编译工作应该在兼容POSIX的系统中进行。libnfc库支持<a href="http://nfc-tools.org/index.php?title=Devices_compatibility_matrix" target="_blank" rel="noopener">多种NFC硬件</a>，如dongles、flat 和 OEM设备等。libnfc当前支持ISO/IEC 14443协议A、B，Felica、Jewel/Topaz标签和发起者和接收者的点对点数据交换。</p></blockquote><p>在libnfc支持的<a href="http://nfc-tools.org/index.php?title=Devices_compatibility_matrix" target="_blank" rel="noopener">硬件列表</a>中发现，其对PN532的各种接口都提供了很好的支持，So，放心的使用libnfc吧！（说的好像还有别的库可以用一样……）</p><p>目前libnfc的版本停留在1.7.1，可以从GitHub上得到它的<a href="https://github.com/nfc-tools/libnfc" target="_blank" rel="noopener">源码</a>，该网页有libnfc的<a href="http://www.libnfc.org/api/index.html" target="_blank" rel="noopener">官方文档</a>。</p><h3 id="libnfc安装与配置"><a href="#libnfc安装与配置" class="headerlink" title="libnfc安装与配置"></a>libnfc安装与配置</h3><p>开发环境为树莓派3，系统是Raspbian。</p><ol><li><p>安装libnfc的依赖库</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libusb-dev libpcsclite-dev</span><br></pre></td></tr></table></figure></li><li><p>安装libnfc</p><p> 这里有两种安装方法，直接使用apt安装和源码编译安装。</p><ul><li><p>apt安装</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libnfc-dev libnfc-bin</span><br></pre></td></tr></table></figure><p>  其中<code>dev</code>包包含libnfc的头文件和链接库文件，<code>bin</code>包包含了一些预编译的二进制工具（其实就是源码文件夹<code>example</code>里面的东西）。</p></li><li><p>源码安装</p><p>  其实源码安装也很简单粗暴，在Raspbian上也没有遇到什么莫名其妙的问题。</p><p>  首先安装CMake，如果已经安装了请忽略这一步：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install cmake</span><br></pre></td></tr></table></figure><p>  然后<code>cd</code>到libnfc的源码目录中，建立一个build文件夹，在build文件夹中进行编译安装：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure><p>至此libnfc安装完成。</p></li></ul></li><li><p>配置libnfc<br> libnfc安装完成后，需要编辑配置文件<code>/etc/nfc/libnfc.conf</code>，使其能够找到PN532设备，如果系统中没有这个文件，创建它，然后在文件中添加以下内容：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Allow device auto-detection (default: true)</span><br><span class="line"># Note: if this auto-detection is disabled, user has to set manually a device</span><br><span class="line"># configuration using file or environment variable</span><br><span class="line">allow_autoscan = true</span><br><span class="line"></span><br><span class="line"># Allow intrusive auto-detection (default: false)</span><br><span class="line"># Warning: intrusive auto-detection can seriously disturb other devices</span><br><span class="line"># This option is not recommended, user should prefer to add manually his device.</span><br><span class="line">allow_intrusive_scan = false</span><br><span class="line"></span><br><span class="line"># Set log level (default: error)</span><br><span class="line"># Valid log levels are (in order of verbosity): 0 (none), 1 (error), 2 (info), 3 (debug)</span><br><span class="line"># Note: if you compiled with --enable-debug option, the default log level is &quot;debug&quot;</span><br><span class="line">log_level = 1</span><br><span class="line"></span><br><span class="line"># Manually set default device (no default)</span><br><span class="line"># To set a default device, you must set both name and connstring for your device</span><br><span class="line"># Note: if autoscan is enabled, default device will be the first device available in device list.</span><br><span class="line">device.name = &quot;PN532&quot;</span><br><span class="line">device.connstring = &quot;pn532_spi:/dev/spidev0.0&quot;</span><br></pre></td></tr></table></figure><p> 如果你使用i2c进行通信，将最后一行改为：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">device.connstring = &quot;pn532_i2c:/dev/i2c-1&quot;</span><br></pre></td></tr></table></figure><p> 使用串口同理，修改最后一行的设备节点为你的串口设备。</p><p> 配置完成后，使用<code>nfc-list</code>查看是否配置成功，如果你是使用<code>apt</code>安装的<code>libnfc-bin</code>，直接在终端中输入<code>nfc-list</code>即可；如果使用源码安装libnfc，这个工具在libnfc源码文件夹中的<code>build/utils</code>文件夹中。<br> 运行<code>nfc-list</code>后如果看到如下输出，表示libnfc已经配置完成：<br> <img src="https://i.loli.net/2019/01/05/5c3078255dc4e.png" alt="result.png"></p> <div class="tip"><br> 一般情况下不会出现配置失败的情况，如果配置失败，即未能成功打开PN532设备，请检查：树莓派的对应接口是否已经配置，如SPI、I2C等；接线是否正确；PN532设备能否正常工作等。<br> </div></li></ol><h3 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h3><p>配置完成libnfc使之能够找到PN532设备之后，才是本系列的重点，请看下文<strong><a href="http://tiehichi.site/2017/09/18/archives/nfc_1/" target="_blank" rel="noopener">在树莓派上使用 PN532 NFC读卡器[1]——Mifare Classic 1K 协议解析</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近需要在树莓派上使用使用NFC读取mifare classic卡中的信息，在X宝购买了一块PN532芯片的NFC读卡器，然后使用libnfc提供的接口进行开发，本文介绍一下libnfc的基本使用方法。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用Hexo搭建博客</title>
    <link href="http://yoursite.com/2017/07/01/hexo-config/"/>
    <id>http://yoursite.com/2017/07/01/hexo-config/</id>
    <published>2017-06-30T16:00:00.000Z</published>
    <updated>2019-01-03T12:11:17.869Z</updated>
    
    <content type="html"><![CDATA[<p>今天成功的在我的VPS上使用Hexo搭建了个人博客，在此把搭建流程记录下来，作为我的第一篇博文。<br><a id="more"></a></p><h3 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h3><p>安装<code>nodejs</code>的方法可以参考<a href="https://www.digitalocean.com/community/tutorials/how-to-install-node-js-on-ubuntu-16-04#how-to-install-using-nvm" target="_blank" rel="noopener">此处</a></p><h3 id="安装配置Hexo"><a href="#安装配置Hexo" class="headerlink" title="安装配置Hexo"></a>安装配置Hexo</h3><p>根据官网的提示，Hexo的安装十分简单<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nvm install hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure></p><p>这样就完成了hexo的安装和启动，关于hexo的配置以及更换主题，hexo有很详细的文档可以参考，这里就不做赘述了。</p><h3 id="管理Hexo服务"><a href="#管理Hexo服务" class="headerlink" title="管理Hexo服务"></a>管理Hexo服务</h3><p>使用<code>hexo server</code>这种方式启动的服务并非 Deamon模式，查阅网上的资料，有一篇<a href="http://russellluo.com/2015/08/building-a-blog-with-hexo.html" target="_blank" rel="noopener">博客</a>提到使用supervisor工具来管理hexo服务。</p><p>ubuntu上supervisor的安装十分简单：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install supervisor</span><br></pre></td></tr></table></figure></p><p>安装完成后，添加hexo服务的配置，在文件<code>/etc/supervisor/conf.d/blog.conf</code>中添加如下行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[program:blog]</span><br><span class="line">command=/home/user/.nvm/v6.11.0/bin/hexo server</span><br><span class="line">directory=/home/user/blog</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br><span class="line">startsecs=5</span><br><span class="line">stopsignal=HUP</span><br><span class="line">stopasgroup=true</span><br><span class="line">stopwaitsecs=5</span><br><span class="line">stdout_logfile_maxbytes=20MB</span><br><span class="line">stdout_logfile=/var/log/supervisor/%(program_name)s.log</span><br><span class="line">stderr_logfile_maxbytes=20MB</span><br><span class="line">stderr_logfile=/var/log/supervisor/%(program_name)s.log</span><br></pre></td></tr></table></figure></p><p>其中<code>command</code>是hexo路径加上参数<code>server</code>，<code>directory</code>是你在<code>hexo init</code>的时候创建的hexo文件夹的路径。</p><p>编写完hexo服务的配置文件后，先别急着启动supervisor，因为会出现问题。上述hexo的配置中，将日志文件存放在<code>/var/log/supervisor</code>中，但是普通用户没有对该文件夹的读写权限，所以需要以root权限启动supervisor，但是前面安装的nodejs的环境变量是在普通用户下配置的，如果以root用户启动，就需要额外为root用户配置nodejs的环境变量，我觉得挺麻烦的，就采用另一种办法，修改<code>/var/log/supervisor</code>的所属组以及拥有者<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R user:users /var/<span class="built_in">log</span>/supervisor</span><br></pre></td></tr></table></figure></p><p>仅修改日志文件夹权限还不行，supervisor在启动的时候，需要用到UNIX本地套接字，这个文件将创建在<code>/var/run</code>目录下，而该目录普通用户也没有写权限，需要修改supervisor的配置文件，将该套接字文件的路径修改到<code>/tmp</code>目录下。</p><p>编辑文件<code>/etc/supervisor/supervisord.conf</code>，找到如下两行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file=/var/run/supervisor.sock</span><br><span class="line">serverurl=unix:///var/run/supervisor.sock</span><br></pre></td></tr></table></figure></p><p>可能你的系统中这两项参数的值跟我的不同，没关系，找到他们就行。然后将其修改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file=/tmp/supervisor.sock</span><br><span class="line">serverurl=unix:///tmp/supervisor.sock</span><br></pre></td></tr></table></figure></p><p><code>supervisor</code>服务本身使用<code>systemd</code>进行管理，所以可以使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl &#123; start | stop | restart | status &#125; supervisor</span><br></pre></td></tr></table></figure></p><p>查看<code>supervisor</code>服务的运行状态，仍然可以使用<code>supervisorctl status</code>查看被<code>supervisor</code>管理的服务运行状态。</p><p>如果出现<code>Permission denied</code>，记得加<code>sudo</code></p><h3 id="使用Nginx代理"><a href="#使用Nginx代理" class="headerlink" title="使用Nginx代理"></a>使用Nginx代理</h3><p>启动Hexo服务后会发现，Hexo服务运行在4000端口上，这在一个博客系统中反映到url上总感觉怪怪的，但是直接使用<code>hexo server -p 80</code>这种方法，在我的系统上启动不了，没权限使用80端口，继续查阅资料，还是这篇<a href="http://russellluo.com/2015/08/building-a-blog-with-hexo.html" target="_blank" rel="noopener">博客</a>详细讲述了使用Nginx进行代理的方法。</p><p>首先安装Nginx<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install nginx</span><br></pre></td></tr></table></figure></p><p>安装完成后，在<code>/etc/nginx/conf.d</code>目录下创建hexo服务的配置文件<code>blog.conf</code>，当然文件名随你喜欢，在文件中添加如下行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name &lt;SERVER-IP/DN&gt;;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://localhost:4000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/blog.access.log;</span><br><span class="line">    error_log /var/log/nginx/blog.error.log;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将其中的<code>&lt;SERVER-IP/DN&gt;</code>替换成你的服务器的IP或者域名，然后重启Nginx<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo nginx -t</span><br><span class="line">sudo nginx -s reload</span><br></pre></td></tr></table></figure></p><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>以上配置全部完成后，你就可以在浏览器使用<code>http://&lt;SERVER-IP/DN&gt;</code>访问你的博客主页啦~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天成功的在我的VPS上使用Hexo搭建了个人博客，在此把搭建流程记录下来，作为我的第一篇博文。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
