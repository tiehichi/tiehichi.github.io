<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tiehichi&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.tiehichi.site/"/>
  <updated>2022-06-15T07:21:11.280Z</updated>
  <id>https://www.tiehichi.site/</id>
  
  <author>
    <name>Tiehichi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ARMv7进程页表</title>
    <link href="https://www.tiehichi.site/2021/11/15/ARMv7%E8%BF%9B%E7%A8%8B%E9%A1%B5%E8%A1%A8/"/>
    <id>https://www.tiehichi.site/2021/11/15/ARMv7进程页表/</id>
    <published>2021-11-15T00:00:00.000Z</published>
    <updated>2022-06-15T07:21:11.280Z</updated>
    
    <content type="html"><![CDATA[<p><code>Linux</code>每个进程有独立的页表，函数调用路径：<code>_do_fork</code> -&gt; <code>copy_process</code> -&gt; <code>copy_mm</code> -&gt; <code>dup_mm</code> -&gt; <code>mm_alloc_pgd</code> -&gt; <code>pgd_alloc</code>。<code>pgd_alloc()</code>的实现与平台相关，对于arm32平台，其实现位于<code>arch/arm/mm/pgd.c</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * need to get a 16k page for level 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">pgd_t</span> *pgd_alloc(struct mm_struct *mm)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">pgd_t</span> *new_pgd, *init_pgd;</span><br><span class="line">    <span class="keyword">pud_t</span> *new_pud, *init_pud;</span><br><span class="line">    <span class="keyword">pmd_t</span> *new_pmd, *init_pmd;</span><br><span class="line">    <span class="keyword">pte_t</span> *new_pte, *init_pte;</span><br><span class="line"></span><br><span class="line">    new_pgd = __pgd_alloc();</span><br><span class="line">    <span class="keyword">if</span> (!new_pgd)</span><br><span class="line">        <span class="keyword">goto</span> no_pgd;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(new_pgd, <span class="number">0</span>, USER_PTRS_PER_PGD * <span class="keyword">sizeof</span>(<span class="keyword">pgd_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Copy over the kernel and IO PGD entries</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    init_pgd = pgd_offset_k(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(new_pgd + USER_PTRS_PER_PGD, init_pgd + USER_PTRS_PER_PGD,</span><br><span class="line">               (PTRS_PER_PGD - USER_PTRS_PER_PGD) * <span class="keyword">sizeof</span>(<span class="keyword">pgd_t</span>));</span><br><span class="line"></span><br><span class="line">    clean_dcache_area(new_pgd, PTRS_PER_PGD * <span class="keyword">sizeof</span>(<span class="keyword">pgd_t</span>));</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进程的全局页表使用<code>__pgd_alloc</code>分配，共分配4个页16k大小：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __pgd_alloc()(pgd_t *)__get_free_pages(GFP_KERNEL, 2)</span></span><br></pre></td></tr></table></figure><p>然后使用<code>memset</code>将分配的内存置0，但是这里置0的内存大小为<code>USER_PTRS_PER_PGD * sizeof(pgd_t)</code>，而<code>USER_PTRS_PER_PGD</code>为<code>TASK_SIZE/PGDIR_SIZE</code>，<code>TASK_SIZE</code>我们知道是用户虚拟地址空间大小，所以<code>USER_PTRS_PER_PGD</code>实际上是用户虚拟地址空间需要占用多少条pgd项，既<code>memset</code>置0的部分刚好用来映射用户虚拟地址空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USER_PTRS_PER_PGD(TASK_SIZE / PGDIR_SIZE)</span></span><br></pre></td></tr></table></figure><p>接下来的<code>pgd_offset_k(0)</code>是从<code>init_mm</code>中获取pgd的地址，实际上就是<code>swapper_pg_dir</code>，然后从<code>swapper_pg_dir</code>中将内核虚拟地址映射表复制到刚申请的pgd中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* to find an entry in a kernel page-table-directory */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pgd_offset_k(addr)pgd_offset(&amp;init_mm, addr)</span></span><br></pre></td></tr></table></figure><p>这部分代码可以说明，每个进程有自己的pgd，pgd中包含了用户虚拟地址空间映射和内核虚拟地址空间映射，不同进程的内核虚拟地址空间映射是相同的，在arm32上都是从<code>swapper_pg_dir</code>复制过来的。<br>对比arm64平台的<code>pgd_alloc</code>实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pgd_t</span> *pgd_alloc(struct mm_struct *mm)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (PGD_SIZE == PAGE_SIZE)</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">pgd_t</span> *)__get_free_page(PGALLOC_GFP);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> kmem_cache_alloc(pgd_cache, PGALLOC_GFP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见arm64中并没有从<code>swapper_pg_dir</code>中拷贝内核虚拟地址映射的步骤，这是因为arm64上linux进程用户地址空间和内核地址空间都是256TB，Linux内核会配置使用<code>TTBR0</code>和<code>TTBR1</code>寄存器，<code>TTBR0</code>存放用户pgd的基址，<code>TTBR1</code>存放内核pgd的基址，MMU根据传入的虚拟地址来选择使用<code>TTBR0</code>还是<code>TTBR1</code>寄存器。</p><p>arm32平台同样具有<code>TTBR0</code>和<code>TTBR1</code>两个全局页表基址寄存器，但Linux内核并没有使用<code>TTBR1</code>，这是因为arm32对用户虚拟地址空间与内核虚拟地址空间的分割无法满足Linux内核的需求。</p><p>ARMv7虚拟地址映射支持长描述符和短描述符两种形式，Linux内核使用短描述符形式，两级页表：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1679957/1636945934322-7288573e-8f01-4b42-833c-039211d6e225.png#clientId=u0ab16135-8a44-4&from=paste&id=u5ac204a8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=505&originWidth=970&originalType=url&ratio=1&size=68107&status=done&style=none&taskId=udbdaa2a9-1d19-42fc-a12c-ab82321af7f" alt="image.png"></p><p><code>TTBR</code>为一级页表基地址寄存器，ARMv7有<code>TTBR0</code>和<code>TTBR1</code>两个页表基址寄存器，可以满足全局页表切换的需要；但是Linux内核虚拟地址空间分配为用户空间3G，内核空间1G，内核虚拟起始地址为<code>0xC0000000</code>；根据ARM手册的描述，<code>TTBR0</code>和<code>TTBR1</code>的切换规则为：<code>TTBCR</code>寄存器值为N，取值范围0-7，如果N为0，则使用<code>TTBR0</code>；如果N&gt;0，虚拟地址第<code>[31:32-N]</code>位均为0，则使用<code>TTBR0</code>，否则使用<code>TTBR1</code>。满足使用<code>TTBR1</code>的最小N值为1，这时<code>TTBR1</code>的虚拟地址范围为<code>0x80000000-0xFFFFFFFF</code>，因此Linux内核不使用<code>TTBR1</code>寄存器。</p><p>在不使用<code>TTRB1</code>的情况下，有两种方式可以满足Linux平台的需求，既每个进程有独立的用户虚拟地址映射和相同的内核虚拟地址映射：一是进程进入内核态时，修改<code>TTBR0</code>来切换页表；另一种方法是创建进程时将内核虚拟地址映射复制到进程的全局页表中。根据前面的分析，Linux内核选择了第二种方式，这是基于性能考虑，通过修改<code>TTBR0</code>来切换页表，每次陷入内核态都需要进行页表地址的切换，非常影响性能；而复制页表项的方式仅需在进程创建时完成，不影响进程运行过程中的性能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;Linux&lt;/code&gt;每个进程有独立的页表，函数调用路径：&lt;code&gt;_do_fork&lt;/code&gt; -&amp;gt; &lt;code&gt;copy_process&lt;/code&gt; -&amp;gt; &lt;code&gt;copy_mm&lt;/code&gt; -&amp;gt; &lt;code&gt;dup_mm&lt;/
      
    
    </summary>
    
    
      <category term="kernel research" scheme="https://www.tiehichi.site/categories/kernel-research/"/>
    
    
  </entry>
  
  <entry>
    <title>ACCESS_ONCE()和READ_ONCE()</title>
    <link href="https://www.tiehichi.site/2021/08/03/ACCESS_ONCE()%E5%92%8CREAD_ONCE()/"/>
    <id>https://www.tiehichi.site/2021/08/03/ACCESS_ONCE()和READ_ONCE()/</id>
    <published>2021-08-03T00:00:00.000Z</published>
    <updated>2022-06-15T07:21:11.280Z</updated>
    
    <content type="html"><![CDATA[<p>内核代码中经常看到使用 <code>ACCESS_ONCE()</code> ， <code>READ_ONCE()</code> 和 <code>WRITE_ONCE()</code> 的地方，本文分析一下这几个宏的作用和实现方式。</p><h2 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h2><p>考虑下面这段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">owner</span>;</span></span><br><span class="line"></span><br><span class="line">    owner = ACCESS_ONCE(lock-&gt;owner);</span><br><span class="line">    <span class="keyword">if</span> (owner &amp;&amp; !mutex_spin_on_owner(lock, owner))</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果忽略 <code>ACCESS_ONCE()</code> 宏，那么编译器可能认为 <code>owner</code> 在循环中并没有被修改，因此不需要每次循环都读取 <code>lock-&gt;owner</code> 并将其赋值给 <code>owner</code> ，那么编译器优化之后的代码就可能变成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">owner</span>;</span></span><br><span class="line">owner = ACCESS_ONCE(lock-&gt;owner);</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (owner &amp;&amp; !mutex_spin_on_owner(lock, owner))</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是 <code>lock-&gt;owner</code> 可能会被另外一个线程改变，而这段优化后的代码无法捕获这种改变，会引起代码运行结果异常； <code>ACCESS_ONCE()</code> 宏的作用就是阻止编译器的优化。</p><h2 id="ACCESS-ONCE"><a href="#ACCESS-ONCE" class="headerlink" title="ACCESS_ONCE()"></a>ACCESS_ONCE()</h2><p><code>ACCESS_ONCE()</code> 宏的实现位于 <code>include/linux/compiler.h</code> 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ACCESS_ONCE(x) (*(volatile typeof(x) *)&amp;(x))</span></span><br></pre></td></tr></table></figure><p>该宏为变量 <code>x</code> 临时添加 <code>volatile</code> 关键字来阻止编译器的优化，如重排序、合并访问等。<br>这里需要思考一个问题，一般在编写用户层代码时，如果一个变量可能在多个线程之间共享，我们会在变量声明的时候为其添加 <code>volatile</code> 关键字，为什么内核中要使用这种方式，而不是在声明时就添加 <code>volatile</code> 呢？我的理解是声明时添加 <code>volatile</code> ，会阻止编译器对该变量的任何优化，这会让代码整体产生一定的性能损耗；而内核为了极致的性能，仅在需要阻止编译器优化时添加 <code>volatile</code> ，其余的地方仍然让编译器尽可能的进行优化。</p><h2 id="READ-ONCE"><a href="#READ-ONCE" class="headerlink" title="READ_ONCE()"></a>READ_ONCE()</h2><p>较新版本的内核中已经很少使用 <code>ACCESS_ONCE()</code> 宏，而转为使用 <code>READ_ONCE()</code> 。<br><code>READ_ONCE()</code> 的引入源于一个编译器bug：在GCC 4.6和4.7版本中，对于非标量数据类型，例如结构体，编译器会自动移除变量的 <code>volatile</code> 关键字。解决这个问题可以从编译器的角度入手，修复编译器bug，但一来很多系统仍在使用GCC 4.6和4.7，二来这个bug的出现也说明了 <code>ACCESS_ONCE()</code> 宏的实现不够健壮。为了解决这个问题，同时保持代码的兼容性，最终内核引入了 <code>READ_ONCE()</code> 宏，并保留了 <code>ACCESS_ONCE()</code> 的实现。<br><code>READ_ONCE()</code> 实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __READ_ONCE_SIZE\</span></span><br><span class="line">(&#123;\</span><br><span class="line"><span class="keyword">switch</span> (<span class="built_in">size</span>) &#123;\</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: *(__u8 *)res = *(<span class="keyword">volatile</span> __u8 *)p; <span class="keyword">break</span>;\</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: *(__u16 *)res = *(<span class="keyword">volatile</span> __u16 *)p; <span class="keyword">break</span>;\</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>: *(__u32 *)res = *(<span class="keyword">volatile</span> __u32 *)p; <span class="keyword">break</span>;\</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>: *(__u64 *)res = *(<span class="keyword">volatile</span> __u64 *)p; <span class="keyword">break</span>;\</span><br><span class="line"><span class="keyword">default</span>:\</span><br><span class="line">barrier();\</span><br><span class="line">__builtin_memcpy((<span class="keyword">void</span> *)res, (<span class="keyword">const</span> <span class="keyword">void</span> *)p, <span class="built_in">size</span>);\</span><br><span class="line">barrier();\</span><br><span class="line">&#125;\</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __always_inline</span><br><span class="line"><span class="keyword">void</span> __read_once_size(<span class="keyword">const</span> <span class="keyword">volatile</span> <span class="keyword">void</span> *p, <span class="keyword">void</span> *res, <span class="keyword">int</span> <span class="built_in">size</span>)</span><br><span class="line">&#123;</span><br><span class="line">__READ_ONCE_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该宏判断变量的大小，对于1、2、4、8个字节的变量，将其转换为对应的标量类型：u8、u16、u32和u64，并添加 <code>volatile</code> 关键字；对于超过8个字节类型，使用 <code>barrier()</code> 来阻止优化。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;内核代码中经常看到使用 &lt;code&gt;ACCESS_ONCE()&lt;/code&gt; ， &lt;code&gt;READ_ONCE()&lt;/code&gt; 和 &lt;code&gt;WRITE_ONCE()&lt;/code&gt; 的地方，本文分析一下这几个宏的作用和实现方式。&lt;/p&gt;
&lt;h2 id=&quot;编译器优化&quot;&gt;
      
    
    </summary>
    
    
      <category term="kernel research" scheme="https://www.tiehichi.site/categories/kernel-research/"/>
    
    
  </entry>
  
  <entry>
    <title>dm-verity使能</title>
    <link href="https://www.tiehichi.site/2021/05/14/dm-verity%E4%BD%BF%E8%83%BD/"/>
    <id>https://www.tiehichi.site/2021/05/14/dm-verity使能/</id>
    <published>2021-05-14T00:00:00.000Z</published>
    <updated>2022-06-15T07:21:11.284Z</updated>
    
    <content type="html"><![CDATA[<p>根据<a href="https://www.kernel.org/doc/html/latest/admin-guide/device-mapper/verity.html#example" target="_blank" rel="noopener">内核文档</a>，用户空间可以通过 <code>veritysetup</code> 命令创建块设备的哈希树，创建 <code>mapped device</code> 并启用 <code>dm-verity</code> 功能，我们来从内核的角度分析一下该命令如何创建激活 <code>mapped device</code> 并启用 <code>dm-verity</code> 功能。</p><h2 id="device-mapper驱动结构"><a href="#device-mapper驱动结构" class="headerlink" title="device mapper驱动结构"></a>device mapper驱动结构</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1679957/1620971139058-94938b70-2252-41dc-9919-0b2baf482e48.jpeg#height=576&id=LbJNA&name=image.jpeg&originHeight=631&originWidth=593&originalType=binary&size=54650&status=done&style=none&width=541" alt="image.jpeg"></p><p>上图展示了 <code>device mapper</code> 的结构，即一个 <code>mapped device</code> 拥有一个 <code>mapping table</code> ，这个表负责维护 <code>mapped device</code> 与 <code>target device</code> 之间的映射关系，这些 <code>target</code> 既可以是物理设备，也可以是另一个 <code>mapped device</code> 。<br>内核使用下图中的几个结构体来描述这种映射关系：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1679957/1620972275115-b1afc057-14ec-4c70-9edf-1ba76861b428.jpeg#height=683&id=pgOrG&name=image.jpeg&originHeight=683&originWidth=721&originalType=binary&size=156516&status=done&style=none&width=721" alt="image.jpeg"></p><p><code>mapped_device</code> 描述设备， <code>dm_table</code> 记录 <code>md</code> 设备下面有多少个 <code>target</code> ， <code>dm_target</code> 与 <code>target_type</code> 共同描述了 <code>target</code> 的驱动， <code>targe_type</code> 则是存放操作 <code>target</code> 设备的方法。我们的 <code>dm-verity</code> 功能，就是其中一种 <code>target_type</code> 。</p><h2 id="dm-verity模块初始化"><a href="#dm-verity模块初始化" class="headerlink" title="dm-verity模块初始化"></a>dm-verity模块初始化</h2><p>内核中的 <code>dm-verity</code> 功能实现在内核源码树 <code>drivers/md/dm-verity-target.c</code> 中。<br>前面说到 <code>dm-verity</code> 功能是作为 <code>target_type</code> 来实现的，内核中的 <code>target_type</code> 使用链表进行管理，使用时通过 <code>target_type.name</code> 进行索引； <code>dm-verity</code> 模块初始化的过程就是将其对应的 <code>target_type</code> 结构体注册到链表上：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * file: drivers/md/dm-verity-target.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">target_type</span> <span class="title">verity_target</span> = &#123;</span></span><br><span class="line">    .name       = <span class="string">"verity"</span>,</span><br><span class="line">    .version    = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    .<span class="keyword">module</span>     = THIS_MODULE,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">dm_verity_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    r = dm_register_target(&amp;verity_target);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * file: drivers/md/dm-target.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">LIST_HEAD</span><span class="params">(_targets)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dm_register_target</span><span class="params">(struct target_type *tt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (__find_target_type(tt-&gt;name))</span><br><span class="line">        rv = -EEXIST;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        list_add(&amp;tt-&gt;<span class="built_in">list</span>, &amp;_targets);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="veritysetup的参数"><a href="#veritysetup的参数" class="headerlink" title="veritysetup的参数"></a>veritysetup的参数</h2><p><code>veritysetup</code> 激活 <code>dm-verity</code> 功能需要提供：</p><ul><li><code>mapped device</code> 设备名</li><li>数据来源设备节点</li><li>哈希树设备节点</li><li>根哈希</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">veritysetup create &lt;device name&gt; &lt;data device&gt; &lt;hashtree device&gt; &lt;root <span class="built_in">hash</span>&gt;</span><br></pre></td></tr></table></figure><p>这条命令其实包括了两个过程，创建 <code>mapped device</code> 设备和处理 <code>mapped device</code> 与 <code>data device</code> <code>hashtree device</code> 之间的关系。这两个过程均为使用 <code>ioctl</code> 向 <code>/dev/mapper/control</code> 发送命令来实现的。</p><h2 id="device-mapper控制节点"><a href="#device-mapper控制节点" class="headerlink" title="device mapper控制节点"></a>device mapper控制节点</h2><p><code>/dev/mapper/control</code> 在内核中的描述如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * file: drivers/md/dm-ioctl.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> _<span class="title">ctl_fops</span> = &#123;</span></span><br><span class="line">    .<span class="built_in">open</span> = nonseekable_open,</span><br><span class="line">    .unlocked_ioctl  = dm_ctl_ioctl,</span><br><span class="line">    .compat_ioctl = dm_compat_ctl_ioctl,</span><br><span class="line">    .owner   = THIS_MODULE,</span><br><span class="line">    .llseek  = noop_llseek,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> _<span class="title">dm_misc</span> = &#123;</span></span><br><span class="line">    .minor      = MAPPER_CTRL_MINOR,</span><br><span class="line">    .name       = DM_NAME,</span><br><span class="line">    .nodename   = DM_DIR <span class="string">"/"</span> DM_CONTROL_NODE,</span><br><span class="line">    .fops       = &amp;_ctl_fops</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过 <code>ioctl</code> 对其进行访问，内核中的函数调用路径为： <code>dm_ctl_ioctl -&gt; ctl_ioctl -&gt; lookup_ioctl</code> 。 <code>lookup_ioctl</code> 再根据用户发送的命令，来返回不同的函数指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ioctl_fn <span class="title">lookup_ioctl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">int</span> *ioctl_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> cmd;</span><br><span class="line">        <span class="keyword">int</span> flags;</span><br><span class="line">        ioctl_fn fn;</span><br><span class="line">    &#125; _ioctls[] = &#123;</span><br><span class="line">        &#123;DM_VERSION_CMD, <span class="number">0</span>, <span class="literal">NULL</span>&#125;, <span class="comment">/* version is dealt with elsewhere */</span></span><br><span class="line">        ...</span><br><span class="line">        &#123;DM_DEV_CREATE_CMD, IOCTL_FLAGS_NO_PARAMS, dev_create&#125;,</span><br><span class="line">        ...</span><br><span class="line">        &#123;DM_TABLE_LOAD_CMD, <span class="number">0</span>, table_load&#125;,</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(cmd &gt;= ARRAY_SIZE(_ioctls)))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    *ioctl_flags = _ioctls[cmd].flags;</span><br><span class="line">    <span class="keyword">return</span> _ioctls[cmd].fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>veritysetup</code> 使能 <code>dm-verity</code> 的核心，是通过 <code>ioctl</code> 发送这两个命令： <code>DM_DEV_CREATE_CMD</code> 和 <code>DM_TABLE_LOAD_CMD</code> 。 <code>DM_DEV_CREATE_CMD</code> 就是创建 <code>mapped-device</code> ，我们把重点放在 <code>DM_TABLE_LOAD_CMD</code> 上。</p><h2 id="DM-TABLE-LOAD-CMD"><a href="#DM-TABLE-LOAD-CMD" class="headerlink" title="DM_TABLE_LOAD_CMD"></a>DM_TABLE_LOAD_CMD</h2><p>我们顺着 <code>DM_TABLE_LOAD_CMD</code> 命令对应的函数 <code>table_load</code> 往下看：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">table_load</span><span class="params">(struct dm_ioctl *param, <span class="keyword">size_t</span> param_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    md = find_device(param);</span><br><span class="line">    ...</span><br><span class="line">    r = dm_table_create(&amp;t, get_mode(param), param-&gt;target_count, md);</span><br><span class="line">    ...</span><br><span class="line">    r = populate_table(t, param, param_size);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的实现比较长，我们只关注上面这三行：首先根据参数，找到对应的 <code>md</code> 设备，然后创建 <code>dm_table</code> 并将其与 <code>md</code> 设备关联，然后将参数继续传递给 <code>populate_table</code> 函数进行处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">populate_table</span><span class="params">(struct dm_table *table,</span></span></span><br><span class="line"><span class="function"><span class="params">                struct dm_ioctl *param, <span class="keyword">size_t</span> param_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; param-&gt;target_count; i++) &#123;</span><br><span class="line">        r = next_target(spec, next, <span class="built_in">end</span>, &amp;spec, &amp;target_params);</span><br><span class="line">        ...</span><br><span class="line">        r = dm_table_add_target(table, spec-&gt;target_type,</span><br><span class="line">                    (<span class="keyword">sector_t</span>) spec-&gt;sector_start,</span><br><span class="line">                    (<span class="keyword">sector_t</span>) spec-&gt;length,</span><br><span class="line">                    target_params);</span><br><span class="line">        ...</span><br><span class="line">        next = spec-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数根据 <code>param</code> 参数中的 <code>target_count</code> ，通过 <code>dm_table_add_target</code> 函数向 <code>dm_table</code> 添加 <code>target</code> ；此处我们要添加的 <code>target</code> 就是 <code>dm-verity-target</code> 。<br>继续看 <code>dm_table_add_target</code> 的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dm_table_add_target</span><span class="params">(struct dm_table *t, <span class="keyword">const</span> <span class="keyword">char</span> *type,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">sector_t</span> start, <span class="keyword">sector_t</span> len, <span class="keyword">char</span> *params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    -&gt;type = dm_get_target_type(type);</span><br><span class="line">    ...</span><br><span class="line">    r = tgt-&gt;type-&gt;ctr(tgt, argc, argv);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dm_get_target_type</code> 通过 <code>type</code> 来找到对应的 <code>target_type</code> 结构体，此处的 <code>type</code> 实际上就是 <code>target_type.name</code> ，我们要找到 <code>verity_target</code> ，所以此处传入的 <code>type</code> 为 <code>&quot;verity&quot;</code>。<br>找到 <code>target_type</code> 后，调用对应的 <code>ctr</code> 函数；对应到 <code>dm-verity</code> 中就是函数 <code>verity_ctr</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">verity_ctr</span><span class="params">(struct dm_target *ti, <span class="keyword">unsigned</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    r = dm_get_device(ti, argv[<span class="number">1</span>], FMODE_READ, &amp;v-&gt;data_dev);</span><br><span class="line">    ...</span><br><span class="line">    r = dm_get_device(ti, argv[<span class="number">2</span>], FMODE_READ, &amp;v-&gt;hash_dev);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>verity_ctr</code> 才是真正的对 <code>dm-verity</code> 功能进行初始化，包括设置 <code>data device</code> ， <code>hash device</code> 等信息，创建 <code>dm_verity</code> 结构体实例；这些操作完成之后，针对前面创建的 <code>md</code> 设备的 <code>dm-verity</code> 功能已经使能，之后对其进行的读写操作，会调用到 <code>verity_target</code> 的 <code>map</code> 函数—— <code>verity_map</code> ，该函数负责处理IO之前的映射关系，设置 <code>bio_end_io</code> 函数指针，即 <code>block io</code> 的完成方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">verity_map</span><span class="params">(struct dm_target *ti, struct bio *bio)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    bio-&gt;bi_bdev = v-&gt;data_dev-&gt;bdev;</span><br><span class="line">    bio-&gt;bi_iter.bi_sector = verity_map_sector(v, bio-&gt;bi_iter.bi_sector);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    bio-&gt;bi_end_io = verity_end_io;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>verity_end_io</code> 则是将校验的过程加入到 <code>work_queue</code> 中，这样每次对块设备的访问，都会触发 <code>dm-verity</code> 校验机制。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;根据&lt;a href=&quot;https://www.kernel.org/doc/html/latest/admin-guide/device-mapper/verity.html#example&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;内核文档&lt;/a&gt;，
      
    
    </summary>
    
    
      <category term="kernel research" scheme="https://www.tiehichi.site/categories/kernel-research/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux-PAM配置文件</title>
    <link href="https://www.tiehichi.site/2020/10/30/Linux-PAM%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <id>https://www.tiehichi.site/2020/10/30/Linux-PAM配置文件/</id>
    <published>2020-10-30T00:00:00.000Z</published>
    <updated>2022-06-15T07:21:11.280Z</updated>
    
    <content type="html"><![CDATA[<p><code>PAM</code>框架意为可拔插身份认证模块，该框架实现了通过模块化的方式配置Linux平台上的身份认证框架；我们常见的需要身份认证的应用，例如<code>login</code>、<code>ssh</code>、<code>su</code>等都可以接入<code>PAM</code>框架，使其能够方便的配置身份认证方式。</p><p><code>pam</code>配置文件有两个路径：<code>/etc/pam.conf</code>和<code>/etc/pam.d/</code>，先来看<code>pam.conf</code>文件。</p><h2 id="etc-pam-conf-配置文件语法"><a href="#etc-pam-conf-配置文件语法" class="headerlink" title="/etc/pam.conf 配置文件语法"></a><code>/etc/pam.conf</code> 配置文件语法</h2><p>pam的配置文件以<code>stack</code>的形式来组织，每个配置文件相当于一个栈；在配置文件中，每条规则一行，每行有五个字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service type control module-path module-argument</span><br></pre></td></tr></table></figure><p>最后两个字段<code>module-path</code>和<code>module-argument</code>为需要调用的pam模块和传入模块的参数，根据模块的不同，支持的参数也不一样，这里就不过多分析；我们重点放在前三个字段上。</p><h3 id="service"><a href="#service" class="headerlink" title="service"></a><code>service</code></h3><p><code>service</code>字段通常是应用程序的名称，例如<code>login</code>，<code>su</code>等；通过<code>service</code>字段可以区分当前规则用于哪个应用程序。即<code>login</code>程序进行身份验证时，只会根据service为login的规则进行。</p><h3 id="type"><a href="#type" class="headerlink" title="type"></a><code>type</code></h3><p>该字段用于标识规则对应的组；pam规则共有四个组，分别为：<code>account</code>、<code>auth</code>、<code>password</code>和<code>session</code>。</p><ul><li><p><code>account</code></p><p>这个类型的规则用于账户管理（不校验身份），例如根据时间来限制哪些用户可以登录，哪些用户不能登录。</p></li><li><p><code>auth</code></p><p><code>auth</code>是我们最常见的规则类型，用于配置用户身份校验方式；比如我们可以将用户配置成简单的密码校验，也可以配置成多因素校验。</p></li><li><p><code>password</code></p><p>这个模块类型用于更新用户的登录标识，如密码等。</p></li><li><p><code>session</code></p><p><code>session</code>类型用在用户登录之前或之后进行一些操作，例如在某个用户登录之后，挂载某个目录，或者在用户登录之前清除它的<code>selinux</code>标签。</p></li></ul><p>注意，上面四种类型，他们的功能都不是绝对的；<code>type</code>字段最重要的功能是告诉当前规则中的<code>pam</code>模块去调用某些特定类型的函数；以<code>pam_unix.so</code>模块为例，如果存在如下两条规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">login session required pam_unix.so open</span><br><span class="line">login auth required pam_unix.so</span><br></pre></td></tr></table></figure><p>在<code>type</code>为<code>session</code>的规则中，PAM框架会调用<code>pam_unix.so</code>模块中的<code>pam_sm_open_session()</code>方法；而在<code>auth</code>类型的规则中，则会调用<code>pam_sm_authenticate()</code>方法。</p><h3 id="control"><a href="#control" class="headerlink" title="control"></a><code>control</code></h3><p>该字段表示当PAM模块未能成功完成校验任务时的行为；该字段有两种表示方法，简单写法共有6个值，复杂写法是方括号中加上键值对表示。</p><p>在简单写法中，<code>control</code>字段可以取以下值：<code>required</code>、<code>requisite</code>、<code>sufficient</code>、<code>optional</code>、<code>include</code>和<code>substack</code>。</p><ul><li><p><code>required</code></p><p>当前模块校验失败，整个PAM校验过程最终会返回失败，但是后续模块仍然会被调用。</p></li><li><p><code>requisite</code></p><p>当前模块校验失败将直接返回上级应用，不会继续调用后续模块。</p></li><li><p><code>sufficient</code></p><p>如果当前模块返回success，并且此模块之前的required模块没有返回失败，PAM会直接向上层应用返回成功，不继续调用后续模块；如果当前模块返回失败，PAM会继续调用后续模块，对最终结果没有影响。</p></li><li><p><code>optional</code></p><p>仅在当前的<code>service</code> <code>type</code>只有这一个模块时，这个模块返回成功或者失败才有意义。</p></li><li><p><code>include</code></p><p>将指定配置文件中的所有给定type的行包含到当前配置中.</p></li><li><p><code>substack</code></p><p>功能上与<code>include</code>相同，不同的是<code>substack</code>会创建一个子栈；子栈作为一个单独的模块执行，子栈中的<code>done</code>和<code>die</code>动作不会影响父栈，子栈中的跳转也不会跳转到父栈中；<code>reset</code>动作会初始化子栈。</p></li></ul><p><code>control</code>字段的复杂表示语法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[value1=action1 value2=action2 ...]</span><br></pre></td></tr></table></figure><p>这里的<code>valueN</code>对应这条规则中，调用的<code>pam</code>模块相应函数的返回值，取值范围为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">success, open_err, symbol_err, service_err, system_err, buf_err, perm_denied, auth_err, cred_insufficient, authinfo_unavail, user_unknown, maxtries, new_authtok_reqd, acct_expired, session_err, cred_unavail, cred_expired, cred_err, no_module_data, conv_err, authtok_err, authtok_recover_err, authtok_lock_busy, authtok_disable_aging, try_again, ignore, abort, authtok_expired, module_unknown, bad_item, conv_again, incomplete, default</span><br></pre></td></tr></table></figure><p>这些值定义在头文件<code>_pam_types.h</code>中。</p><p><code>actionN</code>表示当函数返回<code>valueN</code>时，相应的动作，可以取以下值：<code>ignore</code>、<code>bad</code>、<code>die</code>、<code>ok</code>、<code>done</code>、无符号整数和<code>reset</code>。</p><ul><li><p><code>ignore</code></p><p>模块的返回状态不会影响最终返回值。</p></li><li><p><code>bad</code></p><p>该动作应用于返回失败的时候；如果这个模块是整个栈中第一个失败的模块，那么这个模块的返回值就是整个栈的最终返回值。</p></li><li><p><code>die</code></p><p>功能上与b<code>ad</code>一致，但是<code>die</code>动作将终止当前栈，即不再执行后续的规则，直接返回。</p></li><li><p><code>ok</code></p><p>如果在此动作之前，栈的返回状态为<code>PAM_SUCCESS</code>，那么此动作对应的<code>value</code>将覆盖当前栈状态；如果之前的状态为<code>failed</code>，此动作对应的<code>value</code>就不会覆盖栈状态。</p></li><li><p>done</p><p>功能上与ok相同，但是会终止当前栈，不再执行后续的规则，直接返回。</p></li><li><p><code>N</code>（正整数）</p><p>向下跳过N条规则，注意不能为0.</p></li><li><p><code>reset</code></p><p>清除当前栈的所有状态，重新开始下一条规则。</p></li></ul><p>其实简单写法就是复杂写法的一种缩写，简单写法的规则同样也可以用复杂写法表示，他们之间存在以下等式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">required    =   [success=ok new_authtok_reqd=ok ignore=ignore default=bad]</span><br><span class="line">requisite   =   [success=ok new_authtok_reqd=ok ignore=ignore default=die]</span><br><span class="line">sufficient  =   [success=done new_authtok_reqd=done default=ignore]</span><br><span class="line">optional    =   [success=ok new_authtok_reqd=ok default=ignore]</span><br></pre></td></tr></table></figure><h2 id="etc-pam-d-目录中的配置文件"><a href="#etc-pam-d-目录中的配置文件" class="headerlink" title="/etc/pam.d 目录中的配置文件"></a><code>/etc/pam.d</code> 目录中的配置文件</h2><p><code>pam.d</code>目录中的配置文件语法与<code>pam.conf</code>的略微不同；区别在于其只有四个字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type control module-path module-argument</span><br></pre></td></tr></table></figure><p>对应字段的取值范围和规则仍然与<code>pam.conf</code>相同；这里缺少的<code>service</code>字段体现在文件名上，即配置文件的文件名规则，与<code>service</code>相同。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;PAM&lt;/code&gt;框架意为可拔插身份认证模块，该框架实现了通过模块化的方式配置Linux平台上的身份认证框架；我们常见的需要身份认证的应用，例如&lt;code&gt;login&lt;/code&gt;、&lt;code&gt;ssh&lt;/code&gt;、&lt;code&gt;su&lt;/code&gt;等都可以接入&lt;
      
    
    </summary>
    
    
      <category term="Linux-PAM" scheme="https://www.tiehichi.site/categories/Linux-PAM/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux进程栈空间大小</title>
    <link href="https://www.tiehichi.site/2020/10/22/Linux%E8%BF%9B%E7%A8%8B%E6%A0%88%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F/"/>
    <id>https://www.tiehichi.site/2020/10/22/Linux进程栈空间大小/</id>
    <published>2020-10-22T00:00:00.000Z</published>
    <updated>2022-06-15T07:21:11.280Z</updated>
    
    <content type="html"><![CDATA[<p>分析过程基于<code>Linux kernel 3.18.120</code></p><h2 id="内核栈"><a href="#内核栈" class="headerlink" title="内核栈"></a>内核栈</h2><p><code>Linux</code>上进程的相关属性在内核中表示为<code>task_struct</code>，该结构体中<code>stack</code>成员指向进程内核栈的栈底：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">void</span> *<span class="built_in">stack</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道<code>Linux</code>的子进程创建都是通过复制父进程的<code>task_struct</code>来进行的，所以可以从系统的0号进程着手分析进程内核栈的大小；0号进程为<code>init_task</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> <span class="title">init_task</span> = <span class="title">INIT_TASK</span>(<span class="title">init_task</span>);</span></span><br></pre></td></tr></table></figure><p>来看看<code>init_task</code>的<code>stack</code>字段的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_TASK(tsk)  \</span></span><br><span class="line">&#123;                                   \</span><br><span class="line">    ...</span><br><span class="line">    .<span class="built_in">stack</span>      = &amp;init_thread_info,                \</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">#define init_thread_info    (init_thread_union.thread_info)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">union</span> thread_union init_thread_union;</span><br></pre></td></tr></table></figure><p><code>init_task</code>的<code>stack</code>字段实际上指向thread_union联合体中的<code>thread_info</code>，再来看一下<code>thread_union</code>的结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> thread_union &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> <span class="title">thread_info</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">stack</span>[THREAD_SIZE/<span class="keyword">sizeof</span>(<span class="keyword">long</span>)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以<code>init_task</code>进程的内核栈就是<code>init_thread_union.stack</code>，而<code>thread_info</code>位于内核栈的栈底；内核栈声明为<code>unsigned long</code>类型的数组，其实际大小与平台相关，即为<code>THREAD_SIZE</code>的定义；对于<code>arm32</code>平台，它的定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* arch/arm/include/asm/thread_info.h */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_SIZE_ORDER   1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_SIZE     (PAGE_SIZE &lt;&lt; THREAD_SIZE_ORDER)</span></span><br></pre></td></tr></table></figure><p>而<code>PAGE_SIZE</code>的定义为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* arch/arm/include/asm/page.h */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SHIFT      12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE       (_AC(1,UL) &lt;&lt; PAGE_SHIFT)</span></span><br></pre></td></tr></table></figure><p>所以对于<code>arm32</code>平台，<code>PAGE_SIZE</code>大小为<code>4k</code>，<code>THREAD_SIZE</code>大小为<code>8k</code>；此时可以确定 <strong><code>init_task</code>的内核栈大小为<code>8k</code></strong>。</p><p>前面提到进程的创建是在内核中拷贝父进程的<code>task_struct</code>，来看一下这部分代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct task_struct *<span class="title">dup_task_struct</span><span class="params">(struct task_struct *orig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> *<span class="title">ti</span>;</span></span><br><span class="line">    <span class="keyword">int</span> node = tsk_fork_get_node(orig);</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    tsk = alloc_task_struct_node(node);</span><br><span class="line">    ...</span><br><span class="line">    ti = alloc_thread_info_node(tsk, node);</span><br><span class="line">    ...</span><br><span class="line">    err = arch_dup_task_struct(tsk, orig);</span><br><span class="line">    ...</span><br><span class="line">    tsk-&gt;<span class="built_in">stack</span> = ti;</span><br><span class="line">    ...</span><br><span class="line">    setup_thread_stack(tsk, orig);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在复制<code>task_struct</code>的时候，新的<code>task_struct-&gt;stack</code>通过<code>alloc_thread_info_node</code>来分配：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct thread_info *<span class="title">alloc_thread_info_node</span><span class="params">(struct task_struct *tsk,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> = <span class="title">alloc_kmem_pages_node</span>(<span class="title">node</span>, <span class="title">THREADINFO_GFP</span>,</span></span><br><span class="line"><span class="class">                          <span class="title">THREAD_SIZE_ORDER</span>);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> page ? page_address(page) : <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>THREAD_SIZE_ORDER</code>为<code>1</code>，所以分配了<code>2</code>个<code>page</code>，所以我们可以确定，进程的内核栈大小为<code>8k</code>。</p><h2 id="用户栈大小"><a href="#用户栈大小" class="headerlink" title="用户栈大小"></a>用户栈大小</h2><h3 id="用户栈虚拟地址空间最大值"><a href="#用户栈虚拟地址空间最大值" class="headerlink" title="用户栈虚拟地址空间最大值"></a>用户栈虚拟地址空间最大值</h3><p>通过<code>ulimit</code>命令可以查看当前系统的进程用户栈的虚拟地址空间上限，单位为<code>kB</code>；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~ <span class="comment"># ulimit -s</span></span><br><span class="line">8192</span><br></pre></td></tr></table></figure><p>即当前系统中，用户栈的虚拟地址空间上限为<code>8M</code>；为了确认这个值的出处，使用<code>strace</code>，确认<code>ulimit</code>执行过程中，使用了哪些系统调用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-&gt; % strace sh -c <span class="string">"ulimit -s"</span></span><br><span class="line">...</span><br><span class="line">prlimit64(0, RLIMIT_STACK, NULL, &#123;rlim_cur=8192*1024, rlim_max=RLIM64_INFINITY&#125;) = 0</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>接着到内核中查找该系统调用的实现，函数名为<code>SYSCALL_DEFINE4(prlimit64, .......)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* kernel/sys.c */</span></span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE4(prlimit64, <span class="keyword">pid_t</span>, pid, <span class="keyword">unsigned</span> <span class="keyword">int</span>, resource,</span><br><span class="line">        <span class="keyword">const</span> struct rlimit64 __user *, new_rlim,</span><br><span class="line">        struct rlimit64 __user *, old_rlim)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    tsk = pid ? find_task_by_vpid(pid) : current;</span><br><span class="line">    ...</span><br><span class="line">    ret = do_prlimit(tsk, resource, new_rlim ? &amp;<span class="keyword">new</span> : <span class="literal">NULL</span>,</span><br><span class="line">            old_rlim ? &amp;old : <span class="literal">NULL</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的第一个参数为<code>pid</code>，第二个参数为资源的索引；这里可以理解为查找<code>pid</code>为<code>0</code>的进程中，<code>RLIMIT_STACK</code>的值；函数查找到<code>pid</code>对应的<code>task_struct</code>，然后调用<code>do_prlimit</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* kernel/sys.c */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_prlimit</span><span class="params">(struct task_struct *tsk, <span class="keyword">unsigned</span> <span class="keyword">int</span> resource,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct rlimit *new_rlim, struct rlimit *old_rlim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> *<span class="title">rlim</span>;</span></span><br><span class="line">    ...</span><br><span class="line">    rlim = tsk-&gt;signal-&gt;rlim + resource;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>do_prlimit</code>的实现为我们指明了到何处去查找<code>RLIMIT_STACK</code>的值，即<code>tsk-&gt;signal-&gt;rlim + resource</code>；我们知道0号进程为<code>init_task</code>，所以找到<code>init_task-&gt;signal-&gt;rlim</code>进行确认</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* include/linux/init_task.h */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_TASK(tsk)  \</span></span><br><span class="line">&#123;  </span><br><span class="line">    ...</span><br><span class="line">    .signal        = &amp;init_signals,                \</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">#define INIT_SIGNALS(sig) &#123;                     \</span><br><span class="line">    ...</span><br><span class="line">    .rlim       = INIT_RLIMITS,                 \</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着找到<code>INIT_RLIMITS</code>宏的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* include/asm-generic/resource.h */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_RLIMITS                            \</span></span><br><span class="line">&#123;                                   \</span><br><span class="line">    ...</span><br><span class="line">    [RLIMIT_STACK]      = &#123;       _STK_LIM,  RLIM_INFINITY &#125;,   \</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_STK_LIM</code>即为当前系统中，进程用户栈的虚拟地址空间上限：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* include/uapi/linux/resource.h */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _STK_LIM    (8*1024*1024)</span></span><br></pre></td></tr></table></figure><h3 id="当前用户栈虚拟地址空间大小"><a href="#当前用户栈虚拟地址空间大小" class="headerlink" title="当前用户栈虚拟地址空间大小"></a>当前用户栈虚拟地址空间大小</h3><p>可以从<code>proc</code>文件系统中，查看进程的虚拟地址空间分布；以<code>init</code>进程为例，其<code>pid</code>为1，可以通过以下命令查看<code>init</code>进程的虚拟地址空间分布，在<code>arm32</code>平台，内核版本<code>3.18.120</code>，<code>init</code>进程的用户栈空间大小为<code>132kB</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~ <span class="meta"># cat /proc/1/smaps</span></span><br><span class="line">...</span><br><span class="line">beec2000-beee3000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>          [<span class="built_in">stack</span>]</span><br><span class="line">Size:                <span class="number">132</span> kB</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>仔细观察会发现，任意进程在启动后，其栈空间大小基本都是<code>132kB</code>；在分析原因之前，我们先来看一下进程的虚拟地址空间分布：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1679957/1619073769696-a162481e-6c27-4cab-a313-2b3229285ccd.png" alt="进程虚拟地址空间-进程虚拟地址空间.png"></p><p>进程的虚拟地址空间大小为<code>4GB</code>，其中内核空间<code>1GB</code>，用户空间<code>3GB</code>，在<code>arm32</code>平台上，二者之间存在一个大小为<code>16M</code>的空隙；用户空间的准确大小为<code>TASK_SIZE</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* arch/arm/include/asm/memory.h */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_SIZE       (UL(CONFIG_PAGE_OFFSET) - UL(SZ_16M))</span></span><br></pre></td></tr></table></figure><p>即用户空间的地址范围为<code>0x00000000~0xBEFFFFFF</code>。</p><p>上图左侧为用户空间内的虚拟空间分布，分别为：用户栈（向下增长），内存映射段（向下增长），堆（向上增长）以及<code>BSS</code>、<code>Data</code>和<code>Text</code>；我们关注的重点在用户空间中的栈空间。</p><p>在Linux系统中，运行二进制需要通过exec族系统调用进行，例如<code>execve</code>、<code>execl</code>、<code>execv</code>等，而这些函数最终都会切换到<code>kernel space</code>，调用<code>do_execve_common()</code>，我们从这个函数开始分析：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_execve_common</span><span class="params">(struct filename *filename,</span></span></span><br><span class="line"><span class="function"><span class="params">                struct user_arg_ptr argv,</span></span></span><br><span class="line"><span class="function"><span class="params">                struct user_arg_ptr envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    file = do_open_exec(filename);      <span class="comment">// 在内核中打开可执行文件</span></span><br><span class="line">    ...</span><br><span class="line">    retval = bprm_mm_init(bprm);        <span class="comment">// 初始化进程内存空间描述符</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* 拷贝文件名、环境变量和执行参数到bprm */</span></span><br><span class="line">    retval = copy_strings_kernel(<span class="number">1</span>, &amp;bprm-&gt;filename, bprm);</span><br><span class="line">    ...</span><br><span class="line">    retval = copy_strings(bprm-&gt;envc, envp, bprm);</span><br><span class="line">    ...</span><br><span class="line">    retval = copy_strings(bprm-&gt;argc, argv, bprm);</span><br><span class="line">    ...</span><br><span class="line">    retval = exec_binprm(bprm);         <span class="comment">// 处理bprm</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数中的<code>bprm</code>是类型为<code>struct linux_binprm</code>的结构体，主要用来存储运行可执行文件时所需要的参数，如虚拟内存空间<code>vma</code>、内存描述符<code>mm</code>、还有文件名和环境变量等信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linux_binprm</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> p; <span class="comment">/* current top of mem */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> argc, envc;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * filename;  <span class="comment">/* Name of binary as seen by procps */</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着回到<code>do_execve_common</code>函数，在调用<code>bprm_mm_init</code>初始化内存空间描述符时，第一次为进程的栈空间分配了一个页：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 文件：fs/exec.c</span></span><br><span class="line"><span class="comment"> * 函数调用关系：do_execve_common()-&gt;bprm_mm_init()-&gt;__bprm_mm_init()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __bprm_mm_init(struct linux_binprm *bprm)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    vma-&gt;vm_end = STACK_TOP_MAX;</span><br><span class="line">    vma-&gt;vm_start = vma-&gt;vm_end - PAGE_SIZE;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>vma</code>就是进程的栈虚拟地址空间，这段<code>vma</code>区域的结束地址设置为<code>STACK_TOP_MAX</code>，大小为<code>PAGE_SIZE</code>；这两个宏的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* arch/arm/include/asm/processor.h */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_TOP_MAX   TASK_SIZE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* arch/arm/include/asm/memory.h */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_SIZE       (UL(CONFIG_PAGE_OFFSET) - UL(SZ_16M))       <span class="comment">// CONFIG_PAGE_OFFSET定义为0xC0000000</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* arch/arm/include/asm/page.h */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SHIFT      12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE       (_AC(1,UL) &lt;&lt; PAGE_SHIFT)</span></span><br></pre></td></tr></table></figure><p>此时，进程的栈空间如下图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1679957/1619073695987-abd6cd30-9cd7-4f21-a9cb-25e66030609f.png" alt="进程虚拟地址空间-bprm_mm_init.png"></p><p>继续回到<code>do_execve_common()</code>函数，到目前为止，内核还没有识别到可执行文件的格式，也没有解析可执行文件中各个段的数据；在<code>exec_binprm()</code>中，会遍历在内核中注册支持的可执行文件格式，并调用该格式的<code>load_binary</code>方法来处理对应格式的二进制文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 文件：fs/exec.c</span></span><br><span class="line"><span class="comment"> * 函数调用关系：do_execve_common()-&gt;exec_binprm()-&gt;search_binary_handler()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search_binary_handler</span><span class="params">(struct linux_binprm *bprm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> *<span class="title">fmt</span>;</span></span><br><span class="line">    ...</span><br><span class="line">    list_for_each_entry(fmt, &amp;formats, lh) &#123;</span><br><span class="line">        ...</span><br><span class="line">        retval = fmt-&gt;load_binary(bprm);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>search_binary_handler()</code>会依次调用系统中注册的可执行文件格式<code>load_binary()</code>方法；<code>load_binary()</code>方法中会自行识别当前二进制格式是否支持；以<code>ELF</code>格式为例，其注册的<code>load_binary</code>方法为<code>load_elf_binary()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* fs/binfmt_elf.c */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">load_elf_binary</span><span class="params">(struct linux_binprm *bprm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loc-&gt;elf_ex.e_phnum; i++) &#123;</span><br><span class="line">        ...</span><br><span class="line">            retval = kernel_read(bprm-&gt;file, elf_ppnt-&gt;p_offset,      <span class="comment">// 读取ELF中的各个段</span></span><br><span class="line">                         elf_interpreter,</span><br><span class="line">                         elf_ppnt-&gt;p_filesz);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    retval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),</span><br><span class="line">                 executable_stack);</span><br><span class="line">    ...</span><br><span class="line">    current-&gt;mm-&gt;start_stack = bprm-&gt;p;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数的实现比较复杂，这里我们重点关注<code>setup_arg_pages()</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setup_arg_pages</span><span class="params">(struct linux_binprm *bprm,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_top,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> executable_stack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    stack_top = arch_align_stack(stack_top);</span><br><span class="line">    stack_top = PAGE_ALIGN(stack_top);</span><br><span class="line">    ...</span><br><span class="line">    stack_shift = vma-&gt;vm_end - stack_top;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* Move stack pages down in memory. */</span></span><br><span class="line">    <span class="keyword">if</span> (stack_shift) &#123;</span><br><span class="line">        ret = shift_arg_pages(vma, stack_shift);        <span class="comment">// 移动arg pages</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    stack_expand = <span class="number">131072U</span>L; <span class="comment">/* randomly 32*4k (or 2*64k) pages */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (stack_size + stack_expand &gt; rlim_stack)</span><br><span class="line">        stack_base = vma-&gt;vm_end - rlim_stack;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        stack_base = vma-&gt;vm_start - stack_expand;</span><br><span class="line">    ...</span><br><span class="line">    ret = expand_stack(vma, stack_base);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面我们已经初始化了一个页的栈空间，用来存放二进制文件名、参数和环境变量等；在<code>setup_arg_pages()</code>中，我们把前面这一个页的栈空间移动到<code>stack_top</code>的位置；在调用函数时，<code>stack_top</code>的值是<code>randomize_stack_top(STACK_TOP)</code>，即一个随机地址，这里是为了安全性而实现的栈地址随机化；函数通过<code>shift_arg_pages()</code>将页移动到新的地址，移动后的栈如下图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1679957/1619073715280-ba9fe2c7-e41a-44ac-a0de-2a875d118e36.png" alt="进程虚拟地址空间-shift_arg_pages.png"></p><p>接着回到<code>setup_arg_pages()</code>函数，关注如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">stack_expand = <span class="number">131072U</span>L; <span class="comment">/* randomly 32*4k (or 2*64k) pages */</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (stack_size + stack_expand &gt; rlim_stack)</span><br><span class="line">    stack_base = vma-&gt;vm_end - rlim_stack;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    stack_base = vma-&gt;vm_start - stack_expand;</span><br><span class="line">...</span><br><span class="line">ret = expand_stack(vma, stack_base);</span><br></pre></td></tr></table></figure><p><code>expand_stack()</code>函数用来扩展栈虚拟地址空间的大小，<code>stack_base</code>是新的栈基地址，这里的<code>stack_expand</code>是一个固定值，大小为<code>128k</code>，即此处将栈空间扩展<code>128k</code>的大小，扩展后栈空间如下：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1679957/1619073769672-7b6e92c2-f096-446d-8b61-b11c2d141d8b.png" alt="进程虚拟地址空间-expand_stack.png"></p><p>所以扩展后的栈虚拟地址空间为<code>4kB+128kB</code>，刚刚好<code>132kB</code>.</p><h2 id="栈顶地址随机化"><a href="#栈顶地址随机化" class="headerlink" title="栈顶地址随机化"></a>栈顶地址随机化</h2><p>前面介绍<code>setup_arg_pages()</code>函数移动栈顶的时候提到，出于安全原因，会将栈顶移动到一个随机的地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 文件：fs/binfmt_elf.c</span></span><br><span class="line"><span class="comment"> * 函数调用关系：load_elf_binary()-&gt;setup_arg_pages()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">load_elf_binary</span><span class="params">(struct linux_binprm *bprm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    retval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),</span><br><span class="line">                 executable_stack);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>randomize_stack_top(STACK_TOP)</code>就是将<code>STACK_TOP</code>进行随机化处理，在我们的平台上。<code>STACK_TOP</code>与<code>STACK_TOP_MAX</code>的值相同，为<code>0xBF000000</code>；我们来分析一下<code>randomize_stack_top()</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* fs/binfmt_elf.c */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STACK_RND_MASK</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_RND_MASK (0x7ff &gt;&gt; (PAGE_SHIFT - 12)) <span class="comment">/* 8MB of VA */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">randomize_stack_top</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> stack_top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> random_variable = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((current-&gt;flags &amp; PF_RANDOMIZE) &amp;&amp;</span><br><span class="line">        !(current-&gt;personality &amp; ADDR_NO_RANDOMIZE)) &#123;</span><br><span class="line">        random_variable = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) get_random_int();</span><br><span class="line">        random_variable &amp;= STACK_RND_MASK;</span><br><span class="line">        random_variable &lt;&lt;= PAGE_SHIFT;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_STACK_GROWSUP</span></span><br><span class="line">    <span class="keyword">return</span> PAGE_ALIGN(stack_top) + random_variable;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> PAGE_ALIGN(stack_top) - random_variable;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">函数整体非常好理解，就是获取一个随机值，再根据栈向上还是向下增长，将栈顶地址加上或减去这个随机值；我们重点关注下面两行：</span><br><span class="line"></span><br><span class="line">``` C</span><br><span class="line">random_variable &amp;= STACK_RND_MASK;</span><br><span class="line">random_variable &lt;&lt;= PAGE_SHIFT;</span><br></pre></td></tr></table></figure><p><code>STACK_RND_MASK</code>的值为<code>0x7FF</code>，<code>PAGE_SHIFT</code>为<code>12</code>；第一行将获取的随机值范围限制在<code>0~0x7FF</code>的范围内；第二行将该值左移<code>12</code>位，这样得到的随机数范围就变成了<code>0~0x7FF000</code>，可以理解为<strong>栈顶地址是在一个<code>8MB</code>的范围内取一个<code>4kB</code>对齐的随机值</strong>。</p><h2 id="线程的用户栈"><a href="#线程的用户栈" class="headerlink" title="线程的用户栈"></a>线程的用户栈</h2><p>我们知道在<code>Linux</code>系统上，无论是进程还是线程，都是通过<code>clone</code>系统调用来创建，区别是传入的参数不同；为了确认创建线程时使用的参数，我准备了一个测试程序，然后使用<code>strace</code>来确认：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">function</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"function call\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread;</span><br><span class="line">    pthread_create(&amp;thread, <span class="literal">NULL</span>, function, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(thread,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序的<code>strace</code>部分输出（在<code>x86</code>平台上运行）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone(child_stack=<span class="number">0x7fd2500d0fb0</span>, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tid=[<span class="number">36747</span>], tls=<span class="number">0x7fd2500d1700</span>, child_tidptr=<span class="number">0x7fd2500d19d0</span>) = <span class="number">36747</span></span><br></pre></td></tr></table></figure><p>我们可以看到调用<code>clone</code>的时候传入的<code>flags</code>，其中与内存相关最重要的<code>flags</code>是<code>CLONE_VM</code>；接着我们来看内核部分的源码，仍然从<code>copy_process()</code>函数开始：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* kernel/fork.c */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct task_struct *<span class="title">copy_process</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_start,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">int</span> __user *child_tidptr,</span></span></span><br><span class="line"><span class="function"><span class="params">                    struct pid *pid,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">int</span> trace)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    retval = copy_mm(clone_flags, p);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">copy_mm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags, struct task_struct *tsk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>, *<span class="title">oldmm</span>;</span></span><br><span class="line">    ...</span><br><span class="line">    oldmm = current-&gt;mm;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_VM) &#123;</span><br><span class="line">        atomic_inc(&amp;oldmm-&gt;mm_users);</span><br><span class="line">        mm = oldmm;</span><br><span class="line">        <span class="keyword">goto</span> good_mm;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>copy_mm</code>中，检查了<code>clone_flags</code>，如果设置了<code>CLONE_VM</code>，那么将当前<code>task_struct-&gt;mm</code>指针赋值给新的<code>task_struct-&gt;mm</code>；所以我们可以得到结论，通过<code>pthread</code>库创建的线程，其内存是与主线程共享的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;分析过程基于&lt;code&gt;Linux kernel 3.18.120&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;内核栈&quot;&gt;&lt;a href=&quot;#内核栈&quot; class=&quot;headerlink&quot; title=&quot;内核栈&quot;&gt;&lt;/a&gt;内核栈&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Linux&lt;/code&gt;
      
    
    </summary>
    
    
      <category term="kernel research" scheme="https://www.tiehichi.site/categories/kernel-research/"/>
    
    
  </entry>
  
  <entry>
    <title>为什么static函数不能mock</title>
    <link href="https://www.tiehichi.site/2020/09/29/%E4%B8%BA%E4%BB%80%E4%B9%88static%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BDmock/"/>
    <id>https://www.tiehichi.site/2020/09/29/为什么static函数不能mock/</id>
    <published>2020-09-29T00:00:00.000Z</published>
    <updated>2022-06-15T07:21:11.284Z</updated>
    
    <content type="html"><![CDATA[<p>在使用<code>cmocka</code>单元测试框架进行单元测试的过程中，发现声明为<code>static</code>的函数是不能<code>mock</code>的；为什么这类函数无法被<code>mock</code>呢？需要先分析一下<code>mock</code>函数的实现原理。</p><h2 id="通过连接器参数进行mock"><a href="#通过连接器参数进行mock" class="headerlink" title="通过连接器参数进行mock"></a>通过连接器参数进行<code>mock</code></h2><p>很多<code>C</code>语言的单元测试框架，需要通过设置链接器参数来实现函数的<code>mock</code>，例如想要<code>mock</code> <code>open</code>这个系统调用，需要在编译时添加参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Wl,--wrap=open</span><br></pre></td></tr></table></figure><p><code>-Wl</code>是指后面的参数是添加给连接器的；指定该参数后，调用<code>open</code>的时候会转而调用<code>__wrap_open</code>，所以我们只需要实现一个<code>__wrap_open</code>函数，就可以屏蔽<code>open</code>系统调用；如果需要调用原来的<code>open</code>函数，可以显式调用<code>__real_open</code>。</p><h2 id="mock的原理"><a href="#mock的原理" class="headerlink" title="mock的原理"></a><code>mock</code>的原理</h2><p>根据<code>mock</code>的实现方式，我们可以确定<code>C</code>语言的<code>mock</code>实现是连接器在链接程序时，将<code>open</code>符号链接到<code>__wrap_open</code>，并且将<code>__real_open</code>符号链接到系统调用<code>open</code>。</p><h2 id="不能mock的函数"><a href="#不能mock的函数" class="headerlink" title="不能mock的函数"></a>不能<code>mock</code>的函数</h2><p>确定了<code>mock</code>的实现方式，就可以分析一下这些不能<code>mock</code>的函数究竟为什么不能<code>mock</code>。</p><p>声明为<code>static</code>的函数，特点是只能在当前文件内使用，所以如果被测试函数调用了<code>static</code>的函数，这两个函数必然在同一个文件中，并且不能被其他文件中的函数调用。</p><h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><p>为了确认这个问题，我们准备一份测试用的代码，分为两个<code>.c</code>文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * func.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">function_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">function_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = function_1();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"x = %d\n"</span>, x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * main.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">function_2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    function_2();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译生成<code>.o</code>文件，并链接生成可执行文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -g -O0 -c func.c</span><br><span class="line">gcc -g -O0 -c main.c</span><br><span class="line">gcc -o main main.o func.o -g -O0</span><br></pre></td></tr></table></figure><p>接着我们来分析一下<code>function_2()</code>函数，函数中有两次函数调用，一次调用同文件中的<code>function_1()</code>，另一次调用<code>printf()</code>，所以其对应的汇编代码中，应该存在两个<code>callq</code>指令(<code>x64</code>平台)；所以我们来使用<code>objdump</code>来反汇编一下<code>func.o</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">-&gt; % objdump -d func.o</span><br><span class="line"></span><br><span class="line">func.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;function_1&gt;:</span><br><span class="line">   0:    f3 0f 1e fa              endbr64</span><br><span class="line">   4:    55                       push   %rbp</span><br><span class="line">   5:    48 89 e5                 mov    %rsp,%rbp</span><br><span class="line">   8:    b8 0c 00 00 00           mov    <span class="variable">$0xc</span>,%eax</span><br><span class="line">   d:    5d                       pop    %rbp</span><br><span class="line">   e:    c3                       retq</span><br><span class="line"></span><br><span class="line">000000000000000f &lt;function_2&gt;:</span><br><span class="line">   f:    f3 0f 1e fa              endbr64</span><br><span class="line">  13:    55                       push   %rbp</span><br><span class="line">  14:    48 89 e5                 mov    %rsp,%rbp</span><br><span class="line">  17:    48 83 ec 10              sub    <span class="variable">$0x10</span>,%rsp</span><br><span class="line">  1b:    b8 00 00 00 00           mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">  20:    e8 db ff ff ff           callq  0 &lt;function_1&gt;</span><br><span class="line">  25:    89 45 <span class="built_in">fc</span>                 mov    %eax,-0x4(%rbp)</span><br><span class="line">  28:    8b 45 <span class="built_in">fc</span>                 mov    -0x4(%rbp),%eax</span><br><span class="line">  2b:    89 c6                    mov    %eax,%esi</span><br><span class="line">  2d:    48 8d 3d 00 00 00 00     lea    0x0(%rip),%rdi        <span class="comment"># 34 &lt;function_2+0x25&gt;</span></span><br><span class="line">  34:    b8 00 00 00 00           mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">  39:    e8 00 00 00 00           callq  3e &lt;function_2+0x2f&gt;</span><br><span class="line">  3e:    8b 45 <span class="built_in">fc</span>                 mov    -0x4(%rbp),%eax</span><br><span class="line">  41:    c9                       leaveq</span><br><span class="line">  42:    c3                       retq</span><br></pre></td></tr></table></figure><p>注意<code>function_2</code>的汇编代码中，两个<code>callq</code>指令的不同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">20:    e8 db ff ff ff           callq  0 &lt;function_1&gt;</span><br><span class="line">39:    e8 00 00 00 00           callq  3e &lt;function_2+0x2f&gt;</span><br></pre></td></tr></table></figure><p><code>callq</code>指令码为<code>e8</code>，第一个<code>callq</code>调用<code>function_1</code>，地址为<code>ff ff ff db</code>，<code>x86</code>指令集上<code>callq</code>的地址用补码表示，所以这个地址实际上是个负数，对应的十进制为<code>-37</code>，<code>callq</code>下一条指令的起始地址，加上这个相对跳转地址，刚好是<code>function_1</code>的地址。</p><p>再看一下第二条<code>callq</code>指令，它的地址是<code>00 00 00 00</code>，实际上是等待填充，现在还不知道之后会跳转到哪。</p><p>再来反汇编可执行文件看一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">0000000000001171 &lt;function_2&gt;:</span><br><span class="line">    1171:    f3 0f 1e fa              endbr64</span><br><span class="line">    1175:    55                       push   %rbp</span><br><span class="line">    1176:    48 89 e5                 mov    %rsp,%rbp</span><br><span class="line">    1179:    48 83 ec 10              sub    <span class="variable">$0x10</span>,%rsp</span><br><span class="line">    117d:    b8 00 00 00 00           mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">    1182:    e8 db ff ff ff           callq  1162 &lt;function_1&gt;</span><br><span class="line">    1187:    89 45 <span class="built_in">fc</span>                 mov    %eax,-0x4(%rbp)</span><br><span class="line">    118a:    8b 45 <span class="built_in">fc</span>                 mov    -0x4(%rbp),%eax</span><br><span class="line">    118d:    89 c6                    mov    %eax,%esi</span><br><span class="line">    118f:    48 8d 3d 6e 0e 00 00     lea    0xe6e(%rip),%rdi        <span class="comment"># 2004 &lt;_IO_stdin_used+0x4&gt;</span></span><br><span class="line">    1196:    b8 00 00 00 00           mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">    119b:    e8 b0 fe ff ff           callq  1050 &lt;<span class="built_in">printf</span>@plt&gt;</span><br><span class="line">    11a0:    8b 45 <span class="built_in">fc</span>                 mov    -0x4(%rbp),%eax</span><br><span class="line">    11a3:    c9                       leaveq</span><br><span class="line">    11a4:    c3                       retq</span><br><span class="line">    11a5:    66 2e 0f 1f 84 00 00     nopw   %cs:0x0(%rax,%rax,1)</span><br><span class="line">    11ac:    00 00 00</span><br><span class="line">    11af:    90                       nop</span><br></pre></td></tr></table></figure><p>我们仍然关注<code>function_2</code>中的两条<code>callq</code>指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1182:    e8 db ff ff ff           callq  1162 &lt;function_1&gt;</span><br><span class="line">119b:    e8 b0 fe ff ff           callq  1050 &lt;printf@plt&gt;</span><br></pre></td></tr></table></figure><p>第一条<code>callq</code>的相对跳转地址并未发生任何变化，但是第二条指令中，地址已经被填充，而不再是之前的<code>00 00 00 00</code>。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>根据前面的分析我们可以确定，<code>static</code>函数被调用时，调用地址再编译时就已经确定，并且在链接时不会再去改变它的相对地址；而我们的<code>mock</code>参数是添加在链接器上的，理所当然无法<code>mock</code> <code>static</code>函数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在使用&lt;code&gt;cmocka&lt;/code&gt;单元测试框架进行单元测试的过程中，发现声明为&lt;code&gt;static&lt;/code&gt;的函数是不能&lt;code&gt;mock&lt;/code&gt;的；为什么这类函数无法被&lt;code&gt;mock&lt;/code&gt;呢？需要先分析一下&lt;code&gt;mock&lt;/c
      
    
    </summary>
    
    
      <category term="单元测试" scheme="https://www.tiehichi.site/categories/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>CLONE_FS标志对子进程文件系统的影响</title>
    <link href="https://www.tiehichi.site/2020/06/18/CLONE_FS%E6%A0%87%E5%BF%97%E5%AF%B9%E5%AD%90%E8%BF%9B%E7%A8%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BD%B1%E5%93%8D/"/>
    <id>https://www.tiehichi.site/2020/06/18/CLONE_FS标志对子进程文件系统的影响/</id>
    <published>2020-06-18T00:00:00.000Z</published>
    <updated>2022-06-15T07:21:11.280Z</updated>
    
    <content type="html"><![CDATA[<h2 id="争论"><a href="#争论" class="headerlink" title="争论"></a>争论</h2><p>这两天在研究沙盒的时候,跟同事争论了一下如下场景: 使用clone加上CLONE_FS创建子进程,父进程使用chroot,是否会同时对子进程的文件系统产生影响. 根据man手册对于CLONE_FS的描述,使用CLONE_FS创建子进程,子进程或者父进程任意一个调用chroot, chdir或者umask, 都会对另一进程产生影响. 具体怎么影响需要看一下内核的源码.</p><h2 id="系统调用在内核中的实现"><a href="#系统调用在内核中的实现" class="headerlink" title="系统调用在内核中的实现"></a>系统调用在内核中的实现</h2><p>Linux的系统调用在定义在<code>include/linux/syscalls.h</code>中，例如<code>clone</code>系统调用，在<code>syscalls.h</code>中的定义为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CLONE_BACKWARDS</span></span><br><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_clone</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">int</span> __user *, <span class="keyword">unsigned</span> <span class="keyword">long</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> __user *)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CLONE_BACKWARDS3</span></span><br><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_clone</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">int</span>, <span class="keyword">int</span> __user *,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> __user *, <span class="keyword">unsigned</span> <span class="keyword">long</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_clone</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">int</span> __user *,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> __user *, <span class="keyword">unsigned</span> <span class="keyword">long</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>内核中系统调用的实现，一般会使用<code>SYSCALL_DEFINEn</code>宏进行封装，其中的n为系统调用的参数个数；使用该宏时，第一个参数为系统调用的名字，仍以<code>clone</code>为例，对应的<code>SYSCALL_DEFINEn</code>宏的实现为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __ARCH_WANT_SYS_CLONE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CLONE_BACKWARDS</span></span><br><span class="line">SYSCALL_DEFINE5(clone, <span class="keyword">unsigned</span> <span class="keyword">long</span>, clone_flags, <span class="keyword">unsigned</span> <span class="keyword">long</span>, newsp,</span><br><span class="line">         <span class="keyword">int</span> __user *, parent_tidptr,</span><br><span class="line">         <span class="keyword">unsigned</span> <span class="keyword">long</span>, tls,</span><br><span class="line">         <span class="keyword">int</span> __user *, child_tidptr)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(CONFIG_CLONE_BACKWARDS2)</span></span><br><span class="line">SYSCALL_DEFINE5(clone, <span class="keyword">unsigned</span> <span class="keyword">long</span>, newsp, <span class="keyword">unsigned</span> <span class="keyword">long</span>, clone_flags,</span><br><span class="line">         <span class="keyword">int</span> __user *, parent_tidptr,</span><br><span class="line">         <span class="keyword">int</span> __user *, child_tidptr,</span><br><span class="line">         <span class="keyword">unsigned</span> <span class="keyword">long</span>, tls)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(CONFIG_CLONE_BACKWARDS3)</span></span><br><span class="line">SYSCALL_DEFINE6(clone, <span class="keyword">unsigned</span> <span class="keyword">long</span>, clone_flags, <span class="keyword">unsigned</span> <span class="keyword">long</span>, newsp,</span><br><span class="line">         <span class="keyword">int</span>, stack_size,</span><br><span class="line">         <span class="keyword">int</span> __user *, parent_tidptr,</span><br><span class="line">         <span class="keyword">int</span> __user *, child_tidptr,</span><br><span class="line">         <span class="keyword">unsigned</span> <span class="keyword">long</span>, tls)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">SYSCALL_DEFINE5(clone, <span class="keyword">unsigned</span> <span class="keyword">long</span>, clone_flags, <span class="keyword">unsigned</span> <span class="keyword">long</span>, newsp,</span><br><span class="line">         <span class="keyword">int</span> __user *, parent_tidptr,</span><br><span class="line">         <span class="keyword">int</span> __user *, child_tidptr,</span><br><span class="line">         <span class="keyword">unsigned</span> <span class="keyword">long</span>, tls)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _do_fork(clone_flags, newsp, <span class="number">0</span>, parent_tidptr, child_tidptr, tls);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="CLONE-FS标志在clone-中的使用"><a href="#CLONE-FS标志在clone-中的使用" class="headerlink" title="CLONE_FS标志在clone()中的使用"></a>CLONE_FS标志在clone()中的使用</h2><p><code>clone()</code>系统调用的实现在<code>kernel/fork.c</code>中，该文件中还实现了<code>fork()</code>和<code>vfork()</code>，从该文件中可以确定，<code>fork</code>、<code>vfork</code>和<code>clone</code>在内核中调用的都是<code>_do_fork()</code>函数，只是传递的参数不同。</p><p>函数<code>copy_fs()</code>对<code>CLONE_FS</code>标志进行了检查：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">copy_fs</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags, struct task_struct *tsk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> *<span class="title">fs</span> = <span class="title">current</span>-&gt;<span class="title">fs</span>;</span></span><br><span class="line"><span class="keyword">if</span> (clone_flags &amp; CLONE_FS) &#123;</span><br><span class="line"><span class="comment">/* tsk-&gt;fs is already what we want */</span></span><br><span class="line">spin_lock(&amp;fs-&gt;lock);</span><br><span class="line"><span class="keyword">if</span> (fs-&gt;in_exec) &#123;</span><br><span class="line">spin_unlock(&amp;fs-&gt;lock);</span><br><span class="line"><span class="keyword">return</span> -EAGAIN;</span><br><span class="line">&#125;</span><br><span class="line">fs-&gt;users++;</span><br><span class="line">spin_unlock(&amp;fs-&gt;lock);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">tsk-&gt;fs = copy_fs_struct(fs);</span><br><span class="line"><span class="keyword">if</span> (!tsk-&gt;fs)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到如果设置了<code>CLONE_FS</code>标志，则将当前进程的<code>fs-&gt;users</code>加1，否则调用<code>copy_fs_struct()</code>，并将子进程的<code>fs</code>结构指向其返回值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct fs_struct *<span class="title">copy_fs_struct</span><span class="params">(struct fs_struct *old)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> *<span class="title">fs</span> = <span class="title">kmem_cache_alloc</span>(<span class="title">fs_cachep</span>, <span class="title">GFP_KERNEL</span>);</span></span><br><span class="line"><span class="comment">/* We don't need to lock fs - think why ;-) */</span></span><br><span class="line"><span class="keyword">if</span> (fs) &#123;</span><br><span class="line">fs-&gt;users = <span class="number">1</span>;</span><br><span class="line">fs-&gt;in_exec = <span class="number">0</span>;</span><br><span class="line">spin_lock_init(&amp;fs-&gt;lock);</span><br><span class="line">seqcount_init(&amp;fs-&gt;seq);</span><br><span class="line">fs-&gt;umask = old-&gt;umask;</span><br><span class="line"></span><br><span class="line">spin_lock(&amp;old-&gt;lock);</span><br><span class="line">fs-&gt;root = old-&gt;root;</span><br><span class="line">path_get(&amp;fs-&gt;root);</span><br><span class="line">fs-&gt;pwd = old-&gt;pwd;</span><br><span class="line">path_get(&amp;fs-&gt;pwd);</span><br><span class="line">spin_unlock(&amp;old-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数实现非常简单，就是创建新的<code>fs_struc</code>t结构体，并把当前进程<code>fs</code>结构中的值，然后返回新的fs结构体。<br>通过这两个函数，就可以得出结论：</p><ol><li><p>通过<code>clone</code>创建子进程，未指定<code>CLONE_FS</code>时，子进程拥有自己的<code>fs</code>结构，其初始值与父进程的<code>fs</code>结构相同；双方通过<code>chroot</code>、<code>chdir</code>修改<code>fs</code>结构时，均不影响另一个进程。</p></li><li><p>指定<code>CLONE_FS</code>时，父子进程结构体中<code>fs</code>字段指向同一块内存区域，所以任何一方使用<code>chroot</code>、<code>chdir</code>等修改<code>fs</code>结构时，也会对应一个进程生效。</p></li></ol><h2 id="进程的fork"><a href="#进程的fork" class="headerlink" title="进程的fork"></a>进程的fork</h2><p>进程的<code>fork</code>，关键在于进程结构体的复制，而这个过程是在<code>dup_task_struct()</code>中实现的，从<code>fork</code>、<code>vfork</code>、<code>clone</code>开始，调用顺序为：<br><code>clone</code>/<code>fork</code>/<code>vfork</code> -&gt; <code>_do_fork</code> -&gt; <code>copy_process</code> -&gt; <code>dup_task_struct</code></p><p>该函数的实现简单来说分为如下步骤：</p><ol><li>为新的<code>task_struct</code>结构体分配内存</li><li>分配栈空间</li><li>将当前进程的<code>task_struct</code>结构体各个字段赋值给子进程的<code>task_struct</code>（使用<code>*dst = *src</code>）</li><li>将新的栈空间赋值给子进程的<code>task_struct-&gt;stack</code>。</li></ol><p>为什么子进程的<code>task_struct</code>结构体被分配了新的内存，却还能在设置了<code>CLONE_FS</code>后与父进程共享<code>task_struct-&gt;fs</code>？<br>因为<code>task_struct</code>中，<code>fs</code>的数据类型是<code>struct fs_struct *</code>，所以两个<code>fs</code>实际上指向同一块内存区域。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;争论&quot;&gt;&lt;a href=&quot;#争论&quot; class=&quot;headerlink&quot; title=&quot;争论&quot;&gt;&lt;/a&gt;争论&lt;/h2&gt;&lt;p&gt;这两天在研究沙盒的时候,跟同事争论了一下如下场景: 使用clone加上CLONE_FS创建子进程,父进程使用chroot,是否会同时对子进程
      
    
    </summary>
    
    
      <category term="kernel research" scheme="https://www.tiehichi.site/categories/kernel-research/"/>
    
    
  </entry>
  
  <entry>
    <title>字符设备访问流程</title>
    <link href="https://www.tiehichi.site/2020/03/13/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E8%AE%BF%E9%97%AE%E6%B5%81%E7%A8%8B/"/>
    <id>https://www.tiehichi.site/2020/03/13/字符设备访问流程/</id>
    <published>2020-03-13T00:00:00.000Z</published>
    <updated>2022-06-15T07:21:11.284Z</updated>
    
    <content type="html"><![CDATA[<p>《LDD3》这本书中“字符设备驱动程序”一章有这样一段话：</p><blockquote><p><em>只要<strong>cdev_add</strong>返回了，我们的设备就“活”了，它的操作就会被内核调用。</em></p></blockquote><p>这里就研究一下<code>cdev_add</code>究竟如何让设备“活”过来，以及用户空间访问字符设备节点时，内核的处理流程。</p><h2 id="从cdev-add开始分析"><a href="#从cdev-add开始分析" class="headerlink" title="从cdev_add开始分析"></a>从cdev_add开始分析</h2><p>先从<code>cdev_add()</code>入手： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cdev_add</span><span class="params">(struct cdev *p, <span class="keyword">dev_t</span> dev, <span class="keyword">unsigned</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    p-&gt;dev = dev;</span><br><span class="line">    p-&gt;count = count;</span><br><span class="line"></span><br><span class="line">    error = kobj_map(cdev_map, dev, count, <span class="literal">NULL</span>,</span><br><span class="line">    exact_match, exact_lock, p);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">    kobject_get(p-&gt;kobj.parent);  <span class="comment">/* 增加parent的引用计数 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数除了增加<code>parent</code>的引用计数外，只有一个<code>kobj_map()</code>的函数调用，所以重要的操作应该都通过该函数进行；函数定义再<code>drivers/base/map.c</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kobj_map</span><span class="params">(struct kobj_map *domain, <span class="keyword">dev_t</span> dev, <span class="keyword">unsigned</span> <span class="keyword">long</span> range, </span></span></span><br><span class="line"><span class="function"><span class="params">             struct <span class="keyword">module</span> *<span class="keyword">module</span>, <span class="keyword">kobj_probe_t</span> *probe, </span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">int</span> (*lock)(<span class="keyword">dev_t</span>, <span class="keyword">void</span> *), <span class="keyword">void</span> *data)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="cdev-map"><a href="#cdev-map" class="headerlink" title="cdev_map"></a><code>cdev_map</code></h3><p>结合<code>cdev_add()</code>调用该函数时传入的参数，发现一个重要的参数和数据结构，<code>struct kobj_map</code>类型的<code>cdev_map</code>，这是一个定义在<code>fs/char_dev.c</code>中的全局变量；先来看一下<code>struct kobj_map</code>的结构定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobj_map</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">probe</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">probe</span> *<span class="title">next</span>;</span></span><br><span class="line">        <span class="keyword">dev_t</span> dev;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> range;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">        <span class="keyword">kobj_probe_t</span> *<span class="built_in">get</span>;</span><br><span class="line">        <span class="keyword">int</span> (*lock)(<span class="keyword">dev_t</span>, <span class="keyword">void</span> *);</span><br><span class="line">        <span class="keyword">void</span> *data;</span><br><span class="line">    &#125; *probes[<span class="number">255</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> *<span class="title">lock</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>kobj_map</code>中有一个指向<code>struct probe</code>结构的数组，长度为255，而<code>struct probe</code>结构中包含了设备号、模块的<code>owner</code>等信息。</p><p><code>cdev_map</code>的初始化操作通过<code>chrdev_init()</code>进行，而该函数又直接调用了<code>kobj_map_init()</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct kobj_map *<span class="title">kobj_map_init</span><span class="params">(<span class="keyword">kobj_probe_t</span> *base_probe, struct mutex *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobj_map</span> *<span class="title">p</span> = <span class="title">kmalloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">kobj_map</span>), <span class="title">GFP_KERNEL</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">probe</span> *<span class="title">base</span> = <span class="title">kzalloc</span>(<span class="title">sizeof</span>(*<span class="title">base</span>), <span class="title">GFP_KERNEL</span>);</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((p == <span class="literal">NULL</span>) || (base == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        kfree(p);</span><br><span class="line">        kfree(base);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    base-&gt;dev = <span class="number">1</span>;</span><br><span class="line">    base-&gt;range = ~<span class="number">0</span>;</span><br><span class="line">    base-&gt;<span class="built_in">get</span> = base_probe;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">255</span>; i++)</span><br><span class="line">    p-&gt;probes[i] = base;</span><br><span class="line">    p-&gt;lock = lock;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化过程非常简单，除了分配内存，还初始化了一个<code>probe</code>结构的<code>base</code>，并将<code>cdev_map</code>中<code>probes</code>所有元素指向这个<code>base</code>，所以初始化后的<code>cdev_map</code>结构如下图：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1679957/1619074445251-04defb8d-4c45-46c5-9450-71ac97940c49.png" alt="image.png"></p><h3 id="kobj-map"><a href="#kobj-map" class="headerlink" title="kobj_map()"></a><code>kobj_map()</code></h3><p>分析完<code>cdev_map</code>的初始化，继续回到<code>kobj_map()</code>函数；前面说到<code>cdev_map</code>被作为参数传递给<code>kobj_map()</code>函数，接下来分析一下<code>kobj_map()</code>的实现，注释后的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kobj_map</span><span class="params">(struct kobj_map *domain, <span class="keyword">dev_t</span> dev, <span class="keyword">unsigned</span> <span class="keyword">long</span> range, </span></span></span><br><span class="line"><span class="function"><span class="params">             struct <span class="keyword">module</span> *<span class="keyword">module</span>, <span class="keyword">kobj_probe_t</span> *probe, </span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">int</span> (*lock)(<span class="keyword">dev_t</span>, <span class="keyword">void</span> *), <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> n = MAJOR(dev + range - <span class="number">1</span>) - MAJOR(dev) + <span class="number">1</span>;  <span class="comment">/* 设备号范围跨了多少个主设备号 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> index = MAJOR(dev);  <span class="comment">/* 该设备的起始主设备号 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">probe</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">255</span>)  <span class="comment">/* 虽然主设备号为12位，但是此处限制设备号范围最多跨255个主设备号 */</span></span><br><span class="line">    n = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">    p = kmalloc_array(n, <span class="keyword">sizeof</span>(struct probe), GFP_KERNEL);  <span class="comment">/* 每个主设备号一个probe结构 */</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 逐个初始化probe结构 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++, p++) &#123;</span><br><span class="line">        p-&gt;owner = <span class="keyword">module</span>;</span><br><span class="line">        p-&gt;<span class="built_in">get</span> = probe;</span><br><span class="line">        p-&gt;lock = lock;</span><br><span class="line">        p-&gt;dev = dev;</span><br><span class="line">        p-&gt;range = range;</span><br><span class="line">        p-&gt;data = data;  <span class="comment">/* 传入的data实际上是cdev结构的实例 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    mutex_lock(domain-&gt;lock);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, p -= n; i &lt; n; i++, p++, index++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">probe</span> **<span class="title">s</span> = &amp;<span class="title">domain</span>-&gt;<span class="title">probes</span>[<span class="title">index</span> % 255];</span></span><br><span class="line">        <span class="keyword">while</span> (*s &amp;&amp; (*s)-&gt;range &lt; range)</span><br><span class="line">        s = &amp;(*s)-&gt;next;</span><br><span class="line">        p-&gt;next = *s;</span><br><span class="line">        *s = p;</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_unlock(domain-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mutex_lock()</code>之前的部分比较好理解，就是根据传入的参数，创建并设置了<code>probe</code>结构；<code>mutex_lock()</code>和<code>mutex_unlock()</code>之间的部分需要单独分析：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>, p -= n; i &lt; n; i++, p++, index++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">probe</span> **<span class="title">s</span> = &amp;<span class="title">domain</span>-&gt;<span class="title">probes</span>[<span class="title">index</span> % 255];</span></span><br><span class="line">    <span class="keyword">while</span> (*s &amp;&amp; (*s)-&gt;range &lt; range)</span><br><span class="line">    s = &amp;(*s)-&gt;next;</span><br><span class="line">    p-&gt;next = *s;</span><br><span class="line">    *s = p;</span><br><span class="line">&#125;</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>在这个<code>for</code>循环中，<code>index</code>表示设备的主设备号，<code>p</code>表示一个<code>probe</code>的实例，这段代码主要作用就是将<code>kobj_map</code>结构的<code>probes</code>数组中的元素指向前面创建的<code>probe</code>实例。<br>循环中第一行，创建一个<code>struct probe</code>的指针指向<code>kobj_map-&gt;probes</code>中的某个位置，这个位置并不直接指向第<code>index</code>个位置，而是通过<code>index%255</code>计算得到，因为<code>index</code>是12位的主设备号，取值范围大于255，取模操作可以保证索引不会溢出。<br>接下来的<code>while</code>循环条件比较复杂，暂时先忽略<code>while</code>循环的内容；<code>for</code>循环中最后两句则是将<code>probe[index%255]</code>这个位置指向<code>p</code>，<code>p-&gt;next</code>指向原来的值，最终<code>cdev_map</code>会得到这样的结构：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1679957/1619074445517-0132300b-5a41-4f13-a76a-9f28c0c732d3.png" alt="image.png"></p><p>接着再看刚刚忽略的<code>while</code>循环；简单来说，这里的<code>while</code>循环作用就是将一条<code>probe</code>链上的<code>probe</code>实例按照<code>range</code>的值从小到大排序。</p><p>在<code>kobj_map_init()</code>中这样一条语句，将<code>base</code>的<code>range</code>设置为<code>unsigned long</code>的最大值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">base-&gt;range = ~0</span><br></pre></td></tr></table></figure><p>这里我们以<code>probes</code>数组的第0个元素为例，此时<code>probes[0]</code>结构如下图：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1679957/1619074445213-73fe6afd-e71c-458a-8633-a3f7089506d8.png" alt="image.png"></p><p>假设此时插入一个<code>range</code>为<code>1</code>的<code>probe</code>实例到<code>probes[0]</code>，此时<code>(*s)-&gt;range = MAX &gt; range = 1</code>，所以结构会变为这样：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1679957/1619074445310-69813bb6-3567-4cab-9bd9-65859a61d704.png" alt="image.png"></p><p>这种情况下，再插入一个<code>range</code>为2的<code>probe</code>实例，这时<code>(*s)-&gt;range = 1 &lt; range = 2</code>，会进入到<code>while</code>循环中，执行<code>s = &amp;(*s)-&gt;next</code>：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1679957/1619074446180-17ac8558-f6de-4b96-97bf-1e08ba6e7a27.png" alt="image.png"></p><p>执行完后，<code>s</code>将指向<code>probe_0</code>的<code>next</code>域，而<code>(*s)</code>则指向<code>base</code>，此时<code>(*s)-&gt;range = MAX &gt; range = 2</code>，离开<code>while</code>循环，最终得到如下结构：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1679957/1619074445502-c5dc42b3-87fe-4cd5-8d10-5db47158a65b.png" alt="image.png"></p><p>所以最终得到的<code>cdev_map</code>中，每条<code>probe</code>链都是按<code>range</code>从小到大排序的，并且每条链的末尾都指向初始化时创建的<code>base</code>。</p><h2 id="字符设备的访问"><a href="#字符设备的访问" class="headerlink" title="字符设备的访问"></a>字符设备的访问</h2><p>前面分析完了<code>cdev_map</code>的初始化流程，到目前为止，<code>cdev</code>结构已经添加到<code>cdev_map</code>中，但是从用户空间访问设备节点时，如何找到对应的<code>file_operations</code>函数呢？</p><h3 id="kobj-lookup"><a href="#kobj-lookup" class="headerlink" title="kobj_lookup()"></a><code>kobj_lookup()</code></h3><p><code>drivers/base/map.c</code>中还有一个重要的函数<code>kobj_lookup</code>，先来从这个函数进行分析：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct kobject *<span class="title">kobj_lookup</span><span class="params">(struct kobj_map *domain, <span class="keyword">dev_t</span> dev, <span class="keyword">int</span> *index)</span></span>;</span><br></pre></td></tr></table></figure><p>从函数定义来看，这个函数的作用是根据设备号，从<code>kobj_map</code>中找到对应的<code>probe</code>，并从中返回对应<code>driver</code>的<code>kobject</code>；看一下这个函数的实现部分：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line"><span class="keyword">for</span> (p = domain-&gt;probes[MAJOR(dev) % <span class="number">255</span>]; p; p = p-&gt;next) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *(*<span class="title">probe</span>)(<span class="title">dev_t</span>, <span class="title">int</span> *, <span class="title">void</span> *);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *data;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 设备号与当前probe不匹配，继续寻找 */</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;dev &gt; dev || p-&gt;dev + p-&gt;range - <span class="number">1</span> &lt; dev)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;range - <span class="number">1</span> &gt;= best) <span class="comment">/* 达到链表尾，退出循环 */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (!try_module_get(p-&gt;owner))</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    owner = p-&gt;owner;</span><br><span class="line">    data = p-&gt;data;</span><br><span class="line">    probe = p-&gt;<span class="built_in">get</span>;</span><br><span class="line">    best = p-&gt;range - <span class="number">1</span>;</span><br><span class="line">    *index = dev - p-&gt;dev;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;lock &amp;&amp; p-&gt;lock(dev, data) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        module_put(owner);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_unlock(domain-&gt;lock);</span><br><span class="line">    kobj = probe(dev, index, data);  <span class="comment">/* 使用kobj_map()时注册的probe函数获取kobj */</span></span><br><span class="line">    <span class="comment">/* Currently -&gt;owner protects _only_ -&gt;probe() itself. */</span></span><br><span class="line">    module_put(owner);</span><br><span class="line">    <span class="keyword">if</span> (kobj)</span><br><span class="line">    <span class="keyword">return</span> kobj;</span><br><span class="line">    <span class="keyword">goto</span> retry;</span><br><span class="line">&#125;</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p><code>kobj_lookup()</code>根据主设备号从<code>kobj_map-&gt;probes</code>中找到对应的链表进行遍历，并通过计算<code>probe</code>中设备号的范围来匹配正确的<code>probe</code>结构；而<code>kobj_map()</code>时注册的<code>probe()</code>函数则用来从<code>data</code>中获取<code>kobject</code>；对应到<code>cdev_map</code>上，<code>data</code>指向的是<code>cdev</code>结构，而<code>probe()</code>函数指针指向<code>exact_match()</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct kobject *<span class="title">exact_match</span><span class="params">(<span class="keyword">dev_t</span> dev, <span class="keyword">int</span> *part, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> *<span class="title">p</span> = <span class="title">data</span>;</span></span><br><span class="line">    <span class="keyword">return</span> &amp;p-&gt;kobj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>exact_match()</code>的作用就是从<code>data</code>中获取<code>kobject</code>。</p><p>既然获取到了<code>kobject</code>，那就可以使用<code>container_of()</code>获取对应的<code>cdev</code>结构，所以<code>char_dev.c</code>中一定有对应的函数会调用<code>kobj_lookup()</code>。</p><h3 id="chrdev-open"><a href="#chrdev-open" class="headerlink" title="chrdev_open()"></a><code>chrdev_open()</code></h3><p>经过搜索，在<code>char_dev.c</code>中找到了函数<code>chrdev_open()</code>调用<code>kobj_lookup()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Called every time a character special file is opened</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">chrdev_open</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br></pre></td></tr></table></figure><p>从注释来看，这个函数在用户空间每次访问字符设备时调用；来看一下哪里会注册这个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">def_chr_fops</span> = &#123;</span></span><br><span class="line">    .<span class="built_in">open</span> = chrdev_open,</span><br><span class="line">    .llseek = noop_llseek,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>chrdev_open()</code>函数注册在<code>def_chr_fops</code>结构体中，继续搜索一下这个结构体会被赋值给谁：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_special_inode</span><span class="params">(struct inode *inode, <span class="keyword">umode_t</span> mode, <span class="keyword">dev_t</span> rdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    inode-&gt;i_mode = mode;</span><br><span class="line">    <span class="keyword">if</span> (S_ISCHR(mode)) &#123;</span><br><span class="line">        inode-&gt;i_fop = &amp;def_chr_fops;</span><br><span class="line">        inode-&gt;i_rdev = rdev;</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>fs/inode.c</code>中的函数<code>init_special_inode()</code>里，<code>def_chr_fops</code>被赋值给了字符设备的<code>inode</code>结构体，这样在访问字符设备时，就会通过其<code>inode</code>访问到<code>def_chr_fops-&gt;chrdev_open()</code>，但是目前为止还没有调用我们自己为设备注册的<code>file_operations</code>，回过头来继续看<code>chrdev_open()</code>的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">chrdev_open</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">fops</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> *<span class="title">new</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    spin_lock(&amp;cdev_lock);</span><br><span class="line">    p = inode-&gt;i_cdev;</span><br><span class="line">    <span class="keyword">if</span> (!p) &#123;</span><br><span class="line">        ……</span><br><span class="line">        kobj = kobj_lookup(cdev_map, inode-&gt;i_rdev, &amp;idx);</span><br><span class="line">        ……</span><br><span class="line">        <span class="keyword">new</span> = container_of(kobj, struct cdev, kobj);</span><br><span class="line">        spin_lock(&amp;cdev_lock);</span><br><span class="line">        ……</span><br><span class="line">        <span class="keyword">if</span> (!p) &#123;</span><br><span class="line">            inode-&gt;i_cdev = p = <span class="keyword">new</span>;</span><br><span class="line">            list_add(&amp;inode-&gt;i_devices, &amp;p-&gt;<span class="built_in">list</span>);</span><br><span class="line">            <span class="keyword">new</span> = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!cdev_get(p))</span><br><span class="line">            ret = -ENXIO;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!cdev_get(p))</span><br><span class="line">            ret = -ENXIO;</span><br><span class="line">        ……</span><br><span class="line">        fops = fops_get(p-&gt;ops);</span><br><span class="line">        ……</span><br><span class="line">        replace_fops(filp, fops);</span><br><span class="line">        <span class="keyword">if</span> (filp-&gt;f_op-&gt;<span class="built_in">open</span>) &#123;</span><br><span class="line">        ret = filp-&gt;f_op-&gt;<span class="built_in">open</span>(inode, filp);</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数实现经过精简后，非常容易看出实现过程：第一次访问时，<code>inode-&gt;i_cdev</code>为空，使用<code>kobj_lookup()</code>结合<code>container_of()</code>获取<code>cdev</code>，并将<code>cdev</code>赋值给<code>inode-&gt;i_cdev</code>，然后使用<code>fops_get()</code>获取我们设置的<code>fops</code>，再使用<code>replace_fops()</code>将我们的<code>fops</code>设置到<code>filp</code>文件指针上，然后调用<code>filp-&gt;f_op-&gt;open()</code>，至此成功访问到我们自己的<code>open</code>函数；当再次访问该字符设备时，<code>inode-&gt;i_cdev</code>已经被赋值，无需再次通过<code>kobj_lookup()</code>查找对应的<code>cdev</code>结构。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;《LDD3》这本书中“字符设备驱动程序”一章有这样一段话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;只要&lt;strong&gt;cdev_add&lt;/strong&gt;返回了，我们的设备就“活”了，它的操作就会被内核调用。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里
      
    
    </summary>
    
    
      <category term="kernel research" scheme="https://www.tiehichi.site/categories/kernel-research/"/>
    
    
  </entry>
  
  <entry>
    <title>kobject分析</title>
    <link href="https://www.tiehichi.site/2020/03/09/kobject%E5%88%86%E6%9E%90/"/>
    <id>https://www.tiehichi.site/2020/03/09/kobject分析/</id>
    <published>2020-03-09T00:00:00.000Z</published>
    <updated>2022-06-15T07:21:11.284Z</updated>
    
    <content type="html"><![CDATA[<p>根据文章<a href="https://lwn.net/Articles/51437/" target="_blank" rel="noopener">The zen of kobjects</a>所述，kobject设计之初是为了管理内核对象的引用计数，但在内核的发展过程中，添加了更多的功能；对于较新版本的内核，我理解的kobject的功能主要是：</p><ul><li>管理内核对象引用计数</li><li>为内核中的对象创建层级</li><li>在sysfs中为对象创建文件夹</li></ul><p>每一个kobject在文件系统/sys路径下都有对应的文件夹；既然可以以目录的形式表示kobject，那么kobject一定是按照树形结构来划分层级的。</p><h2 id="kobject结构"><a href="#kobject结构" class="headerlink" title="kobject结构"></a>kobject结构</h2><p>先看部分精简后的kobject的数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>        *name;  <span class="comment">/* 在sysfs中创建文件夹时，文件夹的名称 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">entry</span>;</span>  <span class="comment">/* 链表结构，可以将kobject组织成链表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>        *<span class="title">parent</span>;</span>  <span class="comment">/* 指向父kobject的指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span>        *<span class="title">kset</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span>    *<span class="title">ktype</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kernfs_node</span>    *<span class="title">sd</span>;</span> <span class="comment">/* sysfs directory entry */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kref</span>        <span class="title">kref</span>;</span>  <span class="comment">/* 该kobject实例的引用 */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 位域，表示该对象的各种状态 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_initialized:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_in_sysfs:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_add_uevent_sent:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_remove_uevent_sent:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> uevent_suppress:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中kset和ktype是比较重要的两个内容：</p><ul><li>kset是一个kobject组，其本身也是一个kobject</li><li>ktype表示当前kobject的类型，实际上作用是表示当对象引用计数为0时，如何释放对象</li></ul><h2 id="初始化kobject"><a href="#初始化kobject" class="headerlink" title="初始化kobject"></a>初始化kobject</h2><p>kobject的初始化函数是kobject_init()，而kobject_init()中又调用了kobject_init_internal()函数，两个函数的实现都非常简单，精简掉错误处理部分后代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kobject_init_internal</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!kobj)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    kref_init(&amp;kobj-&gt;kref);</span><br><span class="line">    INIT_LIST_HEAD(&amp;kobj-&gt;entry);</span><br><span class="line">    kobj-&gt;state_in_sysfs = <span class="number">0</span>;  <span class="comment">/* 此时还未在sysfs中创建文件夹 */</span></span><br><span class="line">    kobj-&gt;state_add_uevent_sent = <span class="number">0</span>;</span><br><span class="line">    kobj-&gt;state_remove_uevent_sent = <span class="number">0</span>;</span><br><span class="line">    kobj-&gt;state_initialized = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kobject_init</span><span class="params">(struct kobject *kobj, struct kobj_type *ktype)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    kobject_init_internal(kobj);</span><br><span class="line">    kobj-&gt;ktype = ktype;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上初始化操作就只为kobject结构中ktype及各个字段进行赋值，并且对kref字段使用kref_init()初始化引用计数，继续跟一下kref的结构和kref_init()的实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kref</span> &#123;</span></span><br><span class="line"><span class="keyword">refcount_t</span> refcount;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">kref_init</span><span class="params">(struct kref *kref)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">refcount_set(&amp;kref-&gt;refcount, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kref_init()将引用初始化为1，所以kobject初始化之后，其引用计数为1。</p><p>需要注意kobject_init()函数并未对kobject指针分配内存，所以调用kobject_init()之前，需要手动为其分配内存；但是也有另一个函数，包含了分配内存和初始化的操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct kobject *<span class="title">kobject_create</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">kobj</span>;</span></span><br><span class="line"></span><br><span class="line">    kobj = kzalloc(<span class="keyword">sizeof</span>(*kobj), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!kobj)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    kobject_init(kobj, &amp;dynamic_kobj_ktype);</span><br><span class="line">    <span class="keyword">return</span> kobj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kobject_create()函数将kobject的ktype设置为了dynamic_kobject_ktype，这是一个全局的kobj_type，声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> <span class="title">dynamic_kobj_ktype</span> = &#123;</span></span><br><span class="line">    .<span class="built_in">release</span>    = dynamic_kobj_release,</span><br><span class="line">    .sysfs_ops    = &amp;kobj_sysfs_ops,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>前面提到ktype的作用就是指示当kobject的引用归零时，如何处理kobject；而这里的kobj_type-&gt;release就是对应的处理函数，这个dynamic_kobj_release实现如下：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dynamic_kobj_release</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pr_debug(<span class="string">"kobject: (%p): %s\n"</span>, kobj, __func__);</span><br><span class="line">kfree(kobj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于是使用kobject_create()默认设置的ktype，所以release时也只进行了kfree操作。</p><h2 id="增减引用计数"><a href="#增减引用计数" class="headerlink" title="增减引用计数"></a>增减引用计数</h2><p>kobject对象的引用存储在其kref字段中，使用kobject_get()和kobject_put()函数可以增加和减少kobject引用计数。</p><h3 id="增加引用"><a href="#增加引用" class="headerlink" title="增加引用"></a>增加引用</h3><p>kobject_get()实现比较简单：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct kobject *<span class="title">kobject_get</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (kobj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!kobj-&gt;state_initialized)</span><br><span class="line">            WARN(<span class="number">1</span>, KERN_WARNING</span><br><span class="line">            <span class="string">"kobject: '%s' (%p): is not initialized, yet kobject_get() is being called.\n"</span>, kobject_name(kobj), kobj);</span><br><span class="line">kref_get(&amp;kobj-&gt;kref);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> kobj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查kobject是否为空，然后调用了kref_get()：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">kref_get</span><span class="params">(struct kref *kref)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">refcount_inc(&amp;kref-&gt;refcount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据函数名可以确认这就是将kref-&gt;refcount记录的引用计数加1。</p><h3 id="减少引用"><a href="#减少引用" class="headerlink" title="减少引用"></a>减少引用</h3><p>减少引用除了要减少kref-&gt;refcount，还需要每次检查其值是否为0，如果引用被减少到0，则应该调<code>ktype-&gt;release</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kobject_put</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (kobj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!kobj-&gt;state_initialized)</span><br><span class="line">            WARN(<span class="number">1</span>, KERN_WARNING</span><br><span class="line">            <span class="string">"kobject: '%s' (%p): is not initialized, yet kobject_put() is being called.\n"</span>,</span><br><span class="line">               kobject_name(kobj), kobj);</span><br><span class="line">        kref_put(&amp;kobj-&gt;kref, kobject_release);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">kref_put</span><span class="params">(struct kref *kref, <span class="keyword">void</span> (*<span class="built_in">release</span>)(struct kref *kref))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (refcount_dec_and_test(&amp;kref-&gt;refcount)) &#123;</span><br><span class="line">    <span class="built_in">release</span>(kref);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kobject_put()在调用kref_put()的时候，将kobject_release()传递给了kref_put()，当引用减少为0时，会调用此函数；改函数精简后源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kobject_release</span><span class="params">(struct kref *kref)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">kobj</span> = <span class="title">container_of</span>(<span class="title">kref</span>, <span class="title">struct</span> <span class="title">kobject</span>, <span class="title">kref</span>);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_KOBJECT_RELEASE</span></span><br><span class="line">……</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">kobject_cleanup(kobj);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过kref获取到对应的kobject，然后调用kobject_cleanup():</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kobject_cleanup</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> *<span class="title">t</span> = <span class="title">get_ktype</span>(<span class="title">kobj</span>);</span></span><br><span class="line">……</span><br><span class="line"><span class="keyword">if</span> (t &amp;&amp; t-&gt;<span class="built_in">release</span>) &#123;</span><br><span class="line">pr_debug(<span class="string">"kobject: '%s' (%p): calling ktype release\n"</span>,</span><br><span class="line"> kobject_name(kobj), kobj);</span><br><span class="line">t-&gt;<span class="built_in">release</span>(kobj);</span><br><span class="line">&#125;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在kobject_cleanup()中，调用了ktype-&gt;release，对资源进行了释放。</p><h2 id="kset结构"><a href="#kset结构" class="headerlink" title="kset结构"></a>kset结构</h2><p>kset本身也是一个kobject，其结构比较简单：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kset</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> list_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kset_uevent_ops</span> *<span class="title">uevent_ops</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面说到kset表示一个kobject组，从结构来看，kset也包含kobject结构，所以kset在sysfs中也有对应的文件夹；除了kset_uevent_ops以外，kset结构本身没有其他可以存储数据的部分，所以我认为kset的作用就是为其组内的kobject提供统一的uevent事件。</p><h2 id="kset组织kobject"><a href="#kset组织kobject" class="headerlink" title="kset组织kobject"></a>kset组织kobject</h2><p>kobject结构本身包含一个指向kset的指针，但是kset却没有指向子kobject的指针，所以如果需要通过kset找到组内的kobject，只能通过kset-&gt;list遍历。</p><p>先来看一下kobject_add_internal()的部分：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kobject_add_internal</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ……</span><br><span class="line">    <span class="comment">/* join kset if set, use it as parent if we do not already have one */</span></span><br><span class="line">    <span class="keyword">if</span> (kobj-&gt;kset) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!parent)  <span class="comment">/* 如果未设置parent，会把kset作为该kobject的parent */</span></span><br><span class="line">        parent = kobject_get(&amp;kobj-&gt;kset-&gt;kobj);  <span class="comment">/* 增加parent的引用计数 */</span></span><br><span class="line">        kobj_kset_join(kobj);</span><br><span class="line">        kobj-&gt;parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数由kobject_add()调用，除了设置kobject的parent之外，还调用了kobject_kset_join()：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* add the kobject to its kset's list */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kobj_kset_join</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!kobj-&gt;kset)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    kset_get(kobj-&gt;kset);</span><br><span class="line">    spin_lock(&amp;kobj-&gt;kset-&gt;list_lock);</span><br><span class="line">    list_add_tail(&amp;kobj-&gt;entry, &amp;kobj-&gt;kset-&gt;<span class="built_in">list</span>);</span><br><span class="line">    spin_unlock(&amp;kobj-&gt;kset-&gt;list_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数将kobject添加到了kset指针域的尾部，这样就可以通过kset找到组内的所有kobject，kset与组内的kobject组成了下图所示的结构：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1679957/1619073283151-8ae6f326-5004-4b30-ba99-1f9215174d29.png" alt=""></p><p>这里需要注意kobject_init()和kobject_add()都没有设置kobject-&gt;kset的值，需要手动设置kobject所属的kset。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;根据文章&lt;a href=&quot;https://lwn.net/Articles/51437/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;The zen of kobjects&lt;/a&gt;所述，kobject设计之初是为了管理内核对象的引用计数，但在内核的发展过
      
    
    </summary>
    
    
      <category term="kernel research" scheme="https://www.tiehichi.site/categories/kernel-research/"/>
    
    
  </entry>
  
  <entry>
    <title>愿新年，胜旧年</title>
    <link href="https://www.tiehichi.site/2020/01/22/%E6%84%BF%E6%96%B0%E5%B9%B4%EF%BC%8C%E8%83%9C%E6%97%A7%E5%B9%B4/"/>
    <id>https://www.tiehichi.site/2020/01/22/愿新年，胜旧年/</id>
    <published>2020-01-22T00:00:00.000Z</published>
    <updated>2022-06-15T07:21:11.284Z</updated>
    
    <content type="html"><![CDATA[<h2 id="愿新年，胜旧年"><a href="#愿新年，胜旧年" class="headerlink" title="愿新年，胜旧年"></a>愿新年，胜旧年</h2><h2 id="加油"><a href="#加油" class="headerlink" title="加油"></a>加油</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;愿新年，胜旧年&quot;&gt;&lt;a href=&quot;#愿新年，胜旧年&quot; class=&quot;headerlink&quot; title=&quot;愿新年，胜旧年&quot;&gt;&lt;/a&gt;愿新年，胜旧年&lt;/h2&gt;&lt;h2 id=&quot;加油&quot;&gt;&lt;a href=&quot;#加油&quot; class=&quot;headerlink&quot; title=&quot;加
      
    
    </summary>
    
    
      <category term="生活" scheme="https://www.tiehichi.site/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>deb文件格式</title>
    <link href="https://www.tiehichi.site/2020/01/22/deb%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"/>
    <id>https://www.tiehichi.site/2020/01/22/deb文件格式/</id>
    <published>2020-01-22T00:00:00.000Z</published>
    <updated>2022-06-15T07:21:11.284Z</updated>
    
    <content type="html"><![CDATA[<p>deb软件包实际上是<code>archive file</code>，可以使用<code>ar</code>命令进行打包和解包</p><h2 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h2><p>以下图片来自<a href="https://en.wikipedia.org/wiki/Deb_(file_format)" target="_blank" rel="noopener">维基百科</a></p><p><img src="https://i.loli.net/2020/01/22/216GSpUtJ3cwbLZ.png" alt="Frhed_hex_editor_displaying_deb_package.png"></p><p><img src="https://i.loli.net/2020/01/22/XW89UdHnClJfoT1.png" alt="Deb_File_Structure.png"></p><h2 id="解压deb包"><a href="#解压deb包" class="headerlink" title="解压deb包"></a>解压deb包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看deb包含的文件</span></span><br><span class="line">~ $ ar tv google-chrome-stable_current_amd64.deb </span><br><span class="line">rw-r--r-- 0/0      4 Jan 16 09:44 2020 debian-binary</span><br><span class="line">rw-r--r-- 0/0  12131 Jan 16 09:44 2020 control.tar.gz</span><br><span class="line">rw-r--r-- 0/0 62181000 Jan 16 09:46 2020 data.tar.xz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压deb包</span></span><br><span class="line">~ $ ar x google-chrome-stable_current_amd64.deb</span><br></pre></td></tr></table></figure><p>使用<code>ar</code>命令解压后得到三个文件，分别是<code>debian-binary</code>, <code>control</code>压缩包, <code>data</code>压缩包。</p><ul><li><p><code>debian-binary</code></p><p>纯文本文件，只有一行内容，记录了当前deb格式的版本号：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~ $ cat debian-binary </span><br><span class="line">2.0</span><br></pre></td></tr></table></figure></li><li><p><code>control</code>压缩包</p><p><code>control</code>包使用<code>tar</code>打包，支持<code>gzip</code>和<code>xz</code>压缩方式，其中包含了deb软件包的控制文件</p></li><li><p><code>data</code>压缩包</p><p><code>data</code>压缩包中包含了实际要安装的文件，同样使用<code>tar</code>打包，支持<code>gzip</code>、<code>bzip2</code>、<code>lzma</code>和<code>xz</code>压缩</p></li></ul><h2 id="dpkg-deb命令"><a href="#dpkg-deb命令" class="headerlink" title="dpkg-deb命令"></a><code>dpkg-deb</code>命令</h2><p><code>dpkg-deb</code>命令是<code>dpkg</code>工具包中用来操作deb软件包的命令，可以解压、查看和重新打包deb文件。</p><h3 id="查看deb包信息"><a href="#查看deb包信息" class="headerlink" title="查看deb包信息"></a>查看deb包信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dpkg-deb -c &lt;deb package&gt;    <span class="comment"># 列出deb包中所有待安装文件</span></span><br><span class="line">dpkg-deb -I &lt;deb package&gt;    <span class="comment"># 显示deb包的详细信息</span></span><br><span class="line">dpkg-deb -f &lt;deb package&gt;    <span class="comment"># 显示deb包中control文件的各个字段</span></span><br><span class="line">dpkg-deb -W &lt;deb package&gt;    <span class="comment"># 显示软件包信息和版本</span></span><br></pre></td></tr></table></figure><h3 id="解压deb软件包"><a href="#解压deb软件包" class="headerlink" title="解压deb软件包"></a>解压deb软件包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dpkg-deb -e &lt;deb package&gt; &lt;directory&gt;    <span class="comment"># 解压deb包的控制信息</span></span><br><span class="line">dpkg-deb -x &lt;deb package&gt; &lt;directory&gt;    <span class="comment"># 解压deb包中的待安装文件</span></span><br></pre></td></tr></table></figure><p>与使用<code>ar</code>命令解压不同，<code>ar</code>命令会解压出<code>control</code>和<code>data</code>两个压缩包，而<code>dpkg-deb</code>会继续对压缩包进行解压，输出其中的文件。</p><h3 id="打包deb软件包"><a href="#打包deb软件包" class="headerlink" title="打包deb软件包"></a>打包deb软件包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg-deb -b &lt;directory&gt; &lt;deb name&gt;    <span class="comment"># 构建deb软件包</span></span><br></pre></td></tr></table></figure><p>该命令中，待构建文件夹的结构为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;top directory&gt;/</span><br><span class="line">|---- DEBIAN/</span><br><span class="line">||---- control</span><br><span class="line">||---- md5sums</span><br><span class="line">|---- &lt;path to install&gt;/</span><br><span class="line">|---- &lt;file&gt;</span><br></pre></td></tr></table></figure><p>其中<code>DEBIAN</code>文件夹内必须包含<code>control</code>文件，其他控制文件及脚本按需添加，文件安装的路径与<code>top dir</code>中其他文件的路径一致，即<code>top dir</code>作为<code>fakeroot</code>。</p><h2 id="control压缩包"><a href="#control压缩包" class="headerlink" title="control压缩包"></a><code>control</code>压缩包</h2><p><code>control</code>包中包含以下文件：</p><ul><li><code>control</code></li><li><code>md5sums</code></li><li><code>conffiles</code></li><li><code>perins</code>, <code>postins</code>, <code>prerm</code>, <code>postrm</code></li><li><code>config</code></li><li><code>shlibs</code></li></ul><h3 id="control"><a href="#control" class="headerlink" title="control"></a><code>control</code></h3><p><code>control</code>文件包含了软件包的信息，例如<code>Chrome</code>安装包的<code>control</code>文件内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Package: google-chrome-stable</span><br><span class="line">Version: 79.0.3945.130-1</span><br><span class="line">Architecture: amd64</span><br><span class="line">Maintainer: Chrome Linux Team &lt;chromium-dev@chromium.org&gt;</span><br><span class="line">Installed-Size: 215627</span><br><span class="line">Pre-Depends: dpkg (&gt;= 1.14.0)</span><br><span class="line">Depends: ca-certificates, fonts-liberation, libappindicator3-1, libasound2 (&gt;= 1.0.16), libatk-bridge2.0-0 (&gt;= 2.5.3), libatk1.0-0 (&gt;= 2.2.0), libatspi2.0-0 (&gt;= 2.9.90), libc6 (&gt;= 2.16), libcairo2 (&gt;= 1.6.0), libcups2 (&gt;= 1.4.0), libdbus-1-3 (&gt;= 1.5.12), libexpat1 (&gt;= 2.0.1), libgcc1 (&gt;= 1:3.0), libgdk-pixbuf2.0-0 (&gt;= 2.22.0), libglib2.0-0 (&gt;= 2.31.8), libgtk-3-0 (&gt;= 3.9.10), libnspr4 (&gt;= 2:4.9-2~), libnss3 (&gt;= 2:3.22), libpango-1.0-0 (&gt;= 1.14.0), libpangocairo-1.0-0 (&gt;= 1.14.0), libx11-6 (&gt;= 2:1.4.99.1), libx11-xcb1, libxcb1 (&gt;= 1.6), libxcomposite1 (&gt;= 1:0.3-1), libxcursor1 (&gt;&gt; 1.1.2), libxdamage1 (&gt;= 1:1.1), libxext6, libxfixes3 (&gt;= 1:5.0), libxi6 (&gt;= 2:1.2.99.4), libxrandr2 (&gt;= 2:1.2.99.3), libxrender1, libxss1, libxtst6, wget, xdg-utils (&gt;= 1.0.2)</span><br><span class="line">Recommends: libu2f-udev</span><br><span class="line">Provides: www-browser</span><br><span class="line">Section: web</span><br><span class="line">Priority: optional</span><br><span class="line">Description: The web browser from Google</span><br><span class="line"> Google Chrome is a browser that combines a minimal design with sophisticated technology to make the web faster, safer, and easier.</span><br></pre></td></tr></table></figure><p>关于control文件中各个字段的意义及格式可以参考<a href="https://manpages.debian.org/unstable/dpkg-dev/deb-control.5.en.html" target="_blank" rel="noopener">Debian官方文档</a>。</p><h3 id="md5sums"><a href="#md5sums" class="headerlink" title="md5sums"></a><code>md5sums</code></h3><p>该文件中记录了软件包中所有待安装文件的MD5校验和，格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1d15dcfb6bb23751f76a2b7b844d3c57  sbin/parted</span><br><span class="line">4eb9cc2e192f1b997cf13ff0b921af74  usr/share/man/man8/parted.8.gz</span><br><span class="line">2f356768104a09092e26a6abb012c95e  usr/share/doc/parted/README.Debian</span><br><span class="line">a6259bd193f8f150c171c88df2158e3e  usr/share/doc/parted/copyright</span><br><span class="line">7f8078127a689d647586420184fc3953  usr/share/doc/parted/changelog.Debian.gz</span><br><span class="line">98f217a3bf8a7407d66fd6ac8c5589b7  usr/share/doc/parted/changelog.gz</span><br></pre></td></tr></table></figure><h3 id="conffiles"><a href="#conffiles" class="headerlink" title="conffiles"></a><code>conffiles</code></h3><p>该文件内容表示，软件包的待安装文件中，哪些是配置文件，文件内容格式如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/cups/snmp.conf</span><br><span class="line">/etc/cups/cupsd.conf</span><br></pre></td></tr></table></figure><p>执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg --status &lt;package&gt;</span><br></pre></td></tr></table></figure><p>在输出结果中的<code>conffiles</code>字段可以看到这些内容，例如<code>cups</code>包的输出中包含：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Conffiles:</span><br><span class="line"> /etc/cups/snmp.conf 47b8f1c3fecdc44e3d1fdee4b9eeb3f5</span><br></pre></td></tr></table></figure><h3 id="perins-postins-prerm-postrm"><a href="#perins-postins-prerm-postrm" class="headerlink" title="perins, postins, prerm, postrm"></a><code>perins</code>, <code>postins</code>, <code>prerm</code>, <code>postrm</code></h3><p>这四个文件是在包安装和删除前后触发执行的脚本，其中<code>perins</code>和<code>postins</code>分别在安装前后执行，<code>prerm</code>和<code>postrm</code>在卸载前后执行</p><h3 id="config"><a href="#config" class="headerlink" title="config"></a><code>config</code></h3><p><code>config</code>是一个可选的，支持<code>debconf</code>机制的脚本，参考<a href="http://www.fifi.org/doc/debconf-doc/tutorial.html#AEN113" target="_blank" rel="noopener">debconf教程</a>。</p><h3 id="shlibs"><a href="#shlibs" class="headerlink" title="shlibs"></a><code>shlibs</code></h3><p>该文件列出软件包依赖的共享库，参考<a href="https://manpages.debian.org/unstable/dpkg-dev/dpkg-shlibdeps.1.en.html#Shlibs_files" target="_blank" rel="noopener">Debian官方文档</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;deb软件包实际上是&lt;code&gt;archive file&lt;/code&gt;，可以使用&lt;code&gt;ar&lt;/code&gt;命令进行打包和解包&lt;/p&gt;
&lt;h2 id=&quot;文件格式&quot;&gt;&lt;a href=&quot;#文件格式&quot; class=&quot;headerlink&quot; title=&quot;文件格式&quot;&gt;&lt;/a&gt;文件
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>cgroup的简单使用</title>
    <link href="https://www.tiehichi.site/2019/12/18/CGroup%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.tiehichi.site/2019/12/18/CGroup简单使用/</id>
    <published>2019-12-18T00:00:00.000Z</published>
    <updated>2022-06-15T07:21:11.280Z</updated>
    
    <content type="html"><![CDATA[<p><code>cgroup（control group）</code>是由<code>linux</code>内核提供的功能，可以对一组进程使用的资源进行监控、管理和限制。</p><h2 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h2><p><code>cgroup</code>的工作机制有四部分组成：任务（<code>task</code>），控制组（<code>cgroup</code>），子系统（<code>subsystem</code>）和层级（<code>hierarchy</code>）。</p><ul><li><p>任务（<code>task</code>）</p><p><code>cgroup</code>中的任务实际上就是指系统中的进程。</p></li><li><p>控制组（<code>cgroup</code>）</p><p>控制组是层级（<code>hierarchy</code>）树中的某一个节点，其中包含了一组任务和某个<code>subsystem</code>的相关控制项。</p></li><li><p>子系统（<code>subsystem</code>）</p><p>一个子系统实际上就是一个提供了对某种资源控制功能的内核模块。<code>cgroup</code>支持多种<code>subsystem</code>，每一种<code>subsystem</code>可以针对某一种资源进行控制管理，如<code>memory</code>、<code>block IO</code>等等。</p></li><li><p>层级（<code>hierarchy</code>）</p><p><code>hierarchy</code>是以目录树的形式组织起来的<code>control groups</code>，一个层级可以与0个或者多个<code>subsystem</code>关联，关联后即可对<code>hierarchy</code>中某一层级的<code>cgroup</code>通过<code>subsystem</code>进行资源控制。</p></li></ul><p><img src="https://i.loli.net/2019/12/18/5aIrkzDoOd3BLiT.png" alt="cgroup.png"></p><p>如上图所示，<code>cgroup</code>中各个组成部分之间的关系：</p><ul><li>一个子系统最多只能被添加到一个层级中</li><li>一个层级可以关联多个子系统，也可以不关联子系统</li><li>一个任务可以被添加到多个控制组中，但控制组所属的层级必须不同，即任务在层级中只能属于一个<code>cgroup</code></li><li>系统中进程创建子进程时，子进程会被自动添加到父进程所在的<code>cgroup</code>中。</li><li>创建新的<code>hierarchy</code>时，会将当前系统中所有进程添加到其<code>root cgroup</code>中。</li></ul><h2 id="内核编译选项"><a href="#内核编译选项" class="headerlink" title="内核编译选项"></a>内核编译选项</h2><p>前面提到<code>subsystem</code>是内核模块，开启这些内核模块需要在编译内核时打开对应的选项</p><table><thead><tr><th align="left">子系统</th><th>内核选项</th><th>依赖项</th><th>内核版本</th></tr></thead><tbody><tr><td align="left"><code>cpu</code></td><td><code>CONFIG_CGROUP_SCHED</code></td><td></td><td><code>2.6.24</code></td></tr><tr><td align="left"><code>cpuacct</code></td><td><code>CONFIG_CGROUP_CPUACCT</code></td><td></td><td><code>2.6.24</code></td></tr><tr><td align="left"><code>cpuset</code></td><td><code>CONFIG_CPUSETS</code></td><td></td><td><code>2.6.24</code></td></tr><tr><td align="left"><code>memory</code></td><td><code>CONFIG_MEMCG</code></td><td><code>RESOURCE_COUNTERS</code></td><td><code>2.6.25</code></td></tr><tr><td align="left"><code>devices</code></td><td><code>CONFIG_CGROUP_DEVICE</code></td><td></td><td><code>2.6.26</code></td></tr><tr><td align="left"><code>freezer</code></td><td><code>CONFIG_CGROUP_FREEZER</code></td><td></td><td><code>2.6.28</code></td></tr><tr><td align="left"><code>net_cls</code></td><td><code>CONFIG_CGROUP_NET_CLASSID</code></td><td></td><td><code>2.6.29</code></td></tr><tr><td align="left"><code>blkio</code></td><td><code>CONFIG_BLK_CGROUP</code></td><td></td><td><code>2.6.33</code></td></tr><tr><td align="left"><code>perf_event</code></td><td><code>CONFIG_CGROUP_PERF</code></td><td></td><td><code>2.6.39</code></td></tr><tr><td align="left"><code>net_prio</code></td><td><code>CONFIG_CGROUP_NET_PRIO</code></td><td></td><td><code>3.3</code></td></tr><tr><td align="left"><code>hugetlb</code></td><td><code>CONFIG_CGROUP_HUGETLB</code></td><td><code>RESOURCE_COUNTERS</code>和<code>HUGETLB_PAGE</code></td><td><code>3.5</code></td></tr><tr><td align="left"><code>pids</code></td><td><code>CONFIG_CGROUP_PIDS</code></td><td></td><td><code>4.3</code></td></tr><tr><td align="left"><code>rdma</code></td><td><code>CONFIG_CGROUP_RDMA</code></td><td></td><td><code>4.11</code></td></tr></tbody></table><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="查看子系统与层级关联情况"><a href="#查看子系统与层级关联情况" class="headerlink" title="查看子系统与层级关联情况"></a>查看子系统与层级关联情况</h3><p>使用<code>cat /proc/cgroups</code>可以查看当前系统中可用的<code>cgroup</code>子系统与层级之间的关系；以<code>Ubuntu 18.04</code>为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">~$ cat /proc/cgroups </span><br><span class="line"><span class="comment">#subsys_namehierarchynum_cgroupsenabled</span></span><br><span class="line">cpuset631</span><br><span class="line">cpu3921</span><br><span class="line">cpuacct3921</span><br><span class="line">blkio7921</span><br><span class="line">memory42071</span><br><span class="line">devices5921</span><br><span class="line">freezer231</span><br><span class="line">net_cls931</span><br><span class="line">perf_event1131</span><br><span class="line">net_prio931</span><br><span class="line">hugetlb1031</span><br><span class="line">pids8971</span><br><span class="line">rdma1211</span><br></pre></td></tr></table></figure><p>结果从左到右依次为：子系统名，与子系统关联的层级ID，该层级中<code>cgroup</code>的数量，子系统是否启用。</p><p>当系统中没有挂载任何层级时，结果如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">~$ cat /proc/cgroups</span><br><span class="line"><span class="comment">#subsys_name    hierarchy   num_cgroups enabled</span></span><br><span class="line">cpuset  01       1</span><br><span class="line">cpu     0       1       1</span><br><span class="line">cpuacct 0       1       1</span><br><span class="line">blkio   0       1       1</span><br><span class="line">memory  0       1       1</span><br><span class="line">devices 0       1       1</span><br><span class="line">freezer 0       1       1</span><br><span class="line">net_cls 0       1       1</span><br><span class="line">perf_event      0       1       1</span><br><span class="line">net_prio        0       1       1</span><br></pre></td></tr></table></figure><h3 id="创建新的层级"><a href="#创建新的层级" class="headerlink" title="创建新的层级"></a>创建新的层级</h3><p>使用<code>mount -t cgroup</code>可以看到系统中当前挂载的层级</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">~$ mount -t cgroup</span><br><span class="line">cgroup on /sys/fs/cgroup/systemd <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,xattr,name=systemd)</span><br><span class="line">cgroup on /sys/fs/cgroup/freezer <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,freezer)</span><br><span class="line">cgroup on /sys/fs/cgroup/cpu,cpuacct <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,cpu,cpuacct)</span><br><span class="line">cgroup on /sys/fs/cgroup/memory <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,memory)</span><br><span class="line">cgroup on /sys/fs/cgroup/devices <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,devices)</span><br><span class="line">cgroup on /sys/fs/cgroup/cpuset <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)</span><br><span class="line">cgroup on /sys/fs/cgroup/blkio <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,blkio)</span><br><span class="line">cgroup on /sys/fs/cgroup/pids <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,pids)</span><br><span class="line">cgroup on /sys/fs/cgroup/net_cls,net_prio <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,net_cls,net_prio)</span><br><span class="line">cgroup on /sys/fs/cgroup/hugetlb <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,hugetlb)</span><br><span class="line">cgroup on /sys/fs/cgroup/perf_event <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,perf_event)</span><br><span class="line">cgroup on /sys/fs/cgroup/rdma <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,rdma)</span><br></pre></td></tr></table></figure><p>在创建新的层级关联子系统之前，需要先确定<code>subsystem</code>是否已经关联其他层级，如果有，需要先卸载该层级。如上图结果中，如果需要卸载<code>freezer</code>子系统关联的层级，可以使用<code>umount /sys/fs/cgroup/freezer</code>卸载。</p><p>创建<code>cgroup</code>层级直接在挂载<code>cgroup</code>文件系统即可，一般挂载在<code>/sys/fs/cgroup/</code>下，挂载在其他路径也可以。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /run/cgroup/memory</span><br><span class="line">mount -t cgroup -o memory &lt;name&gt; /run/cgroup/memory<span class="comment"># 创建一个与memory子系统关联的层级，&lt;name&gt;可以替换为任意字符串</span></span><br><span class="line"></span><br><span class="line">mkdir -p /run/cgroup/cpu,cpuacct</span><br><span class="line">mount -t cgroup -o cpu,cpuacct &lt;name&gt; /run/cgroup/cpu,cpuacct<span class="comment"># 创建一个与cpu和cpuacct子系统关联的层级</span></span><br><span class="line"></span><br><span class="line">mkdir -p /run/cgroup/<span class="built_in">test</span></span><br><span class="line">mount -t cgroup -o none,name=&lt;name&gt; &lt;another name&gt; /run/cgroup/<span class="built_in">test</span><span class="comment"># 创建一个不与任何子系统关联的层级,此处的name=&lt;name&gt;作为参数,是该层级的标识符</span></span><br></pre></td></tr></table></figure><p>当层级不与任何子系统关联，挂载时指定的参数<code>name=&lt;name&gt;</code>，<code>&lt;name&gt;</code>为该层级的唯一标记；当挂载另一个不关联子系统的层级时，如果参数<code>name=&lt;name&gt;</code>指定的<code>&lt;name&gt;</code>已经存在，则会再次挂载该层级，两个挂载点的内容相同。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">~$ mkdir -p /run/cgroup/nametest</span><br><span class="line">~$ mount -t cgroup -o none,name=nametest cgroup /run/cgroup/nametest</span><br><span class="line">~$ <span class="built_in">cd</span> /run/cgroup/nametest &amp;&amp; mkdir test_flag &amp;&amp; ls</span><br><span class="line">cgroup.clone_children  cgroup.procs           cgroup.sane_behavior   notify_on_release      release_agent          tasks                  test_flag</span><br><span class="line"></span><br><span class="line">~$ mkdir -p /run/cgroup/nametest2</span><br><span class="line">~$ mount -t cgroup -o none,name=nametest cgroup /run/cgroup/nametest2</span><br><span class="line">~$ <span class="built_in">cd</span> /run/cgroup/nametest2 &amp;&amp; ls</span><br><span class="line">cgroup.clone_children  cgroup.procs           cgroup.sane_behavior   notify_on_release      release_agent          tasks                  test_flag</span><br><span class="line"><span class="comment"># test_flag仍然存在，说明仅再次挂载了name=nametest的层级，没有创建新的层级</span></span><br></pre></td></tr></table></figure><h3 id="查看进程属于哪些cgroup"><a href="#查看进程属于哪些cgroup" class="headerlink" title="查看进程属于哪些cgroup"></a>查看进程属于哪些<code>cgroup</code></h3><p>使用<code>cat /proc/&lt;进程号&gt;/cgroup</code>查看进程属于哪些<code>cgroup</code>，例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">~$ cat /proc/1/cgroup</span><br><span class="line">12:rdma:/</span><br><span class="line">11:perf_event:/</span><br><span class="line">10:hugetlb:/</span><br><span class="line">9:net_cls,net_prio:/</span><br><span class="line">8:pids:/</span><br><span class="line">7:blkio:/</span><br><span class="line">6:cpuset:/</span><br><span class="line">5:devices:/</span><br><span class="line">4:memory:/</span><br><span class="line">3:cpu,cpuacct:/</span><br><span class="line">2:freezer:/</span><br><span class="line">1:name=systemd:/init.scope</span><br><span class="line">0::/init.scope</span><br></pre></td></tr></table></figure><p>结果从左到右依次为：所属层级的ID，与层级关联的子系统，在层级的目录树中所属的<code>cgroup</code>的路径。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;cgroup（control group）&lt;/code&gt;是由&lt;code&gt;linux&lt;/code&gt;内核提供的功能，可以对一组进程使用的资源进行监控、管理和限制。&lt;/p&gt;
&lt;h2 id=&quot;工作机制&quot;&gt;&lt;a href=&quot;#工作机制&quot; class=&quot;headerlink
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>cmocka单元测试框架</title>
    <link href="https://www.tiehichi.site/2019/11/07/cmocka%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    <id>https://www.tiehichi.site/2019/11/07/cmocka单元测试框架/</id>
    <published>2019-11-07T00:00:00.000Z</published>
    <updated>2022-06-15T07:21:11.284Z</updated>
    
    <content type="html"><![CDATA[<p><code>cmocka</code>是一个C语言的单元测试框架，仅依赖标准库，可以在多种平台多种编译器上使用。</p><p><code>cmocka</code>官网为<a href="https://cmocka.org/" target="_blank" rel="noopener">https://cmocka.org/</a></p><h2 id="下载和编译"><a href="#下载和编译" class="headerlink" title="下载和编译"></a>下载和编译</h2><p><code>cmocka</code>的源码托管在<a href="https://gitlab.com/cmocka/cmocka" target="_blank" rel="noopener">GitLab</a>上，编译系统使用<code>CMake</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://gitlab.com/cmocka/cmocka.git</span><br><span class="line"><span class="built_in">cd</span> cmocka</span><br><span class="line">mkdir build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake .. &amp;&amp; make</span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><code>cmocka</code>使用示例位于源码目录下的<code>example</code>文件夹中，<code>example</code>中演示了<code>assert_macro</code>、<code>assert_module</code>、<code>allocate_module</code>和<code>mock</code>的使用。</p><h3 id="测试用法"><a href="#测试用法" class="headerlink" title="测试用法"></a>测试用法</h3><ol><li><p><code>simple_test</code></p><p><code>simple_test.c</code>演示了<code>cmocka</code>最简单的使用方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmocka.h&gt;// include cmocka header</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// test case, do nothing</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">null_test_success</span><span class="params">(<span class="keyword">void</span> **state)</span> </span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>) state; <span class="comment">/* unused */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">CMUnitTest</span> <span class="title">tests</span>[] = &#123;</span></span><br><span class="line">        cmocka_unit_test(null_test_success),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cmocka_run_group_tests(tests, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>allocate_module_test</code></p><p>该例子演示了<code>allocate</code>检测功能的使用， 对应的源码为<code>example/allocate_module.c</code>和<code>example/allocate_module_test.c</code>，其中<code>allocate_module.c</code>是待测试模块。</p><p>根据源码分析，为了使用<code>memory check</code>功能，需要修改待测模块的源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNIT_TESTING</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span>* _test_malloc(<span class="keyword">const</span> <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">const</span> <span class="keyword">char</span>* file, <span class="keyword">const</span> <span class="keyword">int</span> <span class="built_in">line</span>);</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span>* _test_calloc(<span class="keyword">const</span> <span class="keyword">size_t</span> number_of_elements, <span class="keyword">const</span> <span class="keyword">size_t</span> <span class="built_in">size</span>,</span><br><span class="line">                          <span class="keyword">const</span> <span class="keyword">char</span>* file, <span class="keyword">const</span> <span class="keyword">int</span> <span class="built_in">line</span>);</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span> _test_free(<span class="keyword">void</span>* <span class="keyword">const</span> ptr, <span class="keyword">const</span> <span class="keyword">char</span>* file, <span class="keyword">const</span> <span class="keyword">int</span> <span class="built_in">line</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> malloc(size) _test_malloc(size, __FILE__, __LINE__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> calloc(num, size) _test_calloc(num, size, __FILE__, __LINE__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> free(ptr) _test_free(ptr, __FILE__, __LINE__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// UNIT_TESTING</span></span></span><br></pre></td></tr></table></figure><p>将代码中使用的<code>malloc</code>、<code>free</code>等函数替换成<code>cmocka</code>框架中的封装，然后在<code>test case</code>中调用待测函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">leak_memory_test</span><span class="params">(<span class="keyword">void</span> **state)</span> </span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>) state; <span class="comment">/* unused */</span></span><br><span class="line">    leak_memory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例程序中演示了检测内存泄漏、缓冲区溢出和缓冲区下溢；内存问题的检测通过替换<code>malloc</code>和<code>free</code>函数来完成，使用场景比较有限。</p></li><li><p><code>assert_macro_test</code></p><p>该示例演示了断言宏的使用，用法非常简单，在<code>test case</code>中使用断言宏对待测试模块进行调用即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">get_status_code_string_test</span><span class="params">(<span class="keyword">void</span> **state)</span> </span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>) state; <span class="comment">/* unused */</span></span><br><span class="line">    assert_string_equal(get_status_code_string(<span class="number">0</span>), <span class="string">"Address not found"</span>);</span><br><span class="line">    assert_string_equal(get_status_code_string(<span class="number">1</span>), <span class="string">"Connection timed out"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">string_to_status_code_test</span><span class="params">(<span class="keyword">void</span> **state)</span> </span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>) state; <span class="comment">/* unused */</span></span><br><span class="line">    assert_int_equal(string_to_status_code(<span class="string">"Address not found"</span>), <span class="number">0</span>);</span><br><span class="line">    assert_int_equal(string_to_status_code(<span class="string">"Connection timed out"</span>), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些断言宏仅判断测试结果是否与预期相同。</p></li><li><p><code>assert_module_test</code></p><p>在这个例子中演示了<code>assert</code>相关宏的更高级的用法：</p><ul><li><p><code>mock_assert</code></p><p>在<code>example/assert_module.c</code>中，使用<code>mock_assert</code>宏覆盖了标准库中的<code>assert</code>宏，原因是标准库中的<code>assert</code>宏会引起进程的<code>Aborted</code>，造成无法继续执行其他<code>test case</code>，而<code>mock_assert</code>不会引起进程<code>Aborted</code>。</p></li><li><p><code>expect_assert_failure</code></p><p>根据语义可以判断这个宏的作用是<strong><em>期望断言失败</em></strong>，即使用该宏测试的函数中发生断言失败，则该宏测试通过，否则测试失败。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 待测试函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increment_value</span><span class="params">(<span class="keyword">int</span> * <span class="keyword">const</span> value)</span> </span>&#123;</span><br><span class="line">    assert(value);</span><br><span class="line">    (*value) ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrement_value</span><span class="params">(<span class="keyword">int</span> * <span class="keyword">const</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">      (*value) --;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test case</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment_value_assert</span><span class="params">(<span class="keyword">void</span> **state)</span> </span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>) state;</span><br><span class="line">    expect_assert_failure(increment_value(<span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decrement_value_fail</span><span class="params">(<span class="keyword">void</span> **state)</span> </span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>) state;</span><br><span class="line">    expect_assert_failure(decrement_value(<span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试结果</span></span><br><span class="line">[ RUN      ] increment_value_assert</span><br><span class="line">Expected assertion value occurred</span><br><span class="line">[       OK ] increment_value_assert</span><br><span class="line">[ RUN      ] decrement_value_fail</span><br><span class="line"><span class="function">Expected assert in <span class="title">decrement_value</span><span class="params">(<span class="literal">NULL</span>)</span></span></span><br><span class="line">[  ERROR   ] --- [   LINE   ] --- /home/noah/cmocka/example/assert_module_test.c:46: error: Failure!</span><br><span class="line">[  FAILED  ] decrement_value_fail</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="mock用法"><a href="#mock用法" class="headerlink" title="mock用法"></a><code>mock</code>用法</h3><p><code>mock</code>功能的演示代码位于<code>example/mock</code>中，提供了两个示例，分别是<code>chef_wrap</code>和<code>uptime</code>。</p><p><code>mock</code>功能的使用依赖于一个连接器参数：<code>--wrap=symbol</code>，如果在编译时使用，需要用<code>-Wl,--wrap=symbol</code>，使用这个参数后，当需要调用<code>symbol</code>函数时，实际上会去调用<code>__wrap_symbol</code>。</p><ul><li><p><code>chef_wrap</code></p><p>在这个例子中，待测模块是位于<code>waiter_test_wrap.c</code>中的<code>waiter_process</code>函数，该函数中使用了<code>chef_cook</code>函数，但是根据<code>chef.c</code>中<code>chef_cook</code>函数的表述，该函数并未实现，所以需要对这个函数进行<code>mock</code>，<code>__wrap_chef_cook</code>便是该函数的<code>mock</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __wrap_chef_cook(<span class="keyword">const</span> <span class="keyword">char</span> *order, <span class="keyword">char</span> **dish_out)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> has_ingredients;</span><br><span class="line">    <span class="keyword">bool</span> knows_dish;</span><br><span class="line">    <span class="keyword">char</span> *dish;</span><br><span class="line"></span><br><span class="line">    check_expected_ptr(order);<span class="comment">// 测试输入是否为期望值</span></span><br><span class="line"></span><br><span class="line">    knows_dish = mock_type(<span class="keyword">bool</span>);<span class="comment">// mock knows_dish</span></span><br><span class="line">    <span class="keyword">if</span> (knows_dish == <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    has_ingredients = mock_type(<span class="keyword">bool</span>);<span class="comment">// mock has_ingredients</span></span><br><span class="line">    <span class="keyword">if</span> (has_ingredients == <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dish = mock_ptr_type(<span class="keyword">char</span> *);<span class="comment">// mock dish</span></span><br><span class="line">    *dish_out = strdup(dish);</span><br><span class="line">    <span class="keyword">if</span> (*dish_out == <span class="literal">NULL</span>) <span class="keyword">return</span> ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mock_type(<span class="keyword">int</span>);<span class="comment">// mock return value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该<code>mock</code>函数的实现中，有四处<code>mock_type</code>，这些变量的值由外部（如<code>test case</code>中）提供；<code>check_expected_ptr</code>宏用来测试变量是否为期望的值，该期望值也由外部指定。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_order_hotdog</span><span class="params">(<span class="keyword">void</span> **state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rv;</span><br><span class="line">    <span class="keyword">char</span> *dish;</span><br><span class="line">    (<span class="keyword">void</span>) state; <span class="comment">/* unused */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 指定check_expected_ptr的期望值 */</span></span><br><span class="line">    expect_string(__wrap_chef_cook, order, <span class="string">"hotdog"</span>);</span><br><span class="line"></span><br><span class="line">    will_return(__wrap_chef_cook, <span class="literal">true</span>);<span class="comment">// mock knows_dish</span></span><br><span class="line">    will_return(__wrap_chef_cook, <span class="literal">true</span>);<span class="comment">// mock has_ingredients</span></span><br><span class="line">    <span class="comment">/* mock dish */</span></span><br><span class="line">    will_return(__wrap_chef_cook, cast_ptr_to_largest_integral_type(<span class="string">"hotdog"</span>));</span><br><span class="line">    will_return(__wrap_chef_cook, <span class="number">0</span>);<span class="comment">// mock return value</span></span><br><span class="line"></span><br><span class="line">    rv = waiter_process(<span class="string">"hotdog"</span>, &amp;dish);</span><br><span class="line"></span><br><span class="line">    assert_int_equal(rv, <span class="number">0</span>);</span><br><span class="line">    assert_string_equal(dish, <span class="string">"hotdog"</span>);</span><br><span class="line">    <span class="keyword">if</span> (dish != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">free</span>(dish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>uptime</code></p><p>该示例中编译后生成两个可执行文件，分别是<code>uptime</code>和<code>test_uptime</code>；其中<code>uptime</code>使用未被<code>mock</code>的<code>uptime</code>函数，而<code>test_uptime</code>使用<code>mock</code>的<code>uptime</code>函数。</p><p>这个例子旨在演示<code>mock</code>函数的用途，以及开发过程中<code>mock</code>在进行单元测试时的作用。</p></li></ul><h2 id="生成测试报告"><a href="#生成测试报告" class="headerlink" title="生成测试报告"></a>生成测试报告</h2><p><code>cmocka</code>生成的<code>xml</code>格式报告为<code>JUnit</code>格式。</p><p>一般情况下，执行<code>cmocka</code>单元测试程序，测试结果会直接打印到<code>stderr</code>上，格式如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[==========] Running 2 test(s).</span><br><span class="line">[ RUN      ] test_order_hotdog</span><br><span class="line">[       OK ] test_order_hotdog</span><br><span class="line">[ RUN      ] test_bad_dish</span><br><span class="line">[       OK ] test_bad_dish</span><br><span class="line">[==========] 2 test(s) run.</span><br><span class="line">[  PASSED  ] 2 test(s).</span><br></pre></td></tr></table></figure><p>如果需要生成<code>xml</code>格式报告，需要在代码中添加如下行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmocka_set_message_output(CM_OUTPUT_XML);</span><br></pre></td></tr></table></figure><p>该行需要在<code>cmocka_run_group_tests</code>之前调用；<code>xml</code>格式输出如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">testsuites</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">testsuite</span> <span class="attr">name</span>=<span class="string">"tests"</span> <span class="attr">time</span>=<span class="string">"0.000"</span> <span class="attr">tests</span>=<span class="string">"2"</span> <span class="attr">failures</span>=<span class="string">"0"</span> <span class="attr">errors</span>=<span class="string">"0"</span> <span class="attr">skipped</span>=<span class="string">"0"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">testcase</span> <span class="attr">name</span>=<span class="string">"test_order_hotdog"</span> <span class="attr">time</span>=<span class="string">"0.000"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">testcase</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">testcase</span> <span class="attr">name</span>=<span class="string">"test_bad_dish"</span> <span class="attr">time</span>=<span class="string">"0.000"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">testcase</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">testsuite</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">testsuites</span>&gt;</span></span><br></pre></td></tr></table></figure><p>除此之外，也可以通过设置<code>CMOCKA_MESSAGE_OUTPUT</code>环境变量修改<code>cmocka</code>的输出格式，环境变量可用的值有<code>stdout</code>、<code>subunit</code>、<code>tab</code>和 <code>xml</code>；需要注意的是，设置环境变量修改报告格式的方法优先级更高。</p><p>默认情况下，<code>cmocka</code>的输出会被打印到<code>stderr</code>，如果需要存储到文件中，可以通过设置<code>CMOCKA_XML_FILE</code>环境变量的方式，如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMOCKA_XML_FILE=testresults/result1.xml</span><br></pre></td></tr></table></figure><p>如果<code>cmocka</code>无法在<code>CMOCKA_XML_FILE</code>指定的位置创建文件，则仍然会将结果输出到<code>stderr</code>。</p><p>如果有多个<code>cmocka</code>测试程序需要生成报告，可以使用<code>%g</code>对文件名进行格式化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMOCKA_XML_FILE=testresults/%g.xml</span><br></pre></td></tr></table></figure><p>生成报告时，<code>%g</code>将被格式化为<code>group name</code>，即<code>cmocka_run_group_tests</code>宏的第一个参数，例如前面<code>simple_test</code>生成的报告文件名为<code>tests.xml</code>。</p><h2 id="生成覆盖率报告"><a href="#生成覆盖率报告" class="headerlink" title="生成覆盖率报告"></a>生成覆盖率报告</h2><p>推荐使用<code>lcov</code>工具生成代码覆盖率报告；<code>lcov</code>依赖于<code>gcov</code>，后者是包含在<code>GNU</code>编译套件中的，只要安装了<code>GCC</code>，一般就已经包含了<code>gcov</code>工具，但是<code>lcov</code>需要单独安装；<code>Ubuntu</code>上安装方法如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install lcov</span><br></pre></td></tr></table></figure><p>为了生成代码覆盖率报告，首先需要在编译生成单元测试程序时，添加编译器和连接器参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译器参数</span></span><br><span class="line">--coverage</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接器参数</span></span><br><span class="line">--coverage -lgcov</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过GCC添加连接器参数</span></span><br><span class="line">-Wl,--coverage -lgcov</span><br></pre></td></tr></table></figure><p>编译完成后，可执行文件同级目录下应该会生成后缀名为<code>.gcno</code>的文件，如果使用<code>cmake</code>编译系统进行编译，生成的文件可能在对应项目的<code>CMakeFiles</code>目录中；继续执行测试程序，执行完成后，会在当前目录生成后缀名为<code>.gcda</code>的文件，如果使用<code>cmake</code>，则会生成在<code>CMakeFiles</code>对应的目录中。</p><p>接着使用<code>lcov</code>分析并生成对应的<code>info</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcov --capture --directory project-dir --output-file coverage.info</span><br></pre></td></tr></table></figure><p>注意将<code>project-dir</code>替换成包含<code>.gcda</code>文件的文件夹（支持递归查找）</p><p>最后使用<code>genhtml</code>工具将前面生成的<code>info</code>文件转为<code>html</code>格式的网页</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">genhtml coverage.info --output-directory out</span><br></pre></td></tr></table></figure><p>生成的静态网页会存放在<code>out</code>文件夹中，使用浏览器打开<code>index.html</code>即可可视化查看代码覆盖率</p><p><img src="https://i.loli.net/2019/10/09/6UgIfKmhFuj14lk.png" alt="代码覆盖率"></p><p><img src="https://i.loli.net/2019/10/09/jbSNAeZTfusnCKg.png" alt="覆盖的行"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;cmocka&lt;/code&gt;是一个C语言的单元测试框架，仅依赖标准库，可以在多种平台多种编译器上使用。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cmocka&lt;/code&gt;官网为&lt;a href=&quot;https://cmocka.org/&quot; target=&quot;_blank&quot; rel=&quot;
      
    
    </summary>
    
    
      <category term="单元测试" scheme="https://www.tiehichi.site/categories/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>单元测试中的概念</title>
    <link href="https://www.tiehichi.site/2019/10/18/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
    <id>https://www.tiehichi.site/2019/10/18/单元测试中的概念/</id>
    <published>2019-10-18T00:00:00.000Z</published>
    <updated>2022-06-15T07:21:11.284Z</updated>
    
    <content type="html"><![CDATA[<p>单元测试是针对代码中的最小模块进行单独测试的方法；一般对于面向过程语言来说，最小模块就是过程函数；而对于面向对象语言，一般是类的各种方法。</p><p>单元测试使得我们可以放心修改、重构业务代码，而不用担心修改某处代码后带来的副作用。</p><p>单元测试可以帮助我们反思模块划分的合理性，如果一个单元测试写得逻辑非常复杂、或者说一个函数复杂到无法写单测，那就说明模块的抽象有问题。</p><p>单元测试使得系统具备更好的可维护性、具备更好的可读性；对于团队的新人来说，阅读系统代码可以从单元测试入手，一点点开始后熟悉系统的逻辑。</p><h2 id="TDD"><a href="#TDD" class="headerlink" title="TDD"></a>TDD</h2><p>测试驱动开发，是指针对一个项目，在设计好接口的情况下，先针对功能模块编写测试程序，在编写实际代码。这种开发方式能够极大程度的减少代码中单个功能模块的错误发生率。</p><h2 id="单元测试框架"><a href="#单元测试框架" class="headerlink" title="单元测试框架"></a>单元测试框架</h2><p>编写单元测试代码的过程中会有很多冗余的工作，例如格式化输出，初始化环境等等；而单元测试框架就是用来解决这些问题的。一般单元测试框架会提供例如格式化输出、结果验证宏等功能，有些框架也会提供模拟对象、代码生成器等高级功能。</p><h2 id="测试用例（Test-Case"><a href="#测试用例（Test-Case" class="headerlink" title="测试用例（Test Case)"></a>测试用例（Test Case)</h2><p>测试代码中针对某一模块进行测试的部分，一般针对某一模块的测试用例放在一起。</p><h2 id="夹具（Fixture）"><a href="#夹具（Fixture）" class="headerlink" title="夹具（Fixture）"></a>夹具（Fixture）</h2><p>单元测试框架中的夹具实际上就是减少编写单元测试过程中的冗余代码，让编写单元测试的过程尽量集中在测试用例上。</p><p>有些单元测试框架也会提供夹具组，其实就是把多个包含测试用例的夹具放到一起，进一步减少冗余的代码。</p><h2 id="代码生成器（Generator）"><a href="#代码生成器（Generator）" class="headerlink" title="代码生成器（Generator）"></a>代码生成器（Generator）</h2><p>前面提到的TDD开发模式中，是先编写测试代码再去编写模块代码的，对于某些语言例如C，编译测试代码的时候需要模块代码参与编译，这种时候就需要代码生成器来去生成空的模块参与编译。</p><h2 id="Mock"><a href="#Mock" class="headerlink" title="Mock"></a>Mock</h2><p>在一些面向对象语言中，当某个模块的方法依赖于另一个模块的时候，为了保证单元测试的隔离，不能直接使用另一个模块作为参数，此时就需要对这个模块进行mock，实际上就是构造一个虚拟的模块作为参数去测试其他模块功能；对于面向过程语言来说，需要被mock的模块可能是函数或者结构体对象。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;单元测试是针对代码中的最小模块进行单独测试的方法；一般对于面向过程语言来说，最小模块就是过程函数；而对于面向对象语言，一般是类的各种方法。&lt;/p&gt;
&lt;p&gt;单元测试使得我们可以放心修改、重构业务代码，而不用担心修改某处代码后带来的副作用。&lt;/p&gt;
&lt;p&gt;单元测试可以帮助我们反
      
    
    </summary>
    
    
      <category term="单元测试" scheme="https://www.tiehichi.site/categories/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>减小Docker镜像的体积</title>
    <link href="https://www.tiehichi.site/2019/10/13/%E5%87%8F%E5%B0%8FDocker%E9%95%9C%E5%83%8F%E7%9A%84%E4%BD%93%E7%A7%AF/"/>
    <id>https://www.tiehichi.site/2019/10/13/减小Docker镜像的体积/</id>
    <published>2019-10-13T00:00:00.000Z</published>
    <updated>2022-06-15T07:21:11.284Z</updated>
    
    <content type="html"><![CDATA[<p>在构建用于<code>高通sectools</code>签名工具的<code>Docker</code>镜像时，发现一个问题：我基于<code>alpine 3.2</code>构建的镜像，居然比同事基于<code>ubuntu 16.04</code>构建的镜像体积更大，感觉没什么道理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">secbootdevfcb2114cfdb813 seconds ago241MB        <span class="comment"># 我的</span></span><br><span class="line">ubuntusecboot4e637fb3bcc519 hours ago186MB        <span class="comment"># 同事的</span></span><br></pre></td></tr></table></figure><p><code>Dockerfile</code>长这样</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> alpine:<span class="number">3.2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> sed -i <span class="string">'s/dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn/g'</span> /etc/apk/repositories &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apk add --no-cache \</span></span><br><span class="line"><span class="bash">    python \</span></span><br><span class="line"><span class="bash">    openssl \</span></span><br><span class="line"><span class="bash">    squashfs-tools \</span></span><br><span class="line"><span class="bash">    cryptsetup \</span></span><br><span class="line"><span class="bash">    fakeroot \</span></span><br><span class="line"><span class="bash">    libxml2-utils \</span></span><br><span class="line"><span class="bash">    lzo \</span></span><br><span class="line"><span class="bash">    bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk add --no-cache --virtual .build-deps \</span></span><br><span class="line"><span class="bash">    git \</span></span><br><span class="line"><span class="bash">    make \</span></span><br><span class="line"><span class="bash">    python-dev \</span></span><br><span class="line"><span class="bash">    py-pip \</span></span><br><span class="line"><span class="bash">    lzo-dev \</span></span><br><span class="line"><span class="bash">    gcc \</span></span><br><span class="line"><span class="bash">    libc-dev \</span></span><br><span class="line"><span class="bash">    autoconf \</span></span><br><span class="line"><span class="bash">    automake \</span></span><br><span class="line"><span class="bash">    pkgconf \</span></span><br><span class="line"><span class="bash">    libtool \</span></span><br><span class="line"><span class="bash">    util-linux-dev \</span></span><br><span class="line"><span class="bash">    zlib-dev \</span></span><br><span class="line"><span class="bash">    linux-headers</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span> /root &amp;&amp; \</span></span><br><span class="line"><span class="bash">    git <span class="built_in">clone</span> git://git.infradead.org/mtd-utils.git &amp;&amp; \</span></span><br><span class="line"><span class="bash">    <span class="built_in">cd</span> mtd-utils &amp;&amp; git checkout v2.0.2 &amp;&amp; \</span></span><br><span class="line"><span class="bash">    ./autogen.sh &amp;&amp; ./configure &amp;&amp; make &amp;&amp; make install &amp;&amp; \</span></span><br><span class="line"><span class="bash">    <span class="built_in">cd</span> /root &amp;&amp; rm -rf mtd-utils &amp;&amp; \</span></span><br><span class="line"><span class="bash">    pip install python-lzo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk del .build-deps</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /root</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"/bin/bash"</span>]</span></span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>为了找出镜像过大的原因，我开始一段一段的<code>build</code>，测试镜像的大小，终于在最后一个<code>RUN</code>的位置发现了问题<br>这是运行<code>apk del .build-deps</code>前后的镜像大小</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">secbootdev53016ef2a6c6        34 minutes ago      240MB        <span class="comment"># apk del之前</span></span><br><span class="line">secbootdevfcb2114cfdb8        35 minutes ago      241MB        <span class="comment"># apk del之后</span></span><br></pre></td></tr></table></figure><p>我确认上面的注释不是我写错了，而是确实<code>apk del</code>之后镜像比之前还大了<code>1M</code>；仔细思考之后，我觉得应该是镜像分层造成的最终镜像过大。</p><p>查询之后发现有个命令可以查看<code>Docker</code>镜像的分层情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">history</span> &lt;repository&gt;:&lt;tag&gt;</span><br></pre></td></tr></table></figure><p>查看<code>secboot:dev</code>镜像的分层结果如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">IMAGECREATEDCREATED BY                                      SIZE</span><br><span class="line">0362b4c01d3d4 seconds ago/bin/sh -c <span class="comment">#(nop)  CMD ["/bin/bash"]            0B</span></span><br><span class="line">021384a78602    4 seconds ago   /bin/sh -c <span class="comment">#(nop) WORKDIR /root                 0B</span></span><br><span class="line">e3cc8dc505b8    4 seconds ago   /bin/sh -c apk del .build-deps                  167kB</span><br><span class="line">18bba3b26848    6 seconds ago   /bin/sh -c <span class="built_in">cd</span> /root &amp;&amp;     git <span class="built_in">clone</span> git://g…   2.86MB</span><br><span class="line">412c227506812 minutes ago   /bin/sh -c apk add --no-cache --virtual .bui…   192MB</span><br><span class="line">84a93104b0943 minutes ago/bin/sh -c sed -i <span class="string">'s/dl-cdn.alpinelinux.org/…   40.6MB</span></span><br><span class="line"><span class="string">98f5f2d17bd18 months ago    /bin/sh -c #(nop)  CMD ["/bin/sh"]              0B</span></span><br><span class="line"><span class="string">&lt;missing&gt;8 months ago/bin/sh -c #(nop) ADD file:3b4be7a9f665764de…   5.27MB</span></span><br></pre></td></tr></table></figure><p>从分层结果可以看到，第五个层占用了<code>192M</code>的空间，其对应<code>Dockerfile</code>中的命令应该是<code>apk add --no-cache --virtual .build-deps</code>命令；所以镜像过大的原因应该是<code>apk del .build-deps</code>只在第三层中卸载了软件包并叠加在第四层上，而第五层安装的软件包仍然存在。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="合并层级"><a href="#合并层级" class="headerlink" title="合并层级"></a>合并层级</h3><p>最简单的优化方法当然是将<code>apk add --no-cache --virtual .build-deps</code>到<code>apk del .build-deps</code>合并到一个层中，这样安装软件包的时候不会创建新的层级，使用完后卸载软件包，也不会使改层级占用过大的空间。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> apk add --no-cache --virtual .build-deps \</span></span><br><span class="line"><span class="bash">    git \</span></span><br><span class="line"><span class="bash">    make \</span></span><br><span class="line"><span class="bash">    python-dev \</span></span><br><span class="line"><span class="bash">    py-pip \</span></span><br><span class="line"><span class="bash">    lzo-dev \</span></span><br><span class="line"><span class="bash">    gcc \</span></span><br><span class="line"><span class="bash">    libc-dev \</span></span><br><span class="line"><span class="bash">    autoconf \</span></span><br><span class="line"><span class="bash">    automake \</span></span><br><span class="line"><span class="bash">    pkgconf \</span></span><br><span class="line"><span class="bash">    libtool \</span></span><br><span class="line"><span class="bash">    util-linux-dev \</span></span><br><span class="line"><span class="bash">    zlib-dev \</span></span><br><span class="line"><span class="bash">    linux-headers \</span></span><br><span class="line"><span class="bash">    &amp;&amp; \</span></span><br><span class="line"><span class="bash"><span class="built_in">cd</span> /root &amp;&amp; \</span></span><br><span class="line"><span class="bash">    git <span class="built_in">clone</span> git://git.infradead.org/mtd-utils.git &amp;&amp; \</span></span><br><span class="line"><span class="bash">    <span class="built_in">cd</span> mtd-utils &amp;&amp; git checkout v2.0.2 &amp;&amp; \</span></span><br><span class="line"><span class="bash">    ./autogen.sh &amp;&amp; ./configure &amp;&amp; make &amp;&amp; make install &amp;&amp; \</span></span><br><span class="line"><span class="bash">    <span class="built_in">cd</span> /root &amp;&amp; rm -rf mtd-utils &amp;&amp; \</span></span><br><span class="line"><span class="bash">    pip install python-lzo \</span></span><br><span class="line"><span class="bash">    &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apk del .build-deps</span></span><br></pre></td></tr></table></figure><p>再次<code>build</code>查看分层情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IMAGE         CREATED              CREATED BY                                      SIZE</span><br><span class="line">9ab88d516323  About a minute ago   /bin/sh -c <span class="comment">#(nop)  CMD ["/bin/bash"]            0B</span></span><br><span class="line">10ce23bc619c  About a minute ago   /bin/sh -c <span class="comment">#(nop) WORKDIR /root                 0B</span></span><br><span class="line">197866cc1784  About a minute ago   /bin/sh -c apk add --no-cache --virtual .bui…   3.32MB</span><br><span class="line">84a93104b094  30 minutes ago       /bin/sh -c sed -i <span class="string">'s/dl-cdn.alpinelinux.org/…   40.6MB</span></span><br><span class="line"><span class="string">98f5f2d17bd1  8 months ago         /bin/sh -c #(nop)  CMD ["/bin/sh"]              0B</span></span><br><span class="line"><span class="string">&lt;missing&gt;  8 months ago         /bin/sh -c #(nop) ADD file:3b4be7a9f665764de…   5.27MB</span></span><br></pre></td></tr></table></figure><p>可以看到刚才占了<code>192M</code>空间的<code>IMAGE</code>没了，刚才的3、4、5层合并成现在的第三层，仅仅占用了<code>3.32M</code>的空间，镜像的最终大小也降至<code>49M</code>。</p><h3 id="利用Docker的多阶段构建进行压缩"><a href="#利用Docker的多阶段构建进行压缩" class="headerlink" title="利用Docker的多阶段构建进行压缩"></a>利用Docker的多阶段构建进行压缩</h3><p><code>Docker</code>的多阶段构建类似于这样</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">8</span> as build</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> package.json index.js ./</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm install</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">8</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=build /app /</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"index.js"</span>]</span></span><br></pre></td></tr></table></figure><p>二阶段构建时将前一阶段的构建结果拷贝到当前镜像中，相当于将前一阶段的结果<code>merge</code>到当前阶段的构建当中。</p><p><img src="https://s3.amazonaws.com/infoq.content.live.0/articles/3-simple-tricks-for-smaller-docker-images/zh/resources/92-1535708975704.gif" alt=""></p><p>对于我当前的<code>Dockerfile</code>，要通过多阶段编译来缩小镜像，需要调整一下执行顺序，让编译<code>mtd-utils</code>的过程作为一阶段构建，二阶段构建直接使用前一阶段的结果。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> alpine:<span class="number">3.2</span> as build_mtd_utils</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> sed -i <span class="string">'s/dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn/g'</span> /etc/apk/repositories &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apk add --no-cache python &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apk add --no-cache --virtual .build-deps \</span></span><br><span class="line"><span class="bash">    git \</span></span><br><span class="line"><span class="bash">    make \</span></span><br><span class="line"><span class="bash">    python-dev \</span></span><br><span class="line"><span class="bash">    py-pip \</span></span><br><span class="line"><span class="bash">    lzo-dev \</span></span><br><span class="line"><span class="bash">    gcc \</span></span><br><span class="line"><span class="bash">    libc-dev \</span></span><br><span class="line"><span class="bash">    autoconf \</span></span><br><span class="line"><span class="bash">    automake \</span></span><br><span class="line"><span class="bash">    pkgconf \</span></span><br><span class="line"><span class="bash">    libtool \</span></span><br><span class="line"><span class="bash">    util-linux-dev \</span></span><br><span class="line"><span class="bash">    zlib-dev \</span></span><br><span class="line"><span class="bash">    linux-headers</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span> /root &amp;&amp; \</span></span><br><span class="line"><span class="bash">    git <span class="built_in">clone</span> git://git.infradead.org/mtd-utils.git &amp;&amp; \</span></span><br><span class="line"><span class="bash">    <span class="built_in">cd</span> mtd-utils &amp;&amp; git checkout v2.0.2 &amp;&amp; \</span></span><br><span class="line"><span class="bash">    ./autogen.sh &amp;&amp; ./configure &amp;&amp; make &amp;&amp; make install &amp;&amp; \</span></span><br><span class="line"><span class="bash">    <span class="built_in">cd</span> /root &amp;&amp; rm -rf mtd-utils &amp;&amp; \</span></span><br><span class="line"><span class="bash">    pip install python-lzo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk del .build-deps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> alpine:<span class="number">3.2</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=build_mtd_utils / /</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk add --no-cache \</span></span><br><span class="line"><span class="bash">    openssl \</span></span><br><span class="line"><span class="bash">    squashfs-tools \</span></span><br><span class="line"><span class="bash">    cryptsetup \</span></span><br><span class="line"><span class="bash">    fakeroot \</span></span><br><span class="line"><span class="bash">    libxml2-utils \</span></span><br><span class="line"><span class="bash">    lzo \</span></span><br><span class="line"><span class="bash">    bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /root</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"/bin/bash"</span>]</span></span><br></pre></td></tr></table></figure><p>看看编译后的分层情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IMAGECREATEDCREATED BY                                      SIZE</span><br><span class="line">3d27fb3a9c4c30 seconds ago/bin/sh -c <span class="comment">#(nop)  CMD ["/bin/bash"]0B</span></span><br><span class="line">dd3f19eac44d30 seconds ago/bin/sh -c <span class="comment">#(nop) WORKDIR /root0B</span></span><br><span class="line">155f84cb791830 seconds ago/bin/sh -c apk add --no-cache     openssl   …   4.21MB</span><br><span class="line">d166bc1eb44c39 seconds ago/bin/sh -c <span class="comment">#(nop) COPY dir:c1b109c276e386ad4…   44.9MB</span></span><br><span class="line">98f5f2d17bd18 months ago/bin/sh -c <span class="comment">#(nop)  CMD ["/bin/sh"]              0B</span></span><br><span class="line">&lt;missing&gt;8 months ago/bin/sh -c <span class="comment">#(nop) ADD file:3b4be7a9f665764de…   5.27MB</span></span><br></pre></td></tr></table></figure><p>第四层的<code>COPY</code>就是使用了前一阶段的构建结果；这种构建方式最终镜像的大小会比前面合并层级的方式稍大，原因是第四层在使用前一阶段构建结果时，已经包含了基础镜像的大小，所以第六层的基础镜像层就多了出来。</p><p>除了镜像稍大之外，这种构建方式还会创建一个多余的匿名镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-&gt; % docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED              SIZE</span><br><span class="line">secboot             dev                 3d27fb3a9c4c        About a minute ago   54.4MB</span><br><span class="line">&lt;none&gt;              &lt;none&gt;              3449aa1a3034        About a minute ago   238MB</span><br></pre></td></tr></table></figure><p>可以看到<code>secboot:dev</code>镜像比前面合并层级的优化方式多了<code>5M</code>，并且多出了一个<code>238M</code>的匿名镜像；这个镜像这么大的原因仍然是我将<code>apk add</code>和<code>apk del</code>放在两个层级中。</p><h3 id="使用distroless"><a href="#使用distroless" class="headerlink" title="使用distroless"></a>使用<code>distroless</code></h3><p>待调研</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在构建用于&lt;code&gt;高通sectools&lt;/code&gt;签名工具的&lt;code&gt;Docker&lt;/code&gt;镜像时，发现一个问题：我基于&lt;code&gt;alpine 3.2&lt;/code&gt;构建的镜像，居然比同事基于&lt;code&gt;ubuntu 16.04&lt;/code&gt;构建的镜像体积更大，
      
    
    </summary>
    
    
      <category term="docker" scheme="https://www.tiehichi.site/categories/docker/"/>
    
    
  </entry>
  
  <entry>
    <title>公钥私钥、签名和证书</title>
    <link href="https://www.tiehichi.site/2019/03/15/key_signature_certificate/"/>
    <id>https://www.tiehichi.site/2019/03/15/key_signature_certificate/</id>
    <published>2019-03-15T00:00:00.000Z</published>
    <updated>2022-06-15T07:21:11.284Z</updated>
    
    <content type="html"><![CDATA[<p>工作需要，研究了一下安全相关理论知识和名词</p><a id="more"></a><h3 id="非对称加密中的公钥和私钥"><a href="#非对称加密中的公钥和私钥" class="headerlink" title="非对称加密中的公钥和私钥"></a>非对称加密中的公钥和私钥</h3><p>在加解密的过程中，加密密钥和解密密钥不同的加密方式，就是<code>非对称加密</code>。例如：</p><p><img src="https://i.loli.net/2019/03/15/5c8b3d197c943.png" alt=""></p><p>在上图中，加密密钥和解密密钥是不同的，并且两个密钥成对出现，替换掉任意一个密钥，这个加解密过程就不成立，这就是一种非对称加密的形式。</p><p>在非对称加密过程中，由于密钥是成对的，两个密钥公开其中一个，只要保存好另一个密钥，这个过程仍然是安全的，这个被公开的密钥就被称为<code>公钥</code>，自己保留的密钥就是<code>私钥</code>。因为非对称加密的这种特性，该加密过程可用于安全通信、文件校验等场景。</p><p>需要注意的是，理论上非对称加密中的两个密钥，使用任意一个做公钥都是可以的，但在RSA算法中，私钥和公钥生成的规范不同，二者并不能互换角色。</p><h3 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h3><p>在非对称加密的基础上，考虑如下场景：</p><p>现有A和B两个人，A在自己的电脑上生成了一对密钥，并把公钥发给了B</p><p><img src="https://i.loli.net/2019/03/15/5c8b3da9d372a.png" alt=""></p><p>A准备向B发送一个文件，为了确保这个文件在发送过程中不被篡改，并且让B能够确定是A发出的，A采用了这样的方式：将文件先计算哈希和，得到一个文件摘要，然后使用私钥对这个文件摘要进行加密，生成了<code>数字签名</code>，然后把这个签名和文件一起发送给B。</p><p><img src="https://i.loli.net/2019/03/15/5c8b3de6cda1c.png" alt=""></p><p>这样B收到文件后，对<code>数字签名</code>部分使用公钥进行解密，解密成功说明该文件是由A发出的；再对文件部分计算哈希和，并跟解密之后的摘要进行对比，如果哈希和与摘要相同，说明文件未被篡改过。</p><h3 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h3><p>在上面的场景中，如果出现了一个黑客C，C自己生成了一对密钥，然后在A将公钥发给B的过程中截获了公钥A，并替换成自己的公钥C</p><p><img src="https://i.loli.net/2019/03/15/5c8b3e3722d60.png" alt=""></p><p>但B并不知道此事，B仍然以为自己接收的是公钥A；此时C向B发送一个经过签名的恶意文件，B虽然能够完成对该文件的验证，但是B仍以为该文件是A发出的。</p><p>为了解决这种情况，需要一个可信的第三方机构D，并同时引入证书的概念。D生成一对密钥，并把自己的个人信息和公钥打包成一个文件交给B，B相信D，所以把这个文件存了下来，这个文件就是<code>CA证书</code>。</p><p>A把自己的公钥和个人信息也打包成一个文件，交给D进行认证。D在确认这个文件中的公钥跟信息一致（均属于A）的时候，就使用自己的私钥对这个文件进行签名，这样这个文件就是一个<code>经过认证的数字证书</code>。</p><p><img src="https://i.loli.net/2019/03/15/5c8b3e7aae5c8.png" alt=""></p><p>当B需要和A通信时，D会把证书A使用自己的私钥D进行签名，并附带上自己的机构信息，然后将这个文件发送给B。</p><p><img src="https://i.loli.net/2019/03/15/5c8b3ea103494.png" alt=""></p><p>B拿到包含公钥A的证书后，使用CA证书中包含的公钥D进行验证，确认可信后拿到公钥A，然后就可以跟A安全的通信了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作需要，研究了一下安全相关理论知识和名词&lt;/p&gt;
    
    </summary>
    
    
      <category term="Security" scheme="https://www.tiehichi.site/categories/Security/"/>
    
    
  </entry>
  
  <entry>
    <title>树莓派上的骚操作</title>
    <link href="https://www.tiehichi.site/2018/04/04/about_rpi/"/>
    <id>https://www.tiehichi.site/2018/04/04/about_rpi/</id>
    <published>2018-04-04T00:00:00.000Z</published>
    <updated>2022-06-15T07:21:11.284Z</updated>
    
    <content type="html"><![CDATA[<p>树莓派是个好东西，简单易用价格不贵，就是上面的坑还真不少，本文记录一下在使用树莓派2/3的过程中踩过的坑</p><a id="more"></a><h3 id="串口问题"><a href="#串口问题" class="headerlink" title="串口问题"></a>串口问题</h3><p>树莓派3上蓝牙使用硬件串口，软件串口<code>ttyS0</code>的速率不稳定基本无法正常使用。为了能够使用硬件串口设备<code>ttyAMA0</code>即<code>GPIO 14 15</code>脚，需要禁用蓝牙设备，关闭串口shell并打开硬件串口。</p><p>向<code>/boot/config.txt</code>文件中添加<code>dtoverlay=pi3-disable-bt</code>将禁用蓝牙设备，具体可见<code>/boot/overlays</code>文件夹中的<code>README</code>文件。然后使用<code>raspi-config</code>关闭串口shell并且打开硬件串口，重启后即可使用<code>ttyAMA0</code>串口设备。</p><h3 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h3><p>刚装完系统的树莓派，没有显示屏没有串口线，默认没有打开<code>ssh</code>和<code>vnc</code>服务，怎么远程连接上去呢？直接在SD卡的<code>boot</code>分区中创建一个名为<code>ssh</code>的空文件，再启动树莓派的时候<code>ssh</code>服务就被启动了。</p><p>需要注意的是，如果使用这种方法启动了ssh服务，就不要再去<code>raspi-config</code>中启动ssh服务了，否则树莓派上回启动两个<code>ssh</code>服务，远程连接上去使用任何命令都会被两个<code>ssh</code>服务同时执行，也就是任何命令都会被执行两次。</p><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>没有路由器密码没有屏幕怎么查看树莓派ip地址呢？这里强烈安利我的小脚本<a href="https://github.com/StarAndRabbit/LAN-Scanner" target="_blank" rel="noopener">LAN-Scanner</a>，简单粗暴显示局域网内的活动IP和MAC和OUI信息。</p><h3 id="3-5MM音频输出电流声"><a href="#3-5MM音频输出电流声" class="headerlink" title="3.5MM音频输出电流声"></a>3.5MM音频输出电流声</h3><p>网上很多人都提过树莓派的音频输出电流声过大的问题，有人说电路设计有问题解决不了，有人说换电流稳定的电源，有人说换USB声卡，居然还有人说大力出奇迹使劲把接头往里按的……其实解决方法很简单，在<code>/boot/config.txt</code>中添加<code>audio_pwm_mode=2</code>，重启，完事。</p><h3 id="备份镜像过大"><a href="#备份镜像过大" class="headerlink" title="备份镜像过大"></a>备份镜像过大</h3><p>在Linux上使用<code>dd</code>把SD卡备份出来的镜像文件，跟SD卡容量大小相等，你用张32G的卡，备份出来的镜像就是32G。那么有没有一种方法能把镜像缩小呢？当然有！<a href="https://github.com/Drewsif/PiShrink" target="_blank" rel="noopener">PiShrink</a>脚本能够快速的重排镜像中的<code>inode</code>节点，缩减未使用的部分。</p><h3 id="更换软件源"><a href="#更换软件源" class="headerlink" title="更换软件源"></a>更换软件源</h3><p><code>Raspbian</code>上不是只有一个<code>apt</code>源，还有一个<code>archive.raspberrypi.org</code>源，文件位置在<code>/etc/apt/sources.list.d/raspi.list</code>，科大和清华都有对应的国内源，找出来把原本的替换掉即可。例如USTC源的<a href="http://mirrors.ustc.edu.cn/help/archive.raspberrypi.org.html" target="_blank" rel="noopener">使用帮助</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;树莓派是个好东西，简单易用价格不贵，就是上面的坑还真不少，本文记录一下在使用树莓派2/3的过程中踩过的坑&lt;/p&gt;
    
    </summary>
    
    
      <category term="树莓派" scheme="https://www.tiehichi.site/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux串口开发</title>
    <link href="https://www.tiehichi.site/2017/11/16/linuxserialport/"/>
    <id>https://www.tiehichi.site/2017/11/16/linuxserialport/</id>
    <published>2017-11-16T00:00:00.000Z</published>
    <updated>2022-06-15T07:21:11.284Z</updated>
    
    <content type="html"><![CDATA[<p>一直以来在Linux下用到串口的时候都是用Python的pyserial库操作，现在发现直接使用Linux的系统调用操作串口还真是挺复杂的。</p><a id="more"></a><p>得益于Linux一切皆文件的思想，串口的读写可以直接使用<code>read</code>、<code>write</code>系统调用操作<code>/dev</code>目录下的串口设备节点，串口开发复杂的地方在于串口属性的配置，十分繁琐。</p><h3 id="串口设备属性配置"><a href="#串口设备属性配置" class="headerlink" title="串口设备属性配置"></a>串口设备属性配置</h3><p>一般来说，使用串口设备需要配置的属性有：波特率、数据位、停止位、校验位。Linux中，这些属性使用<code>struct termios</code>结构进行存储，该结构定义在<code>termios.h</code>头文件中，查看系统的<a href="https://linux.die.net/man/3/termios" target="_blank" rel="noopener">man手册</a>可以看到该结构的详细介绍。该结构至少包含以下属性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">termios</span></span></span><br><span class="line"><span class="class">&#123;</span>   </span><br><span class="line">    <span class="keyword">tcflag_t</span> c_iflag;      <span class="comment">/* input modes */</span></span><br><span class="line">    <span class="keyword">tcflag_t</span> c_oflag;      <span class="comment">/* output modes */</span></span><br><span class="line">    <span class="keyword">tcflag_t</span> c_cflag;      <span class="comment">/* control modes */</span></span><br><span class="line">    <span class="keyword">tcflag_t</span> c_lflag;      <span class="comment">/* local modes */</span></span><br><span class="line">    <span class="keyword">cc_t</span>     c_cc[NCCS];   <span class="comment">/* special characters */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用<code>tcgetattr()</code>、<code>tcsetattr()</code>函数可以读取或设置串口设备的属性，函数原型见<a href="https://linux.die.net/man/3/termios" target="_blank" rel="noopener">man手册</a>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">portOption</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fd: 串口设备文件描述符，使用 open 函数创建</span></span><br><span class="line">tcgetattr(fd, &amp;portOption);     <span class="comment">// 读取串口设备属性，存入portOption中</span></span><br><span class="line">tcsetattr(fd, TCSANOW, &amp;portOption);    <span class="comment">// 设置设备属性， “TCSANOW”参数表示使属性立即生效</span></span><br></pre></td></tr></table></figure><p><strong>波特率的设置</strong></p><p>可以使用<code>cfsetispeed()</code>、<code>cfsetospeed()</code>分别设置串口的输入、输出波特率，使用<code>cfgetispeed()</code>、<code>cfgetospeed()</code>分别获取串口的输入、输出波特率。波特率的数据类型为<code>speed_t</code>，是一个枚举类型，其取值范围可以查看<a href="https://linux.die.net/man/3/termios" target="_blank" rel="noopener">man手册</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cfsetispeed(&amp;portOption,B115200);   <span class="comment">//设置为115200Bps</span></span><br><span class="line">cfsetospeed(&amp;portOption,B115200);</span><br></pre></td></tr></table></figure><p>注意，该设置仅为修改<code>struct termios</code>结构的值，要让设置生效还需要使用<code>tcsetattr()</code>函数。</p><p><strong>数据位设置</strong></p><p>数据位长度可以设置为5、6、7、8，分别对应宏CS5、CS6、CS7、CS8，根据需要将对应的宏与<code>struct termios</code>结构中的<code>c_cflag</code>字段按位或即可，这种设置属性的方法很符合Unix风格。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">portOption.c_cflag |= CS7;  <span class="comment">// 7位数据位</span></span><br><span class="line">portOption.c_cflag |= CS8;  <span class="comment">// 8位数据位</span></span><br></pre></td></tr></table></figure><p><strong>停止位设置</strong></p><p><code>termios.h</code>中定义了一个宏<code>CSTOPB</code>来表示两位停止位，如果需要设置2位停止位，同数据位设置一样与<code>c_cflag</code>按位或即可。如果要设置1位停止位，则对CSTOPB取反再与<code>c_cflag</code>按位与。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">portOption.c_cflag |= CSTOPB;   <span class="comment">// 2位停止位</span></span><br><span class="line">portOption.c_cflag &amp;= ~CSTOPB;  <span class="comment">// 1位停止位</span></span><br></pre></td></tr></table></figure><p><strong>校验位设置</strong></p><p>涉及校验的宏定义有<code>INPCK</code>、<code>PARENB</code>、<code>PARODD</code>：</p><ul><li>INPCK：开启输入校验</li><li>PARENB：开启输入输出时的校验码生成</li><li>PARODD：设置奇校验<br>使用这三个宏，即可设置校验方式：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 无校验 */</span></span><br><span class="line">portOption.c_cflag &amp;= ~PARENB;</span><br><span class="line">portOption.c_cflag &amp;= ~INPCK;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 奇校验 */</span></span><br><span class="line">portOption.c_cflag |= PARENB;</span><br><span class="line">portOption.c_cflag |= PARODD;</span><br><span class="line">portOption.c_cflag |= INPCK;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 偶校验 */</span></span><br><span class="line">portOption.c_cflag |= PARENB;</span><br><span class="line">portOption.c_cflag &amp;= ~PARODD;</span><br><span class="line">portOption.c_cflag |= INPCK;</span><br></pre></td></tr></table></figure></li></ul><p>注意：如果不是开发串口终端，而仅仅使用串口传输数据，则数据需要使用RAW Mode进行传输：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">portOption.c_lflag &amp;= ~(ICANON | ECHO | ECHOE | ISIG);  <span class="comment">/*Input*/</span></span><br><span class="line">portOption.c_oflag &amp;= ~OPOST;   <span class="comment">/*Output*/</span></span><br></pre></td></tr></table></figure><p>也可以偷懒使用<code>termios.h</code>中提供的函数<code>cfmakeraw()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfmakeraw(&amp;portOption);</span><br></pre></td></tr></table></figure><h3 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h3><p>串口设备的读写阻塞与非阻塞不仅仅与设备节点被<code>open</code>的时候设置的参数有关，还与<code>struct termios</code>结构中<code>c_cc[VMIN]</code>和<code>c_cc[VTIME]</code>有关。</p><p>参考<code>wiringPi</code>库和<code>pyserial</code>的实现，我发现大家再打开串口设备的时候都是将其设置为非阻塞，然后在设置完设备属性后再使用<code>fcntl()</code>将其设置为阻塞。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd = <span class="built_in">open</span>(<span class="string">"/dev/ttyS0"</span>, O_RDWR | O_NOCTTY | O_NONBLOCK | O_NDELAY);</span><br><span class="line">...</span><br><span class="line"><span class="comment">/* 设置属性... */</span></span><br><span class="line">...</span><br><span class="line">fcntl(fd, F_SETFL, <span class="number">0</span>);  <span class="comment">// 设置为阻塞模式</span></span><br></pre></td></tr></table></figure><p>设置完文件描述符的属性，还需要根据<code>c_cc[VMIN]</code>和<code>c_cc[VTIME]</code>才能确定读写的时候是否为阻塞模式，这两项的组合如下：</p><ul><li><p>c_cc[VMIN]==0; c_cc[VTIME]==0;</p><p>  非阻塞，<code>read</code>函数将立即返回实际读取的字节数，没有读取到则返回0</p></li><li><p>c_cc[VMIN]&gt;0; c_cc[VTIME]==0;</p><p>  阻塞，串口缓冲区中至少有<code>c_cc[VMIN]</code>个字节可供读取时，<code>read</code>才会返回，<code>read</code>的返回值为<code>c_cc[VMIN]</code>与<code>read</code>的<code>len</code>参数中的较小者。</p></li><li><p>c_cc[VMIN]==0; c_cc[VTIME]&gt;0;</p><p>  这种情况下，当调用<code>read</code>时，计时器开始计时，<code>c_cc[VTIME]</code>的单位为十分之一秒，如果计时超过<code>c_cc[VTIME]</code>设置的时间，<code>read</code>将会返回0，或者缓冲区中至少有一个字节可供读取，<code>read</code>正常返回，否则将会阻塞。</p></li><li><p>c_cc[VMIN]&gt;0; c_cc[VTIME]&gt;0;</p><p>  该情况中从调用<code>read</code>并且缓冲区中至少有一个字节可用时，计时器开始计时，并且每次调用<code>read</code>且缓冲区中有数据可供读取时，计时器会重新计时，直到计时器超时或者<code>read</code>已经读到<code>len</code>个字节，<code>read</code>会返回实际读取的字节数。注意在该情况下，如果缓冲区中没有可供读取的数据，那么计时器不会启动，<code>read</code>将被一直阻塞。</p></li></ul><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>使用<code>c_cc[VMIN]</code>与<code>c_cc[VTIME]</code>可以灵活的按需设置串口读取的阻塞与非阻塞状态。非阻塞<code>read</code>直接设置<code>c_cc[VMIN]==0; c_cc[VTIME]==0;</code>即可；阻塞的设置相对比较复杂：</p><ol><li><p>如果需要保证每次<code>read</code>的字节数，可以设置<code>c_cc[VMIN]&gt;0; c_cc[VTIME]==0;</code>，但是需要注意，<code>c_cc[]</code>的数据类型<code>cc_t</code>实际上为<code>unsigned char</code>，其取值范围为<code>0~255</code></p></li><li><p>如果需要为<code>read</code>设置超时时间，需要注意后面两种情况的超时是不同的。<code>c_cc[VMIN]==0; c_cc[VTIME]&gt;0;</code>只能确保串口缓冲区中有数据可读，但是无法保证实际<code>read</code>到的字节数量；<code>c_cc[VMIN]&gt;0; c_cc[VTIME]&gt;0;</code>能够确保<code>read</code>到的字节数量，但是<code>read</code>每读取一个字节会重新设置计时器，即设置的超时时间并不是<code>read</code>超时返回的时间，并且需要注意，当缓冲区无数据可读时，计时器并不会启动，<code>read</code>将被一直阻塞。</p></li></ol><p>从某种意义上来说，串口超时的设置都不是“真正的”超时，并非从<code>read</code>函数被调用到超时返回的真实时间。<code>pyserial</code>库中的<code>read</code>函数是可以设置其超时返回时间的，参考其源码发现可以使用<code>select()</code>来实现“真正的”超时。</p><p>为了同时保证<code>read</code>读取的字节数和超时返回的时间，换一种思路就是使用<code>c_cc[VMIN]&gt;0; c_cc[VTIME]==0;</code>来保证<code>read</code>读取的字节数，使用<code>select()</code>函数来设置超时：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fd_set <span class="built_in">set</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line"></span><br><span class="line">timeout.tv_sec = <span class="number">5</span>;     <span class="comment">// 设置超时时间为5s</span></span><br><span class="line">FD_ZERO(&amp;<span class="built_in">set</span>);</span><br><span class="line">FD_SET(fd, &amp;<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">portOption.c_cc[VMIN] = <span class="number">255</span>;</span><br><span class="line">portOption.c_cc[VTIME] = <span class="number">0</span>;</span><br><span class="line">tcsetattr(fd, TCSANOW, &amp;portOption);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(select(fd+<span class="number">1</span>, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;timeout))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="comment">/* timeout */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        <span class="comment">/* select() error */</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">read</span>(fd, <span class="built_in">buffer</span>, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于<code>select()</code>函数的使用方法可以参考<a href="https://linux.die.net/man/3/select" target="_blank" rel="noopener">man手册</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直以来在Linux下用到串口的时候都是用Python的pyserial库操作，现在发现直接使用Linux的系统调用操作串口还真是挺复杂的。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Systemd Service 单元文件的编写</title>
    <link href="https://www.tiehichi.site/2017/09/19/systemd_service_unit/"/>
    <id>https://www.tiehichi.site/2017/09/19/systemd_service_unit/</id>
    <published>2017-09-19T00:00:00.000Z</published>
    <updated>2022-06-15T07:21:11.284Z</updated>
    
    <content type="html"><![CDATA[<p>目前我所掌握的使一个Linux下的软件开机自启动的方法只有将其加入<code>rc.local</code>文件或桌面环境的<code>autostart</code>文件中，但前者不能很好的保证软件的依赖关系，后者要求系统具备桌面环境。虽然知道现在大多数发行版已经使用<code>systemd</code>来管理系统服务，但一直没有研究过如何编写其单元文件，为了解决上述问题，研究了一下<code>systemd</code>的<code>service</code>单元文件的写法，将遇到的问题做个总结。</p><a id="more"></a><h3 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a><code>systemctl</code></h3><p><code>systemctl</code>命令基本相当于<code>System V init</code>的<code>service</code>命令，可用于系统服务的管理，也可以进行电源管理，常用命令如下：</p><ul><li>系统服务管理</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> &lt;unit&gt;     <span class="comment"># 将&lt;unit&gt;设置为开机自启动</span></span><br><span class="line">systemctl <span class="built_in">disable</span> &lt;unit&gt;    <span class="comment"># 取消&lt;unit&gt;开机自启动</span></span><br><span class="line"></span><br><span class="line">systemctl start &lt;unit&gt;      <span class="comment"># 启动&lt;unit&gt;</span></span><br><span class="line">systemctl restart &lt;unit&gt;    <span class="comment"># 重启&lt;unit&gt;</span></span><br><span class="line">systemctl stop &lt;unit&gt;       <span class="comment"># 停止&lt;unit&gt;</span></span><br><span class="line">systemctl status &lt;unit&gt;     <span class="comment"># 查看&lt;unit&gt;的状态</span></span><br><span class="line">systemctl reload &lt;unit&gt;     <span class="comment"># 重新加载&lt;unit&gt;的配置文件而不关闭服务</span></span><br><span class="line"></span><br><span class="line">systemctl is-active &lt;unit&gt;  <span class="comment"># 查看&lt;unit&gt;是否为激活状态</span></span><br><span class="line">systemctl is-enabled &lt;unit&gt; <span class="comment"># 查看&lt;unit&gt;是否设置了开机自启</span></span><br><span class="line">systemctl is-failed &lt;unit&gt;  <span class="comment"># 查看&lt;unit&gt;是否加载失败</span></span><br></pre></td></tr></table></figure><ul><li>电源管理</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl reboot            <span class="comment"># 重启</span></span><br><span class="line">systemctl poweroff          <span class="comment"># 关机</span></span><br><span class="line">systemclt hibernate         <span class="comment"># 休眠</span></span><br><span class="line">systemctl <span class="built_in">suspend</span>           <span class="comment"># 待机</span></span><br></pre></td></tr></table></figure><h3 id="systemd单元文件"><a href="#systemd单元文件" class="headerlink" title="systemd单元文件"></a><code>systemd</code>单元文件</h3><p><code>systemd</code>的单元文件有以下几类：</p><ul><li>系统服务 <code>.service</code></li><li>挂载点 <code>.mount</code></li><li>sockets <code>.socket</code></li><li>系统设备 <code>.device</code></li><li>交换分区 <code>.swp</code></li><li>文件路径 <code>.path</code></li><li>启动目标 <code>.target</code></li><li>定时器 <code>.timer</code></li></ul><p>当使用<code>systemctl</code>对一个单元进行操作时，一般需要使用单元的全名，如<code>ssh.service</code>，但如果使用不带后缀名的单元名称，<code>systemctl</code>将会把这个单元当做系统服务(<code>.service</code>)进行操作。如果一个单元文件中存在<code>@</code>字符，表示该单元文件是一个模板单元，当使用<code>systemctl</code>操作模板单元时，需要对单元进行实例化，否则会调用失败。</p><p>单元文件可以从两个地方加载：</p><ul><li><code>/usr/lib/systemd/system/</code>：软件包安装的单元</li><li><code>/etc/systemd/system/</code>：系统管理员安装的单元</li></ul><p>加载优先级上，系统管理员安装的单元优先级高于软件包安装的单元。</p><h3 id="Serivce单元文件编写"><a href="#Serivce单元文件编写" class="headerlink" title="Serivce单元文件编写"></a>Serivce单元文件编写</h3><p><code>service</code>单元文件有三个段落：<code>[Unit]</code> <code>[Service]</code> <code>[Install]</code>；其单元文件的编写模板可以参考man手册的<a href="http://jlk.fjfi.cvut.cz/arch/manpages/man/systemd.service.5#EXAMPLES" target="_blank" rel="noopener">EXAMPLE章节</a>，上面提到的单元加载目录下也有很多例子可供参考。</p><p><strong>依赖关系的处理</strong></p><p>如果需要<code>A</code>单元在<code>B</code>单元启动之后启动，仅指定<code>Requires=B</code>或<code>Wants=B</code>是不行的，如果不指定<code>After=B</code>，<code>A</code>单元和<code>B</code>单元会并行启动。为了保证<code>A</code>在<code>B</code>单元启动之后再启动，应该在<code>A</code>的配置文件中<code>[Unit]</code>段中添加<code>Requires=B</code>和<code>After=B</code>。</p><p>在<code>[Unit]</code>段中，用于表示依赖关系的选项有<code>Wants</code>、<code>Requires</code>、<code>BindsTo</code>和<code>PartOf</code>，他们所表示的依赖关系的强弱可以大致表示为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PartOf = BindsTo &gt; Requires &gt; Wants</span><br></pre></td></tr></table></figure><p><code>Wants</code>的依赖关系最弱，当依赖的单元启动失败时，不会对其他单元的启动造成影响；<code>Requires</code>所指定的单元中有一个启动失败时，其他相关的单元都不会被启动；<code>BindsTo</code>的依赖性比<code>Requires</code>更强，当启动使用了<code>BindsTo</code>的单元时，<code>BindsTo</code>所指定的单元均会被启动，当列出的单元全部被启动后，该单元也会被启动，但是如果指定的单元中任意一个终止或重启，该单元也会终止或重启；<code>PartOf</code>类似于<code>BindsTo</code>，不同的是，使用<code>PartOf</code>的单元不会随着依赖单元的启动而启动。</p><p><strong>为启动的服务设置环境变量</strong></p><p>可以在单元配置文件的<code>[Service]</code>段落中添加<code>Environment</code>选项，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Environment=LANG=zh_CN.UTF_8</span><br></pre></td></tr></table></figure><p>如果需要添加多个环境变量，<del>应在<code>[Service]</code>中添加多个<code>Environment</code>，而不是在一个<code>Environment</code>后面添加多个环境变量的值。</del> 可以在<code>[Service]</code>中添加多个<code>Environment</code>，也可以在<code>Environment</code>后添加多个环境变量的定义，使用空格分隔，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Environment=PATH=/home/jack CONFIG=&apos;-std=c99&apos;</span><br></pre></td></tr></table></figure><p>对没错也可以使用<code>&#39;</code>，可以查看man手册的<a href="http://jlk.fjfi.cvut.cz/arch/manpages/man/systemd.service.5.en#COMMAND_LINES" target="_blank" rel="noopener">相关章节</a>获得更多信息。</p><p>也可以使用<code>EnvironmentFile</code>选项指定一个包含环境变量列表的文件路径，这个文件中每一行都是一个环境变量的值。例如，单元文件中<code>[Service]</code>字段包含选项如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EnvironmentFile=/home/jack/env</span><br></pre></td></tr></table></figure><p><code>/home/jack/env</code>文件包含内容格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LANG=zh_CN.UTF-8</span><br><span class="line">CONFIGPATH=/home/jack/.config/config</span><br></pre></td></tr></table></figure><p><strong>设置运行服务的用户和组</strong></p><p>在单元配置文件的<code>[Service]</code>段落中添加<code>User</code>和<code>Group</code>选项即可，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User=Jack</span><br><span class="line">Group=Jack</span><br></pre></td></tr></table></figure><p><strong>设置服务的工作路径</strong></p><p>在单元配置文件的<code>[Service]</code>段落中添加<code>WorkingDirectory</code>选项，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WorkingDirectory=/home/Jack/</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>经过了激烈的讨论之后绝大多数发行版还是迁移到了<code>Systemd</code>，这个东西确实符合UNIX<code>keep it simple and stupid</code>的哲学，而是一个大而全的东西。<code>Systemd</code>出现后接管了Linux上包括启动日志在内的很多东西，造成使用者们之前掌握的一部分技能在这上面不顶用了，这会不会也是<code>Systemd</code>出现后遭到抵制的原因之一呢。</p><p>更多<code>Systemd</code>的相关资料可以查看man手册的<a href="http://jlk.fjfi.cvut.cz/arch/manpages/man/systemd.1" target="_blank" rel="noopener">systemd章节</a>，以及ArchLinux Wiki页面中关于<a href="https://wiki.archlinux.org/index.php/Systemd" target="_blank" rel="noopener">Systemd的部分</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前我所掌握的使一个Linux下的软件开机自启动的方法只有将其加入&lt;code&gt;rc.local&lt;/code&gt;文件或桌面环境的&lt;code&gt;autostart&lt;/code&gt;文件中，但前者不能很好的保证软件的依赖关系，后者要求系统具备桌面环境。虽然知道现在大多数发行版已经使用&lt;code&gt;systemd&lt;/code&gt;来管理系统服务，但一直没有研究过如何编写其单元文件，为了解决上述问题，研究了一下&lt;code&gt;systemd&lt;/code&gt;的&lt;code&gt;service&lt;/code&gt;单元文件的写法，将遇到的问题做个总结。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>在树莓派上使用 PN532 NFC读卡器[1]——Mifare Classic 1K 协议解析</title>
    <link href="https://www.tiehichi.site/2017/09/18/nfc_1/"/>
    <id>https://www.tiehichi.site/2017/09/18/nfc_1/</id>
    <published>2017-09-18T00:00:00.000Z</published>
    <updated>2022-06-15T07:21:11.284Z</updated>
    
    <content type="html"><![CDATA[<p>本系列的<a href="http://tiehichi.site/2017/07/04/archives/nfc_0/" target="_blank" rel="noopener">上一篇文章</a>讲了libnfc的安装与配置，这篇文章将着重分析Mifare Classic 1K卡的存储结构。</p><a id="more"></a><h3 id="Mifare-Classic-卡的存储结构"><a href="#Mifare-Classic-卡的存储结构" class="headerlink" title="Mifare Classic 卡的存储结构"></a>Mifare Classic 卡的存储结构</h3><p>Mifare Classic 卡的容量分为三种，1K、2K和4K，我只用过容量为1K的，即S50卡，后面两种卡据说只是容量不同，存储格式一样。</p><p>Mifare卡的存储有扇区（Sector）和块（Block）两个概念，对于1K卡来说，其容量共1024字节，这1024个字节被分为16个扇区，每个扇区有4个块，每个块16字节，如下图所示：</p><p><img src="https://i.loli.net/2019/01/05/5c3079223c3a3.png" alt="mfs50storage.png"></p><ul><li><p><strong>厂商数据块</strong></p><p>  Mifare卡的存储空间中，第0扇区的第0块为厂商数据块，该块是只读的，不过据说有一种<code>Chinese Magic Card</code>是可以修改该数据块的。</p><p>  该块中，0-3字节为UID，每张Mifare卡都拥有唯一的UID，所以很多小区的门禁系统使用UID作为门禁卡的标志来认证门禁卡，比如我们小区；第4字节据说是校验位，但我不清楚它是怎么进行校验的；第5字节为SAK，又称卡片容量，我不知道其他卡该字节的值是多少，我手上的Mifare卡该字节均为<code>0x08</code>；第6-7字节是<code>ATQA</code>应答字节，好像也经常被称为卡片类型，因为Mifare Classic 1K卡的<code>ATQA</code>均为<code>0x0004</code>（Mifare协议使用小端约定，低字节存放在低地址，高字节存放在高地址，即第6字节为<code>0x04</code>，第7字节为<code>0x00</code>）；剩下的第8-15字节我也不知道是啥，我手里的多张卡读出来的值均为<code>0x62 0x63 0x64 0x65 0x66 0x67 0x68 0x69</code>。</p><p>  第0扇区第0块的结构如下图所示：</p><p>  <img src="https://i.loli.net/2019/01/05/5c3079447721e.png" alt="mfs50block0.png"></p></li><li><p><strong>密钥块</strong></p><p>  Mifare卡中每个扇区的最后一个Block为密钥块，又叫做尾块（<code>Sector Trailer</code>），该Block中存放了对应扇区的认证密钥以及权限设置，密钥块的结构如下图所示：</p><p>  <img src="https://i.loli.net/2019/01/05/5c30797485468.png" alt="mfs50trailerblock.png"></p><p>  该块中，前6个字节与最后6个字节分别为密钥A和密钥B，当卡片出厂时，两个密钥均被设置为<code>0xFF 0xFF 0xFF 0xFF 0xFF 0xFF</code>，如果读密钥时，权限不足或认证失败则读出的值全为0。</p><p>  密钥块中，第6-9个字节为权限位，指明对应扇区相应的权限，其默认值为<code>0xFF 0x07 0x80 0x69</code></p></li><li><p><strong>数据块</strong></p><p>  除了密钥块和厂商数据块以外的Block为数据块，普通数据块可以作为可读写块或数值块，可读写块可以进行一般的读写操作，没什么特殊的，比较特殊的是数值块。</p><ul><li><p><strong>数值块</strong></p><p>  将普通数据块格式化为数值块后，可以把卡片当做电子钱包使用，其除了读写操作外，还可进行增值、减值、存储和传输操作，数值块的数据格式如下：</p><p>  <img src="https://i.loli.net/2019/01/05/5c3079a24b629.png" alt="mfs50valueblock.png"></p><p>  根据官方文档的说法，为了保证数据的可靠性，在一个数值块中，数值存储三次，一次取反，两次不取反；地址存储四次，两次取反，两次不取反。</p><p>  例如：将<code>Sector 0 Block 2</code>设置为数值块，其值设置为十进制<code>200</code>，则<code>block 2</code>中的数据为：<code>00 00 00 C8 FF FF FF 37 00 00 00 C8 02 FD 02 FD</code></p></li></ul></li></ul><h3 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h3><p>前面说到S50卡中，通过扇区尾块的权限位（<code>Access Bits</code>）来控制一个扇区相应的权限，权限位为尾块中的第6-9个字节。每个扇区中对应的Block的权限由三个位控制，表示为 C1<sub>n</sub> C2<sub>n</sub> C3<sub>n</sub>。例如Block 0的权限位表示为：C1<sub>0</sub> C2<sub>0</sub> C3<sub>0</sub></p><p><img src="https://i.loli.net/2019/01/05/5c3079c4bbbd3.png" alt="mfs50accessconditions.png"></p><p>权限位在尾块中的存储结构如下图所示：</p><p><img src="https://i.loli.net/2019/01/05/5c3079e055a4a.png" alt="mfs50accessbitsstruct.png"></p><p>如果需要修改扇区中某个块的访问权限，需要根据控制条件修改权限位并存储到对应扇区尾块的<code>Access Bits</code>区中，数据块的控制条件如下图所示：</p><p><img src="https://i.loli.net/2019/01/05/5c3079fde1d19.png" alt="mfs50dbaccess.png"></p><p>上图中Access Bits列表示权限位的组合，Access conditions for列表示进行对应操作时需要认证的密钥，<code>never</code>表示不可进行对应操作。Application列表示应用在何种类型的操作或数据块上。</p><p>需要注意的是，尾块的权限控制与数据块不同，尾块的控制条件如图：</p><p><img src="https://i.loli.net/2019/01/05/5c307a1a6f26d.png" alt="mfs50tbaccess.png"></p><div class=tip>如果不需要使用key B，可在尾块中将key B的存储空间当做数据块使用，但需要配置相应的权限。</div><h3 id="卡片认证流程"><a href="#卡片认证流程" class="headerlink" title="卡片认证流程"></a>卡片认证流程</h3><p>当对S50卡的一个Block进行操作时，需要根据其权限的设置来选择对应的密钥进行认证，其认证流程如下：</p><ol><li><p><strong>选卡</strong></p><p> 当S50卡进入PN532的可通信范围后，需要控制PN532选择卡片进行通信，如果有多张卡同时进入可通信范围，需要抗干扰算法选择其中一张进行通信。</p></li><li><p><strong>认证</strong></p><p> 当PN532与S50卡之间建立通信连接后，需要根据权限位选择对应的密钥对扇区进行认证，如果认证失败，则需要断开连接重新选卡才能再次认证。</p></li><li><p><strong>操作</strong></p><p> 认证成功后可以对已经认证的扇区进行操作，操作完成后断开连接即可进行下一次选卡。</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从上一篇到现在拖了将近两个月，目睹了大佬们的博客之后还是把这篇写出来了……下一篇将着重总结一下libnfc控制PN532的具体代码，先列标题：<strong>在树莓派上使用 PN532 NFC读卡器[2]——libnfc 控制PN532</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列的&lt;a href=&quot;http://tiehichi.site/2017/07/04/archives/nfc_0/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;上一篇文章&lt;/a&gt;讲了libnfc的安装与配置，这篇文章将着重分析Mifare Classic 1K卡的存储结构。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
